########################################################################
#
#  Disassembly listing of binary 'A9L' (8061, 1 bank)
#
#  See 'A9L_msg.txt' for warnings, command list and other info
#
########################################################################
 
########################################################################
# OVERALL MEMORY MAP
########################################################################
#
# 0000-00FF   Direct page (on-chip registers)
# 0000-0001    Constant 0
# 0002-000F    IO registers
# 0010-0011    Stack pointer
# 0012-00FF    General registers
#
# 0100-04FF   RAM (off-chip)
#
# 0700-07FF   Keep-alive memory (off-chip)
#
# 092F        Off-Chip Input Port of 81C61 RAM-I/O (low 5 bits active)
# 0930        ROM Port of 8763 (low 5 bits are parallel I/O)
# 
# 0C80?-1FF7? Calibration Console (factory use)
# 
# 2000-9FFF   ROM
# 2000         CPU startup address 
# 2010-201F    Interrupt vectors
# 2020         # of calibration levels
# 2021         # of calibrations
# 2022-2031    Calibration level base address table
# 2032-8BFF    Executable strategy
# 8C00-9FFF    Calibration data
#
# C000-DFFF   Calibration console (factory use)
# E000-FFFF   Engineering console (factory use)
#

#################################################################################################### 
# Disassembly of Ford A9L EECIV
# Comments shamelessly stolen from various web listings and merged here
# Then mangled some more and correlated with GUFB strategy document
#  by Chuck Fry, chucko@chucko.com
# 15Mhz Clock (.2 us per CPU state, 2.4 uS per HSI/HSO 'tick')
# CPU regs 0-ff, RAM 100-4ff, KAM 700-7ff, ROM 2000-9fff
#####################################################################################################
#
# AD Channels:
# 0 TAR  1 VCAL  2 VPWR  3 OCC  4 SCCS  5 EGO2  6 MAF  7 TP  8 ECT  9 ACT A NDS/A3C/HW  B EGO1  C EVP
#
# I/0 mappings:
# bitno or chan   0      1      2      3      4      5      6      7      8      9      A             F
# HSO channels:   INJ3   INJ4   INJ6   INJ7   INJ5   SPOUT  INJ1   INJ2   INJ8   KTS    S/W 1 (1ms)   S/W 2 (console, 5ms)
#
# HSI: (bit) in:  PIP    KI     BP     STI    BOO    CID    VSS    IDM
# LSO: (bit) out: SCVAC  DOL    EVR    ISC    SCVNT  MIL    ACC/WD FP
# LIO: (bit) out: ?      CANP
#            in:  PSPS   ?
# 92F: (bit) out: SHIFT  TAB    TAD    Fan    Hi_fan
# 930: (bit) in:  ECADI  ?      FPM    ?      ?
#
# ADC inputs:
#  TAR   Throttle Angle Rate
#  VCAL  Calibration voltage, 1/2 ADC Vref (nominally 2.5 volts)
#  VPWR  Ignition key-on power (battery voltage)
#  OCC   Open Circuit test voltage (0 V)
#  SCCS  Speed Control Command Switch (not present on A9L)
#  EGO2  LH Exhaust Gas Oxygen sensor
#  MAF   Mass Air Flow sensor
#  TP    Throttle Position sensor 
#  ECT   Engine Coolant Temperature sensor
#  ACT   Air Charge Temperature sensor
#  NDS/A3C/HW  Multiplexed input:
#        Neutral Drive Switch (NDS): PRNDL (AUTO) or Clutch/Neutral (Manual);
#        A3C: Air Conditioner Compressor Cycling;
#        HW: Heated Windscreen (not present on A9L)
#  EGO1  RH Exhaust Gas Oxygen sensor
#  EVP   EGR Valve Position sensor
#
# HSO outputs:
#  INJn  Fuel Injectors 1 through 8
#  KTS   Knock sensor enable (not used on A9L)
#  SPOUT SPark OUTput signal
#  S/W   software timer interrupt - timer 1 every 1 millisec, timer 2 for calibration console use (typ. 5ms)
#
# HSI inputs:
#  PIP   Profile Ignition Pickup
#  KI    Knock Indicated (not present on A9L)
#  BP    Barometric Pressure sensor
#  STI   Self Test Input
#  CID   Camshaft Cyl No 1 IDentifier sensor (not present on A9L)
#  VSS   Vehicle Speed Sensor
#  IDM   Ignition Diagnostic Monitor (Tach, SPOUT loopback)
#
# LSO outputs: 
#  SCVAC   Speed Control Vacuum (cruise control servo) (not present on A9L)
#  DOL     Data Output Link (used by optional TripMinder info display)
#  EVR     EGR Vacuum Regulator
#  ISC     Idle Speed Control (Throttle bypass air solenoid)
#  SCVNT   Speed Control Vent (cruise control servo) (not present on A9L)
#  MIL     Self Test Output / Malfunction Indicator Light
#  ACC/WD  LOS WatchDog - must be flipped every 4 ms - also used for ACC cutoff
#  FP      Fuel Pump
#
# BIDI inputs:
#  PSPS  Power Steering Pressure Switch (not present on A9L)
#
# BIDI outputs:
#  CANP  Canister Purge
#
# RAM-I/O inputs:
#  ECADI Electronically Controlled Accessory Drive Input (not present on A9L)
#  FPM   Fuel Pump circuit Monitor
#
# ROM port outputs:
#  SHIFT Shift light/indicator (not present on A9L)
#  AM2   Air management solenoid 2 (Thermactor Air Diverter)
#  AM1   Air Management solenoid 1 (Thermactor Air Bypass)
#  FAN   engine coooling fan (not present on A9L)
#  FANHI Hi speed cooling fan (not present on A9L)
#
###############
# Register mappings:  Address, [Bit], Name,  notes 
#################
# standard I/O int regs etc (0-0x11)
# 0  read: Always zero (word)
#    write: ignored (word)
# 2  LSO_Port   write:     bits  0 SCVAC  1 DOL  2 EVR  3 ISC  4 SCVNT  5 MIL  6 CPU_OK (watchdog)  7 FP
# 3  LIO_Port   read:      bits  0 PSPS   1 ?
#               write:     bits  0 ITS ?  1 CANP
# 4  read: AD_Low          write: AD_Cmd
# 5  read: AD_High         write: WDG_Timer
# 6  read: IO_Timer (word) write: ignored
# 8  read/write: INT_Mask  bits  0 HSO2  1 IO_Tmr_Ovfl  2 AD_Cvt_Done  3 HSI_Data_avail  4 Ext_INT  5 HSO1  6 HSI1  7 HSI0
# 9  read/write: INT_Pend  (same)
# a  IO_Status             bits  0 HSO_OVF  1 HSI_OVF  2 HSI_Ready  3 AD_Ready  4 INT_Service  5 INT_Prio (not used)
# b  HSI_Sample            bits  0 PIP  1 KI  2 BP  3 STI 4 BOO 5 CID  6 VSS  7 IDM
# c  HSI_Mask              (same) 1 = interrupt enabled
# d  read:  HSI_Data       bits  0 PIP  1 KI  2 BP  3 STI  5 CID  6 VSS  7 IDM
#    write: HSO_Cmd
# e  read:  HSI_Time (word)
#    write: HSO_Time (word)              
# 10 Hardware Stack Pointer (word)
#
# 12 Tmr_OVF_cnt           (word)
#
# 14 - 23 background loop working registers
#
# 24 Flags_24             
#  0 Wot                   At Wide Open Throttle (not mentioned in GUFB); 0 = increment NWOTMR every second
#  1 Ctnq                  set if RPM < INLRPM + FN880(CTNTMR); cleared if RPM > INLRPM + INLRPH + FN880(CTNTMR) - GUFB p. 20-14
#  2 AWOTMR_On             1 = increment AWOTMR every second (At Wide Open Throttle)
#  3                       not used?
#  4 Console_init          1 = Initialize calibration console if present
#  5 NACTMR_On             1 = increment NACTMR every second (Not At Closed Throttle)
#  6 ATMR2_On              1 = increment ATMR2 every second
#  7 TSEGRE_On             1 = increment TSEGRE every second (Accumulated Time EGR Enabled)
# 25 Flags_25             
#  0                       not used?
#  1 WARM_UP               Set if TCSTRT < VECT5, ECT > VECT3, and run mode
#  2 Mhpfd_neg             Part of signature PIP logic (will always be 0 for A9L)
#  3 FAM_FLG               1 = In Filtered Air Mass region (idle control strategy)
#  4 Slq2                  Speed Limiter
#  5 Slq1                  Speed Limiter
#  6 CHKAIR                Thermactor logic
#  7 Chkair_flag           Thermactor logic
# 26 Flags_26             
#  0 IMFMFLG               MAF count out of range error
#  1 Archflg               Manifold filling logic enabled (GUFB pp. 19-20 - 22)
#  2 NFLG                  Neutral idle flag.
#  3 JMPFLG                In Filtered Air Mode (idle) region (GUFB p. 6-34)
#  4 Trsprpml              RPM above Transient Spark threshold
#  5                       not used?
#  6 DNDSUP                Drive/Neutral flag 
#  7 HCAMFG                Hi Cam Idle adders active
# 27 Flags_27             
#  0 SWTFL2                EGO 2 cross detected
#  1 DFSFLG                Decel Fuel Shut Off active
#  2                       not used?
#  3 SWTFL1                EGO 1 cross detected
#  4 POWSFG                Power Steering Pressure Switch Flag
#  5                       not used?
#  6 LESTMR2_On            1 = count up LESTMR2
#  7 LESTMR1_On            1 = count up LESTMR1
# 28 Flags_28             
#  0 EGREN                 Egr enabled (zero at cranking)
#  1 PTPFLG                PIP occurred after 50 msec.                
#  2 Newsa                 New Spark Advance calculation required
#  3 EFFLG1                Equilibrium Fuel Flag, used in transient fuel calculation
#  4 Ramp_rich             Used only in self test?
#  5                       not used?
#  6                       not used?
#  7 KAM_ERROR             1 = KAM error detected
# 29 Flags_29             
#  0 HLTMR_Off             0 = increment HLTMR every 1/8 sec
#  1 Taq6                  Load below DNLOD (see GUFB p. 12-8)
#  2 Qtpclol               1 = throttle below open loop threshold, 0 = above threshold + hysteresis
#  3 Taq1                  ECT and ACT high enough to force open loop fuel (see GUFB p. 12-7)
#  4 Iacflg                Inlet Air Control flag (only active if THRMHP = 3, i.e. not on A9L)
#  5 AEOFLG                1 = Manifold filling (GUFB p. 6-58)
#  6 Evpout                ??? Set by Read_AD at exit, never referenced???
#  7 EGRFLG                1 = EGRDC has been incremented by DCOFF
# 2a VIP_flags             VIP mode flags (diagnostic testing flags)
#  0 VSCDT                 VSCDT Vehicle Speed Control dynamic test enable
#  1 Vscst                 Vehicle Speed Control Self Test ?
#  2 Vip_enable            VIP enable (self tests?) set after engine running for 10 seconds?
#  3 Disable_running       disable - 'running' after reset - never cleared
#  4 Disable_nostart       Set if hardware fault detected ? - never cleared
#  5 RUNNING               engine is running in self test mode (KOER)
#  6 No_start              indicates KOEO test in progress (engine off)
#  7 Disable_vscdt         disable VSCDT after reset - never cleared
# 2b Flags_2B              - flags
#  0 Rvip_cyl_quit         Self Test Output trigger
#  1 Rvip_cyl_bal          Passed Cyl Balance Test ?
#  2 Sto_trigger           Self Test Output trigger - to turn off STO
#  3 Error_detected        Self test error marker
#  4 Disable_isc           Disable Idle Speed Control if set
#  5 STIFLG                STI input state
#  6 Egoste2               HEGO2 cross over voltage detected
#  7 Egoste1               HEGO1 cross over voltage detected
# 2c Flags_2C             
#  0 IDM_BYPASS            0 = TSLIDM is time since last IDM; 1 = TSLIDM is time since IDM_BYPASS set to 1
#  1 Kflg_local            1 = Knock sensor present (self test only?)
#  2                       not used?              
#  3 Wigflg                KOEO wiggle mode?
#  4 Sto_hyper             Sets STO time to 2mS instead of 0.5 secs ?
#  5 Disable_eolt          1 = disable MIL self test
#  6 EGRFG2                Flags for continuous self test of EGR system
#  7 EGRFG1                ""
# 2d Flags_2D             
#  0 Spout_pending         part of spark logic
#  1 Undsp_trans           1 = UNDSP changed state
#  2 Dual_edge             1 = use Falling-Edge spark timing; 0 = use Rising-Edge spark timing (high RPM)
#                           Cleared in PIP High handler; set or cleared in Spark_calc
#  3 No_fuel_save          1 = tell Sub8 not to save HSO_time in injector table
#  4 FIRST_PIP             Clear at startup and by Update_rpm background task on stall;
#                           set by PIP rising edge handler first time through
#  5 CTFLG                 Set when throttle closed and LOAD < TIPLOD; cleared when LOAD > TIPLOD + TIPHYS
#  6 TIPFLG                1 = Tip-in in progress (used in tip-in retard logic)
#  7 Tblsflg               Input to table lookup routine              
# 2e Flags_2E             
#  0                       Not used?
#  1                       Not used?
#  2 New_ibeta             
#  3 Simultaneous          0 = sequential injection, 1 = bank fire (e.g. crank);
#                           cleared in PIP rising edge handler when DT12S <= Seq_max, Foreground_Fuel when SYNC_UP_FUEL == 1
#                           set in Foreground_Fuel when CRKFLG == 1
#  4 SYNC_UP_FUEL          Fuel synchronization requested
#                           cleared or set in PIP falling edge handler, CID handler;
#                           cleared in Update_RPM background task on stall
#  5 Base_fuel
#                           Set or cleared in Schedule_Injectors; checked in Do_inj?
#  6 SYNFLG                0 = not in sync; 1 = Signature PIP or CID syncs w/ cylinder #1.
#                           Initialized to 0, cleared in Update_RPM background task on stall;
#                            cleared or set in PIP falling edge handler, CID handler
#  7 FUEL_IN_SYNC          Fuel synchronized with PIP
#                           cleared at startup, PIP falling edge handler, CID handler, Update_RPM background task on stall;
#                           set in Foreground_Fuel
# 2f Flags_2F             
#  0                       Not used?
#  1                       Not used?
#  2                       Not used?            
#  3 NLMT_FLG              1 = Rev limiter fuel cutoff
#  4 PTSCR                 Part throttle mode since exiting crank                 
#  5 Maf_pip               1 = MAF read during PIP high interrupt, 0 = 1ms interrupt
#  6 New_idelay2           
#  7 New_idelay1           
#
# 30 - 43                  Working registers, some used as function inputs/outputs
# 30
# 32
# 34
# 36
# 38                       Return value for some table lookup functions
# 3a
# 3b                       Return value for some table lookup functions
# 3c                       Return value for Get_par
# 3e                       Return value for rolling average functions
# 40                       Return value for various fuel calculations
# 42                       Return value for various fuel calculations
# 
# 44 HSOut_Flags           State of HSO (Output) lines (WORD)
#  0 Inj3_State            
#  1 Inj4_State            
#  2 Inj6_State            
#  3 Inj7_State            
#  4 Inj5_State            
#  5 Spout_state           
#  6 Inj1_State            
#  7 Inj2_State            
#  8 Inj8_State            
#  9 KTS_State             (not used in A9L)
#
# 46 IO_Port_State         LSO image - sets LSO (R2) bits from this register
#  0 SCVAC                  Speed Control VACuum - increase throttle
#  1 Dol                    Data Output Link - to trip computer                  
#  2 Evr                  
#  3 Isc                  
#  4 SCVNT                  Speed Control VeNT - release throttle
#  5 Sto_state             
#  6 WOT_AC                
#  7 Pump                  
# 47 Flags_47              bidirectional IO (output) image - sets Low speed IO (R3)
#                            and Off Chip Port from this register
#  0 ???                    LIO 0 - always on?
#  1 Canp                   LIO 1
#  2 ShLight_On             OCP 0 - Shift Light (not used on A9L)
#  3 TAB                    OCP 1 - Air mgmt 1 - on A9L, Thermactor Air Bypass (1 = bypassed)
#  4 TAD                    OCP 2 - Air mgmt 2 - on A9L, Thermactor Air Diverter (1 = upstream)
#  5 Fan                    OCP 3 - Electric Fan on (not used on A9L)
#  6 Hi_fan                 OCP 4 - High Speed Fan on (not used on A9L)
# 48 Flags_48
#  5 HSO_CAM_Full          HSO CAM overflow occurred - only set by HSO 2 (calibration console) timer interrupt handler
#  7 CHANGE_FUELPW         Current injector pulsewidth needs to be updated
# 49                       MUST BE 0 (see 0x26a8)
# 4A                       not used?
# 4B                       not used?
# 4c Flags_4C              HSO mode/status (input/output to Send_HSO_Cmd())
#  0 ???                   (Input) not used?
#  1 Bypass_time_check     (Input) Skips time check (set with Immediate?)
#  2 Bypass_limit          (Input) Set to disable max event count (12) in each time slice
#  3 Immediate             (Input) Request / (Output) Commanded to cause immediate HSO interrupt
#  4 No_service            (Output) Failed to schedule event (CAM full and No_queue set)
#  5 Late_output           (Output) Requested HSO event will be late
#  6 Queued                (Output) Events are queued (software queue)
#  7 No_queue              (Input) Used by queue management
# 4d                       not used?
# 4E Flags_4E              HSI bit flags
#  0 Hsi_error             Indicates an unexpected HS Interrupt Occurred (set but never used)
#  1 Kts_pending           See Knock Detection Logic @ 0x6c9f
#  2 New_Bpv               New BAP average calc required 
#  3 New_rpm               new RPM calc reqd
#  4 New_idm               new IDM
#  5 New_sti                - etc -
#  6 NEW_BAP               BP sensor changed state
#  7 New_pip               Set in PIP high interrupt handler,
#                           cleared in Set_ign_timers background routine
# 4F Flags_4F              
#  0 Pip_double            Tracks Dual_edge (see 0x282e - 0x2836);
#                           0 = use rising edge spark timing, 1 = use falling edge;
#                           updated on rising edge of PIP
#  1                       Not used?
#  2 Clkext_ovr            Timer overflow count has wrapped around (32 bit = 171.8 mins)
#                           (set, not read?)
#  3 KNOCK_DETECTED        
#  4 Pending               1 = injector pulsewidth update pending?
#                           Set or cleared in Sub7; cleared in UPd_Inj_pend; tested in Sub6
#  5                       Not used?
#  6 KNOCK_ENABLED         Also called KNOCK_ENABLE in GUFB doc
#  7 KNOCK_OCCURRED        
# 50-5B                    INTERRUPT HANDLER WORKING REGISTERS
# 5C                       INTERRUPT HANDLER STACK, 11 (decimal) words
# ...                      In low registers for speed
# 70                       1st word of interrupt stack
# 72 Rp                    = 0x180 RAM Pointers, used as "Base+Offset" for indexed instructions
# 74 Rp2                   = 0x27e
# 76 Rp3                   = 0x37a 
# 78 Cp                    Constant - Pointer to ROM 8eda - Self-test constant base
# 7a Event_time            24-bit time of most recent HSI interrupt
# 7c Event_timeH           ...
# 7d Cmd                   Image of command sent by Send_HSO_Cmd
#  0-3                      Channel #
#  4                        1 = set output high 0 = set output low
#  5                        1 = generate output interrupt #1 0 = don't
#  6                        S/w flag, meaning not yet determined
#  7                        See Do_CmdP
# 7e Rtab                  Offset into RAM HSO queue
# 7f                       Always 0 (upper 8 bits of Rtab) - see 0x261d
# 80 HSO_time              Calculated HSO Time (for any output via HSO) 
# 82 HSO_timeH             Calc HSO Time top 8 bits
# 83 HSI_State             HSI_Data temp (only used in Read_hsi subroutine)
# 84-86                    Temporaries for time in interrupt handlers
# 87 New_irqs              Image of HSI_Data bits CHANGED since last HSI Interrupt
#  0 Pip_irq              
#  1 Knk_irq               these set for handler reqd.
#  2 Bap_irq              
#  5 Cid_irq              
#  6 Mph_irq              
#  7 Idm_irq              
# 88                       Used as ROM pointer in HSO output routine (cell no) 
# 8a                       Used as RAM pointer in HSO output routine (cell no) 
# 8C Reftime               master reference time, 24 bits
# 8e ReftimeH              master reference time, 24 bits
# 8f Wd_time               Time delta for watchdog reset
# 90 Last_HSI              Saved most recent HSI_Data value
# 91 Slice_ptr             Index into Slice_0 table of 8 entries, range 0-7
# 92 TPtr                  pointer to HSO or Injection entries in tables in RAM (HSOTable, InjTTab)
# 94 - 97                  Working registers for HSO 1 (1ms timer) interrupt handler
#
# 98 - 99                  not used(?)
# 9a Bg_offset             Offset of next routine address in background loop table (0 - a2)
# 9b Vsc_count             Part of Vehicle Speed Control logic
# 9c ANPIP1                # of PIPs since last EGO #1 switch
# 9d ANPIP2                # of PIPs since last EGO #2 switch
# 9e EFTR                  Transient Fuel Compensation flow rate
# a0 Vsc_states           
#  0 VSC_PULSE             Background flag indicating that a dither pulse is in progress.
#  1 ACC_REQ               Flag set when ACCEL button pressed
#  2 HOLD_STATE            1 = maintain speed
#  3 RESUM_STATE           Flag set when RESUME button pressed
#  4 ACCEL_STATE           1 = VSC is accelerating
#  5 BRAKE_STATE           Flag set when brake pedal pressed
#  6 COAST_STATE           Flag set when COAST button pressed
#  7 ON_STATE              1 = VSC enabled
# a1 a1_Flags             
#  0 ADPTMR_On             engine at operating temp ( 170 < temp < 226 ) 
#  1 Idleq                 RPM in idle region - set when N < IDLRPM, cleared when N > IDLRPM + IDLRPH
#  2 UNDSP                 1 = N < UNRPM; 0 = N >= UNRPM + UNRPMH
#                           Set or cleared in background task set_rpm_flgs
#  3 DMFLG                 Decel fuel low load timer enable
#  4 Egronflg              1 = EGR rate >= MINDES + DESHYS; 0 = rate < MINDES (PFE EGR only)
#  5                       Cleared, never set?
#  6 CTTMR_On              At Closed Throttle timer enable
#  7 CRKFLG                Set when N < NSTALL; cleared when N > NRUN 
# a2 AM                    Air mass flow rate, units .426 kg/hr
# a4 AMPEM                 Air mass + EGR mass flow rate
# a6 NRMCES                (Temporary) Column number for 2D table lookup
# a8 NRMRLD                (Temporary) Row number for 2D table lookup
# aa TP                    Throttle position
# ac TCSTRL                Low bits of TCSTRT intermediate calculations
# ad TCSTRT                Coolant temp at cold start, degrees F / 2
# ae N                     Engine RPM x 4
# b0 ECT                   Engine Coolant Temperature, degrees F / 2
# b1 ACT                   Air Charge Temperature, degrees F / 2
# b2 MPHCNT                
# b3 PPCTR                
# b4 PIPCNT                # of PIP rising edges since entering crank mode
# b5 Vsc_switches          State of cruise control switches
#  1 VSCCS_ERROR           Input voltage out of range
#  3 RESUM_BUT             Resume Button Pressed
#  4 ACCEL_BUT             Accel  Button Pressed
#  5 COAST_BUT             Coast  Button Pressed
#  7 OFF_BUT               Off    Button Pressed
# b6 BAPCNT                MAP(BP) counts since last check
# b7 Ifreq                 ISC output counter
# b8 ISCDTY                required ISC duty cycle
# ba DT12S                 Most recent PIP cycle time in ticks, low 16 bits
# bc DT12SH                Most recent PIP cycle time, upper 8 bits
# bd KAYCTR                A counter to indicate how often to update MKAY (linked to PIPs per rev)
# be HFDLTA                PIP high pulsewidth
# c0 MKAY                  Half period multiplier.  Corrects for average error caused by hall effect sensor in distributor and armature.
# c2 SAF                   Final spark advance (before knock adjust), crank degrees BTDC x 4
# c4 Vsc_flags            
#  0 Code_87               
#  1 Vsc_flags             
#  2 First_mph             Flag for very first VSS tick received. 
#  3 Vsc_state             
#  4 Vscq2                  
#  5 Vscq1                 
#  6 Vsc_vac_active        
#  7 Vsc_flags             
# c5 Fmem_flags            Failure Mode Effects Management flags
#  1 BFMFLG                1 = BP sensor failed
#  2 PEFMFG                Last value of EFMFLG
#  3 MFMFLG                1 = MAF sensor failed
#  4 TFMFLG                1 = TP sensor failed
#  5 AFMFLG                1 = ACT sensor failed
#  6 EFMFLG                1 = EVP or PFE sensor failed
#  7 CFMFLG                1 = ECT sensor failed
# c6 DOL_COUNT             Used in Data Output Link bit-banging
# c8 ATMR1                 Seconds since start (i.e. time since exiting crank mode, CRKFLG == 0)
# c9 ATMR2                 Seconds since ECT became greater than TEMPFB (ATMR2_On == 1)
# ca Flag_ca              
#  0 Asp_input             Do not use background timer for Filter subroutine call
#  1 Declflg               0 = Increment PPCTR every PIP 1 = Don't (part of DFSO logic)
#  2 Dfldl_hys_flag        Set when LOAD < DFLDL; cleared when LOAD > DFLDH
#  3 Dfsvs_hys_flag        Set when VSBAR >= DFSVS; cleared when VSBAR < DFSVS - DFSVHSH
#  4 Ecadq3                Electrically Controlled Accessory Drive flags (not present in A9L)
#  5 Ecadq2                ""
#  6 Ecadq1                ""
#  7 USAFLG                Thermactor Upstream Air
# cb AWOTMR                Time at WOT, sec. (AWOTMR_On == 1)
# cc NDDTIM                Time since Neutral/Drive Switch State change, sec.
# cd NACTMR                Not at Closed throttle Timer, sec. (NACTMR_On == 1)
# ce MFATMR                Managed Fuel Air Timer, sec.
# cf HQcnt                 Count of events in the HSO hardware queue.
# d0 APT                   At Part Throttle: -1 = closed, 0 = part throttle, 1 = WOT
# d1 SYNCTR                Zeroed at signature PIP falling edge, incremented by 0x20 each PIP rising edge
# d2 Egrdc_w               EGR Duty Cycle, as word
# d3 EGRDC                 High 8 bits of EGR duty cycle
# d4 Vip_code             
# d5                      
# d6 STO_flags            
#  0 High_speed            
#  1 Lowspeed_repeat       
#  2 Low_speed             
#  3 Sto_working           
#  4 Sto_fast              sets STO time to 5 mS instead of 0.5 secs ?
#  5 Sto_code              
#  6 Sto_off               
#  7 Sto_on                
# d7 Tc_flags              Trouble Code Flags
#  0 Code_75               
#  1 Code_74               
#  2 Code_67_94            
#  3 Code_45_92            
#  4 Code_77_91            
#  5 Code_44_73            
#  6 Code_42_72            
#  7 Code_25_41            
# d8 Vip_flags3           
#  0 Sto_holdoff           Part of Self Test Out bit-banging logic
#  1 Vf1                   
#  2 Output_tst_mode       
#  3 Reqflg                
#  4 Sto_pending           Part of Self Test Out bit-banging logic           
#  5 Code_48               
#  6 Vip_kam               Indicates KAM invalid for VIP.
#  7 Threshold_lvl         
# d9 Vip_flags4           
#  0 Vip_fp_override       Prevents fuel pump being checked for timeout (normally 1 sec) 
#  1 Goose                 
#  2 Onedigit_out          
#  3 Vip_knock             
#  4 Kam_codes             
#  5 Vvsfl1                
#  6 Vegrbp                
#  7 RMSPRU                
# da Sto_time             
# dc Pip_counter           Index into SPKADn knock retard table. See GUFB p. 7-40
# de Input_image           HSI changed bits since last read; set but not read anywhere; see R0b for interpretation
# df Flags_df              ROM Input Port and LIO (bidirectional port) changed bits; updated at same time as above (see 0x26E9)
#  0 Psps_lvl              P/S pressure switch (LIO bit 0)
#  1                       (LIO bit 1)
#  2 ECADI                 Electronically Controlled Accessory Drive Input - 1 = half speed mode allowed (not used on A9L) (ROM bit 0)
#  3                       (ROM bit 1)
#  4 FPM                   Fuel Pump Monitor (readback from FP relay) (ROM bit 2)
#  5                       (ROM bit 3)
#  6                       (ROM bit 4)
# e0 Inj_mode              Bit mask per injector, 1 = on
# e1 TIPRET                Tip-in retard               
# e2 RETINC                Knock retard ramp increment, units 1/4 degree/PIP
# e3                       not used?
# e4                       not used?
# e5                       not used?
# e6 Flags_e6             
#  0 HWFLGL                Heated windshield was on at some point since startup
#  1 HWFLAG                Heated windshield is on
#  2 Powoff                Power steering switch self test
#  3 Powon                 Power steering switch self test
#  4 Vhfnon                
#  5 Vlfnon                
#  6 Pfehp_flg             1 if Pressure Feedback EGR Hardware Present
#  7 VPTFLG                1 if at part throttle; used in self tests
# e7 Flags_e7              
#  0 FOFFLG                Very High vehicle speed limiter - fire alternate injectors
#  1 FGFFLG                Flip state for alternate injector firing
#  2 HSPFLG                High speed limiter - richen fuel, retard spark
#  3 FLG_DASMNQ            
#  4 Fulq2                 
#  5 FFULFLG               1 = can use foreground air charge to calculate fuel PW 0 = use BG PW
#  6                       not used?
#  7 NDSFLG                Flag = 0 if transmission in neutral; = 1 if in gear.
# e8 Flags_e8             
#  0 Ctntmr_dwn            Control flags for ctntmr 
#  1 Ctntmr_up             
#  2 CTNFLG                1 = Closed Throttle Neutral               
#  3 Dcelq5                Set when (N-DSDRPM) > DSFRPM; cleared when (N-DSDRPM) <= DSFRPM - DSFRPH
#  4 Dcelq4                Set when (N-DSDRPM) > SHFRPM; cleared when (N-DSDRPM) <= SHFRPM - SHFHYS
#  5 Dcelq3                Set when NACTMR > DSFTM; cleared when 0 < NACTMR <= DSFTM
#  6 Dcelq2                Set when NDSFLG = 1 or TRLOAD < 2; cleared when ...
#  7 Dcelq1                Set when LOAD < DFLOD; cleared when LOAD > DFLOD + DFLODH
# e9 Flags_e9             
#  0 Prld_ff               1 = PERLOAD >= LDMH + LDMHH; 0 = PERLOAD < LDMH (GUFB p. 6-20)
#  1 LDFLG                 1 = lug mode open loop flag
#  2 Lospd_ect             ECT above low speed fan threshold
#  3 Hispd                 ECT above high speed fan threshold
#  4 Crnk_trans            Transition back to CRANK mode (set in set_rpm_flgs, never read)
#  5 HSFFLG                Activate High Speed Fan
#  6 CanPurgeOK            
#  7 CTPTFG                Closed Throttle to PT/WOT transition                
# ea Flags_ea             
#  0 Paccflg               
#  1 BIFLG                 1 = brake on. Only active if BIHP = 1 (not on A9L)
#  2 ACIFLG                1 = A/C clutch engaging soon, bump idle speed
#  3 ACCFLG                1 = A/C clutch engaged
#  4 Acr_n                 
#  5 Acr_ect               
#  6 EGOFL2                EGO 2 Rich (drivers side)
#  7 EGOFL1                EGO 1 Rich (pass side)                
# eb Flags_eb             
#  0 Ol_cl_transition      
#  1 SIGPIP                set when PIP is at narrow slot/signature PIP
#  2 HMTMR_On              1 = increment HMTMR every sec (Thermactor logic)
#  3 CTAFLG                1 = increment CTATMR every second (Thermactor logic)
#  4 Ctupr_flg             
#  5 Acn_flg               
#  6 Acect_flg             
#  7 Acwflg                
# ec Flag_ec              
#  0 MFAFLG                Managed Fuel Air State flag, set to 1 if MFA is being used.
#  1 NEUFLG                Neutral/Drive transition occurred.
#  2 PSFLAG                Power steering switch was on at last check
#  3 REFFLG                Conditions for entering Filtered Air Mass Mode met                
#  4 Tfq1                  
#  5 BPUFLG                Key-on update flag for EPTZER
#  6 SLTMR_flg             Shift light timer flag (not present on A9L)
#  7 SWTFLG                Managed Fuel Air State Flag
# ed Flags_ed             
#  0 LEGOFG2               Lack of EGO 2 switching (drivers side)               
#  1 LEGOFG1               Lack of EGO 1 switching (pass. side)
#  2 Hvq2                  
#  3 Hvq1                  
#  4 Hcsdq                 
#  5 Fpwq1                 
#  6 LUGTMR_dwn            
#  7 LUGTMR_up             
# ee Flags_ee             
#  0 SWTFL                 cache for SWTFLn (1 = HEGO cross detected)
#  1 EGOFL                 cache for EGOFLn (1 = rich)
#  2 OLFLG                 1 = open loop, 0 = closed loop fuel                 
#  3 Qclol                 1 = load above LOLOD, 0 = load below LOLOD - LOLODH
#  4 Signdy                Table lookup fn internal flag
#  5 Signdslp              Table lookup fn internal flag
#  6 INDFLG                Instantaneous Neutral/Drive Flag; 1 = in gear.
#  7 A3C                   Air Conditioning Cycling Switch; 1 = on.
# ef Flags_ef             
#  0 Power_up              
#  1 WMEGOL                WRMEGO was 1 at least once.
#  2 WRMEGO                EGO sensor should be warm flag.
#  3 IDLFLG                
#  4 Byptmr_dwn            
#  5 Lesflg                
#  6 Prgflg                
#  7 Byptmr_up             
#
# f0 = 8c00                Base Pointers to ROM data areas
# f2 = 8e5a
# f4 = 8fd6
# f6 = 93a8
# f8 = 9430
# fa = 97a8
# fc = 9a7e
# fe = 9e5a
#
# RAM locations 
# 100 TPBAR                filtered TP (throttle Position)
# 102 EGRBAR               filtered EVP (Sonic EGR)
# 104 EPTBAR               filtered EPT (PFE EGR)
# 106                      not used?
# 108 NBAR                 filtered RPM, used by self tests
# 10A MDELTA               Delta time (IO ticks) since last MAP/BP interrupt
# 10C IIVPWR               KEYPWR (battery) reference voltage
# 10e IOCC                 Output circuit check ref
# 110 IVCAL                2.5V reference voltage AD
# 112 IECT                 ECT raw AD
# 114 IACT                 ACT raw AD
# 116 IEVP                 EVP raw AD (a.k.a. IEPT)
# 118 IVSCCS               Input Vehicle Speed Control Command Switch (A/D)
# 11A INDS                 NDS/A3C raw AD (multiplexed) (a.k.a. IACC_NDS) 
# 11C IEGO1                HEGO1 raw AD pass side oxygen sensor
# 11E IEGO2                HEGO2 raw AD drivers side
# 120 ITAR                 TAR Throttle position sensor angular rate
# 122 ITP                  TP raw AD
# 124 IMAF                 MAF (raw) (read at 2D33)
# 126 RATCH                Minimum Value when throttle closed (RATCH - from filtered TPS)
# 128 EOFF                 Minimum EVP position (from filtered EVP/EPT)
# 12A CTTMR                Time at closed throttle timer (1/8 secs)
# 12C PURGDC               Canister Purge solenoid duty cycle
# 12F IBAP                 Instantaneous Barometric Pressure (as byte)
# 130 BAPBAR               Filtered Barometric Pressure (as word)
# 132 FFMTMR               FAM timer, msec
# 134 PUTMR                Time since CPU power-up (msec)
# 136 BAPTMR               Time since last background cycle after BAP low-high transition (msec_
# 137 HMTMR                High Power Demand Timer (sec)
# 138 CTATMR               Closed Throttle Upstream Air Timer (sec)
# 139 SLTMR                Shift Light Timer (msec)
# 13A ADPTMR               Adaptive fuel timer (sec)
# 13c MINTIM2              Time of next-to-last BAP low-high transition, ticks
# 13E TSLPIP               Time since last PIP high transition (msec)
# 140 Eighths_ext          Remainder from timer update
# 142 Loop_time            IO_Timer value rounded down to msec boundary at last call to Update_Timers
# 144 CTNTMR               Closed throttle neutral timer for both UP AND DOWN modes
# 145 LUGTMR               LOM load transition timer (sec)
# 146 ISCTMR               RPM sampling timer
# 147 MULTMR               Time since incrementing LAMMUL (msec)
# 148 MFACTR               HEGO switches (?) since SWTFLG = 1
# 149 PRGTMR               Canister purge accumulation timer (sec) (PRGFLG)
# 14A CPRGTMR              Current Purge on time(PRGFLG)
# 14B IMFMCTR              Hysteresis counter for MAF FMEM logic
# 14C HLTMR                High Load Timer (1/8 sec)
# 14d ATMR3                Secs since Entering RUN Mode (UNDSP == 0) i.e. engine running 
# 14E EDFTMR               ElectroDrive Fan Timer (Sec) - 0 when EDF fan off or CRKFLG = 1, otherwise free run
# 14F CRKTMR               Time in CRANK Mode (1/8 sec)
# 150 DLTMR                Decel fuel low load timer (msec)
# 152 RANNUM               Random Number adder; used in adaptive fuel algorithm.
# 154 IPSIBR               Integrated value of closed loop idle speed correction
# 156 SPKMUL               Spark Feedback multiplier used to enhance idle speed control.
# 157 ISCFLG               Current Idle Speed Control Mode: -1 = dashpot; 0 = preposition; 1 = closed loop RPM control; 2 = RPM lockout
# 158 DESMAF               The desired airflow necessary to operate at a specified idle condition.
# 15a DSTPBR               Filtered throttle position - see GUFB p. 9-16               
# 15c DASPOT               Dashpot pre-position airflow register
# 15e FAM                  Filtered Air Mass
# 160 IBGPSI               Idle air integrator background loop counter
# 162 NLAST                Previous value of N, used in ISC mode select logic
# 164 DESNLO               High cam adder to DSDRPM, filtered by TCDESN
# 166 DSDRPM               Target idle RPM
# 168 LAMMUL               Multiplier which is used to prevent cold-engine stalls following transmission engagement.
# 16a BGCNT                Filtered Air Mass background loop counter
# 16b ISFLAG               Degree of loading on engine at idle, range 0-3. See GUFB p. 9-28.
# 16c ISLAST               Previous value of ISFLAG
# 16d                      not used?
# 16e EGRACT               Actual EGR %
# 16f EGRATE               Desired EGR %
# 170 EVP                  EVP sensor voltage after sanity check (also filtered on PFE)
# 172 EGRERR               DELOPT - EVP; signed
# 174 DESDP                Desired downstream EGR pressure (PFE only)
# 176 DELPR                Pressure drop across the EGR control orifice (PFE only)
# 178 Dp                   Downstream pressure (PFE only) - not used?
# 17a PRESER               EPTBAR - CONPR (PFE only) 
# 17c CONPR                Desired PRT sensor value (PFE only)
# 17e DESEM                Desired EGR mass rate
#
# --- R72 points here ---
# 180 INJDLY               Injector delay in degrees x 4
# 182 BASEFF1              Base fuel flow rate for bank 1
# 184 BASEFF2              Base fuel flow rate for bank 2
# 186 EFTRFFL              Lower word of sum of AEFUEL/2 + EFTRFF/2
# 188 EFTRFF               Equilibrium fuel transfer rate for transient fuel compensation
# 18a BASEFFT              Total base fuel flow
# 18c AEFUEL               Accelerator enrichment fuel rate
# 18e PWOFF                Injector pulsewidth offset (ticks)
# 190 Inj_base             Bit mask per injector, 1 = base fuel
#                           Set in Do_inj?; checked & cleared in Sub8
# 191 Inj_pip              Bit mask per injector
#                           Set to 0xFF in PIP_Rising_Edge, bit cleared in Do_inj?, checked in Sub7
# 192 Inj_pending          Bit mask per injector, 1 = injection event pending
#                           Bits cleared in UPd_Inj_pend, set in Do_inj?, checked in Sub7
# 193 PWOFS                Injector pulsewidth offset (1/32 msec)
# 194 BIAS                 Computed EGO bias - result of FN1353(N,LOAD)
# 196 LBMF_INJ1            Fuel mass bank 1 for DOL (Tripminder)
# 198 LBMF_INJ2            Fuel mass bank 2 for DOL
# 19a Lbmf_i1              Table per injector of fuel delivered
# 19c Lbmf_i2              
# 19e Lbmf_i3              
# 1a0 Lbmf_i4              
# 1a2 Lbmf_i5              
# 1a4 Lbmf_i6              
# 1a6 Lbmf_i7              
# 1a8 Lbmf_i8              
#
####################
# SELF TEST COUNTERS
####################
# 1aa C14FIL               # of times erratic PIP observed
# 1ab C22FIL               # of times BP out of range
# 1ac C29FIL               # of times VSS failed
# 1ad C31FIL               # of times EPT/EVP below min
# 1ae C32FIL               # of times EPT/EVP low in self test
# 1af C33FIL               # of times no EGR flow observed
# 1b0 C34FIL               # of times EPT/EVP high in self test
# 1b1 C35FIL               # of times EPT/EVP above max
# 1b2 C41FIL               # of times EGO1 failed to switch
# 1b3 C51FIL               # of times ECT above max
# 1b4 C53FIL               # of times TP above max
# 1b5 C54FIL               # of times ACT above max
# 1b6 C56FIL               # of times MAF shorted to power
# 1b7 C61FIL               # of times ECT below min
# 1b8 C63FIL               # of times TP below min
# 1b9 C64FIL               # of times ACT below min
# 1ba C66FIL               # of times MAF open
# 1bb C87FIL               # of times fuel pump relay 
# 1bc C91FIL               # of times EGO2 failed to switch
# 1bd C95FIL               # of times fuel pump circuit ??? 
# 1be C96FIL               # of times fuel pump circuit ???
# 1bf IDM_FAULT_CNT        # of times IDM failed
#
# 1C0 MILTMR               1/8 second timer for Malfunction Indicator Light output.
# 1C2 OUTTMR               Time since NO START flag set?
# 1C4 TSLIDM               Time since last Ignition Diagnostic Monitor pulse, msec (see IDM_BYPASS)
# 1C6 VIP_FPMTMR           Fuel Pump Circuit self-test timer
# 1C8 TSSTIL               Time since STI input was last low (R2B bit 5) 
# 1C9 VSSTMR               Vehicle Speed Sensor Time (.125 Sec) (Test only? )
# 1CA VIPTMR               VIP timer?
# 1FE BP                   Filtered BP (as byte)
# 1FF BPCOR                Corrected BP (result of FN004(BP))
# 200 Mult_bp311           Result of FN311(BP) - MFA Open loop fuel multiplier vs. BP
# 201 Mult_bp212A          Result of FN212A(BP) - Open loop fuel multiplier vs. BP
# 202 DSLMBS1              LAMBSE1 - 0x8000; only used by calibration console
# 204 DSLMBS2              LAMBSE2 - 0x8000; only used by calibration console
# 206 FUELPW1              Injector Pulse Width in ticks for Bank 1 (port 0)
# 208 FUELPW2              Injector Pulse Width in ticks for Bank 2 (port 2)
# 20A LAMBSE1              (Word) Desired lambda (air/fuel ratio) for bank 1
#                           x 32768 (0x8000 = 1.0 = stoichiometric)
#                           *** Larger values mean LESS fuel!
# 20C LAMBSE2              (Word) Desired lambda for bank 2
#                           x 32768 (0x8000 = 1.0 = stoichiometric)
#                           *** Larger values mean LESS fuel!
# 20e DELOPT               Filtered desired EGR valve position - (EVP - EOFF) in A/D counts
# 210 CLFLG                Closed Loop Flag. 1 = closed loop. 0 = open loop
# 211 VBAT                 Battery Voltage Level [divided by 16]
# 212                      ??? something to do with KOER test (see 0x30dc)
# 213 ACBTMR               Time since brake (BIFLG) went on (1/8 sec)
# 214 ACWTMR               A/C Clutch Wide Open Throttle Time (Secs)
# 215 WCOTMR               A/C Clutch WOT Cutout Timer (1/8 Sec)
# 216 ACCTMR               A/C Clutch Transition Timer (1/8 Sec)
# 218 ACITMR               Time since Idle Speed Control system was warned of impending increase in load (ACIFLG)
# 21C AELOAD               Averaged (filtered) Load
# 21E TSLADV               Time since the spark was last advanced by the KNOCK Strategy (KNOCK_ENABLED) mSec.
# 220 NWOTMR               Not at WOT (Wide Open Throttle) Timer. (sec)
# 221 EGRCNT               EGR vacuum regulator on-time count (max 30; see 559b)
# 222 EGRPER               EGR vacuum regulator period (msec/16; clipped to c0 = 12 ms)
# 223 Egrctf               EGR on-time counter
# 224 Egrprf               EGR period counter
# 226 Htime_beta           Knock sensor open offset
# 228 Htime_delta          Knock sensor open width
# 22a TBART                (Word) TP rolling average, only used in spark tip-in retard logic
# 22b SPKADn               Base address for SPKAD table
# 22c SPKAD1               Individual cylinder spark advance table (for use with knock detect strategy, KIHP == 1)
# 22d SPKAD2               
# 22e SPKAD3               
# 22f SPKAD4               
# 230 SPKAD5                
# 231 SPKAD6               
# 232 SPKAD7               
# 233 SPKAD8               
# 234 FUELFLOW1            Desired fuel flow rate for bank 1
# 236 FUELFLOW2            Desired fuel flow rate for bank 2
# 238 PIPACL               Percentage of PIP that PIP will decrease under Maximum Acceleration, Beta.
# 23a Dwlbst                
# 23c Dwell                (ticks) 
# 23e DWLBSE               Base amount of DWELL as a function of VBAT and TEMDWL, sec. Initial value = 0.005.
# 240 Dwellms               
# 242 Post_image            
# 244 Ppereng               
# 246 Poffeng               
# 248 Spout_low_time       (ticks)
# 24a FUEL_SUM_l           Fuel consumption, 24 bits; used for Data Output Link (trip computer)
# 24c FUEL_SUM_h           
# 24d Sparebyte1           
# 24e VMAF                 Scaled current MAF voltage
# 250 MAF                  The current measured mass air flow in Kg/Hr
# 252 ARCHG                Air charge mass per intake stroke (units are .027094 mg/LSB)
# 254 ARCHLI               Air charge mass leakage per intake stroke (same units)
# 256 ARCHI                Foreground corrected air charge mass (same units)
# 258 ARCHFG               Integrated air charge mass computed every PIP (same units)
# 25A FILRC1               Ratio of ARCHI/ARCHFG
# 25C LOAD                 Volumetric Efficiency; 0x8000 = 100%
# 25E PEAK_LOAD            Output of FN035(N) scaled for actual BP
# 260 PERLOAD              PERCENT LOAD Volumetric Efficiency in percent
# 262 DEBYMA_FM            DEBYMA without BP correction, for MAF FMEM
# 264 TSEGRE               Accumulated time EGR is enabled (sec)
# 265 ECTCNT               # of times ECT sensor was read since start;
#                           updated in Update_AD() background task; used to calculate TCSTRT
# 266 LESTMR1              Seconds since EGO1 noswitch (LESTMR1_On == 1) i.e.lack of switching ?
# 267 LESTMR2              Seconds since EGO2 noswitch (LESTMR2_On == 1) i.e.lack of switching ?
# 268 ENPIP1               Expected # of PIPs between EGO #1 switches
# 268 ENPIP2               Expected # of PIPs between EGO #2 switches
#
#  Injector scheduling working storage
#  See Foreground_Fuel, Schedule_Injectors
#
# 26A Inj_pip_cnt1         # of PIPS to delay before firing
# 26B Inj_pip_cnt2
# 26C Inj_bank1            Sequence # of injector to consider per bank, range 0 - NUMOUT-1;
# 26D Inj_bank2             Foreground_Fuel sets both to 0 when CRKFLG == 1
# 26E Total_delay1
# 26F Total_delay2
# 270 Ibeta1               something to do with injector pulse width
# 271 Ibeta2
#
# 272 MFAMUL               MFA table ramp-in Multiplier, unitless.
# 274 TSLAMU1              Time of last lambda update in IO timer ticks, bank 1
# 276 TSLAMU2              Time of last lambda update in IO timer ticks, bank 2
# 278                      not used?
# 27A                      not used?
# 27C NDBAR                Filtered RPM, used in Managed Fuel Air logic
#
# --- R74 points here (27E)
# 27E TCF                  TP - TBART; used in tip-in retard logic
# 280 MINTIM1              Last SCAP edge prior to the background calculation of BAP.
# 282 Old_beta             Used in spark timing logic
# 284 Last_HSO             Time of most recent HSO 1ms interrupt; used in MAF integration logic
# 286                      not used?
# 288 EM                   EGR Mass Flow
# 28A LST_IACC             Last AC Clutch/Neutral Drive Switch input
# 28C LSTROW               Last normalized row value.    (Adaptive fuel algorithm)
# 28E LSTCOL               Last normalized column value. (Adaptive fuel algorithm)
# 290 COLTBU               Column # of adaptive fuel cell to be updated
# 292 AISFL                Actual Intake Surface Fuel, low 16 bits
# 294 AISF                 Actual Intake Surface Fuel, high 16 bits
# 296 DELTIM               Time of last transient fuel update
# 298 LastSWtime           Scheduled time of next/current 5ms timer interrupt, IO ticks
# 29A SAFTOT               Total advance, in crank degrees before TDC x 4 (used by cal console only)
# 29C SAPW                 Spark Angle Pulse Width, sec. (HIDRES only; not used on A9L)
# 29E TAR                  scaled and translated TAR ?
# 29F N_BYTE               N/16
# 2A0 DTPCYC               PIP-PIP interval 2 revolutions + 1 cylinder ago
# 2A2 HFPCYC               PIP high time 2 revolutions ago
# 2A4 EGOSSS               Total EGO switches since start
# 2A5 EGOSS1               EGO1 switches since start
# 2A6 EGOSS2               EGO2 switches since start
# 2A7                      not used?
# 2A8 DEBTMR               VSCCS Debounce timer, msec.
# 2AC MPH                  filtered vehicle speed B (MPH)
# 2AE RES_SPEED            Vehicle Control Speed set by Driver, mph.
# 2B0 SET_SPEED            Current Desired Vehicle Control Speed
# 2B2 VS                   (Word) Instantaneous vehicle speed, mph, scale factor unknown (?)
#                           Only used as input to VSBAR, MPH rolling averages
# 2B4 VSCCS                Vehicle Speed Control Command Switch; input, debounced counts.
# 2B6 VSC_ERROR            Vehicle Speed Control Error
# 2B8 VSC_OFF_COUNT        Number of scheduler passes with output off.
# 2B9 VSC_ON_COUNT         Number of scheduler passes with output on.
# 2BA Vsc_dc
# 2BB TSLMPH               msec since last VSS click
# 2BC VSBAR                filtered vehicle speed A  (MPH) (word)
# 2BD VSBAR_H              high byte of VSBAR
# 2BE MPHTIM1L             IO time of most recent VSS tick
# 2C0 MPHTIM1H             
# 2C2 MPHTIM2L             IO time of previous VSS tick
# 2C4 MPHTIM2H

##################################################################
# 2C5 HSOQ                  RAM based table for SPOUT, 8 injects and KTS  (2c5-327)
# Format is 10 byte entries (5 bytes on, 5 bytes off)
# Each specific device has a fixed location.
# The table is organized as an ordered linked list by time.
# 0       Link field; offset from 2C5.  FF if not in use.
# 1       Offset of corresponding 2284 table entry. 0 if not in use.
# 2,3,4   24 bit IO time for HSO event
# 5       link field; offset to another 2C5 entry
# 6       offset to corresponding 2284 Table entry
# 7,8,9   HSO Event time
##################################################################
#
# 2C5 Initialized to 3 (->2c8) to start chain; see 2613, init table entry at 86be
# 2C6 SvStack              Saved stack pointer - alternate stack used for interrupts and some tests
#
# 2C8 Q0                   First HSO queue entry - SPOUT
# 2C9                      
# 2CA                      
# 2CB
# 2CC
# 2CD
# 2CE Prev_PIP_time        Last PIP time (24 Bit)
# 2CF
# 2D0 Prev_PIP_timeH        
#
##################################################################
# Injector events save the previous HSO event time
# -3      High byte of previous event time
# -2      Low 16 bits (little-endian order)
# 0       Link field; offset from 2C5.  FF if not in use.
# 1       Offset of corresponding 2284 table entry. 0 if not in use.
# 2,3,4   24 bit IO time for HSO event (normal little endian)
# 5       link field; offset to another 2C5 entry
# 6       offset to corresponding 2284 Table entry
##################################################################
# 
# 2D1 Inj1_LAST            High byte of last injector event for cyl 1 (see 27f9) - initialized to time of 1st PIP rising edge
# 2D2                      Low word (little-endian) of 24 bit time for cyl 1
# 2D4 Q1                   (offset 0F) cylinder 1 HSO ch 6 - Initialized to FF
# 2D5                      byte offset from HSOTable (ROM Table)
# 2D6                      HSO execution time for cyl 1 (24 bits), normal little endian order
# 2D7                      ""
# 2D8                      ""
# 2D9                      queue link
# 2DA Next_spout_beta      offset into 2284 Table 5C[R74]
# 2DB
# 2DC
# 2DD Inj2_last            Last event time hi 8 for cyl 2
# 2DE                      last event time lo 16
# 2DF
# 2E0 Q2                   cylinder 2 HSO 7 - Initialized to FF
# 2e6 Spr264               
# 2e7 Inj3_last            
# 2EA Q3                   cylinder 3 HSO 0 - Initialized to FF
# 2f0 Spare_26E            
# 2f1 Inj4_last            
# 2F4 Q4                   cylinder 4 HSO 1 - Initialized to FF
# 2fb Inj5_last            
# 2FE Q5                   cylinder 5 HSO 4 - Initialized to FF
# 305 Inj6_last            
# 208 Q6                   cylinder 6 HSO 2 - Initialized to FF
# 309                      offset into 2284 Table
# 30f Inj7_last            
# 312 Q7                   cylinder 7 HSO 3 - Initialized to FF
# 319 Inj8_last            
# 31C Q8                   cylinder 8 HSO 8 - Initialized to FF
# 322 Q9                   9TH - KTS ? - Initialized to FF
# 323 EGRCNT2              ??
# 324 EGRPER2              ??
# 325                       
# 326                       
# 327
# 328 MAF_TIME             Time of last MAF A/D read
# 32a AMINT                Accumulator for air mass integration
# 32c                      not used?
# 32e Maf_ptr              MAF transfer function ptr
# 330 RAWAIRCHG            Raw integrated air mass for one cylinder
# 332 INTM                 Delta time between current and previous MAF reads
# 334 DT23S                Previous PIP cycle time (low 16 bits)
# 336 PHFDLT               Previous value of HFDLTA
# 338 TL0FLG               Transient Spark calculation flag (GUFB p. 7-27)
# 339 DIFCTR               Counter for TL0FLG state changes (GUFB p. 7-27)
# 33a SIGKAL               Signature PIP ratio / multiplier - for narrow slot (cyl 1)
# 33c SIGDLT               Uncorrected signature PIP half period
# 33E PSGDLT               Previous cylinder PIP half period
# 340 DTSIG                PIP period of last signature PIP.
# 342 Serv_code_tab        base of Hard Trouble Code Error Table
#
# --- R76 points here --- (37A)
# 37A
#
# 384 Sto_delay            Self Test Out bit-banging I/O working storage
# 386 Sto_shift
# 388 Sto_high_delay
# 389 Sto_high_time
# 38A Sto_shift_cnt
#
# 394 BGFUL1               Background computed injector pulsewidth (sec) for bank 1
# 396 BGFUL2               Background computed injector pulsewidth (sec) for bank 2
# 398 FFULM1               Foreground injector pulsewidth for bank 1
# 39A FFULM2               Foreground injector pulsewidth for bank 2
# 39C FFULC1               Injector pulsewidth correction for acceleration/transient fuel, bank 1
# 39E FFULC2               Injector pulsewidth correction for acceleration/transient fuel, bank 2
# 3A0 ARCHG_BG             Air charge mass per intake stroke, computed in the background loop
# 3A2 AEFTRFF              The upper word of the sum of (AEFUEL/2) and (EFTRFF/2).
# 3A4 AEFTRFFL             The lower word of the sum of (AEFUEL/2) and (EFTRFF/2).
# 3A6 AIR37                Cached result of FN037(N).
# 3A8 A3CTMR               Timer for distinguishing A/C clutch and heated windshield events
# 3AA HWTMR                Ditto - see GUFB p. 10-8
# 3AC IVSCCS_LST           Last input vehicle speed control command switch.
# 3AE                      not used?
# 3B0 AMINT_L              Low order bits of AMINT, cleared at every PIP rising edge interrupt
# 3B2 LSTA3C               State of A3C the last pass.
# 3b3 ARCHCOR              Air Charge Correction for MAF backflow
# 3b4 Slice_0              8 counts of scheduled events for HSO lines 
# 3b5
# 3b6
# 3b7
# 3b8
# 3b9
# 3ba
# 3bb
# 3bc Sparek1              
# 3bd Mapsav               
# 3be Piplim               (byte)
#                           Cleared to 0 at startup; set in background routine Update_rpm to 2
# 3bf
# 3c0 MNPIP                (word) Minimum interval (ticks) for a valid PIP high-high cycle;
#                           Initialized to 0x56c (see initialization list @ 86e2)
#                           Set from table in background routine Update_rpm to 0x3c1
# 3c2 Seq_max              (word) PIP high-high cycle time at or below which sequential injection is enabled;
#                           Initialized to 0x1900 (see initialization list @ 86e0)
#                           Set from table in background routine Update_rpm to 0xc80

### End of RAM variables ?

# 48C StackBase            Background stack - Location to which R10 (SP) is initialized
                           Stack grows down (towards 0)
# 4FF
### End of gen'l purpose RAM

#
# KEEP ALIVE MEMORY 0700-07FF
#
# 700 KAMQA                 KAM qualification register 1 (should always = 0xAA) (GUFB p. 22-2)
#
# 702 CHKSUM                KAM checksum word 1, covers LTMTB1-2 (GUFB p. 22-5)
# 704 LTMTB1                Adaptive fuel table for bank 1 (pass. side)
# 75A LTMTB2                Adaptive fuel table for bank 2 (driver side)
#
# 7B0 KAMQB                 KAM qualification register 2 (should always = 0xC6) (GUFB p. 22-2)
#
# 7B4 KAMRF1                Adaptive fuel strategy correction factor for bank 1 - larger values add fuel
# 7B6 KAMRF2                Adaptive fuel strategy correction factor for bank 2
#
# 7CA K14CNT ?              Beginning of stored-code counters; codes go away when respective counter >= 40
# 7E0 KWUCTR                KAM warm-up counter - # of warmups since KAM last reset
#
# 7E2 KAMQA                 KAM qualification register 3 (should always = 0x75) (GUFB p. 22-2)
#
# 7E4 ISCKAM0               Idle air correction, Drive w/ AC off
# 7E6 ISCKAM1               Idle air correction, Drive w/ AC on
# 7E4 ISCKAM2               Idle air correction, Idle w/ AC off
# 7E4 ISCKAM3               Idle air correction, Idle w/ AC on
# 7EC ISKSUM                KAM checksum word 2, covers ISCKAMs (GUFB p. 22-6)
# 7EE EPTZER                filtered EPT saved in KAM (PFE EGO only)

#
# OFF-CHIP I/O PORTS
# 
# Pin assignments marked by ? are from a speed-density, bank-fire EEC schematic
# and may not match MAF, sequential EFI variant.
#
# 092F        Off-Chip Port of 81C61 RAM-I/O (low 5 bits are parallel I/O)
#  0 ShLight_On OCP 0 - Shift Light (not used on A9L)
#  1 TAB        OCP 1 - Air mgmt 1 - on A9L, Thermactor Air Bypass (1 = bypassed)
#  2 TAD        OCP 2 - Air mgmt 2 - on A9L, Thermactor Air Diverter (1 = upstream)
#  3 Fan        OCP 3 - Electric Fan on (not used on A9L)
#  4 Hi_fan     OCP 4 - High Speed Fan on (not used on A9L)
# 0930        ROM Port of 8763 (low 5 bits are parallel inputs)
#  0            Electronically Controlled Accessory Drive Input (ECADI)
#  1            Calibration Select Module pin 1?
#  2            Fuel Pump Circuit Monitor (FPM)
#  3            Calibration Select Module pin 2?
#  4            Calibration Select Module pin 3?
#

#
# Calibration Console region ?
# No hardware on the EEC itself responds to these addresses
#
# 0C80 (word)  ??? see 84da
#
# 0D00         ??? see 277c and 84b2
# 0D01         if == 2a, console active - see 277c-278c, 84b2-84ba
#
# 0D12         Region used by TwEECer and Quarterhorse payload patch
#  ...          for copying zero page registers which would otherwise
# 0DFF          be inaccessible
#
# 1F1C         unknown console function called from 8528-852f
#
# 1FF2 (word)  console function ptr (points to 1F1C if present)
#               see 850a, 8528
#
# 1FF6 (word)  ??? location tested for read/write
#               see 8515-8523
#

####################### Analog Input Handling:
# 28A7                       and 2D29  MAF - reads AD h/w at saves to 124 = A4[R72]
# 2DC7                       calibrate for voltage? at in var D0[R74] = 2E4
# ACT - Air Charge Temperature - raw counts? MSB in 115, degrees Farenheit in RB1
# Important functions:
# 384E Update_AD             reads raw AD values and updates values
# 68FE Update_timers         timers - incr/decr Table of timer pointers
# 7BAE SaveTCode1            trouble code (BrkPt at 7BB8 and look at R1A)
# 827D HW_Check              8061 CPU and RAM test routines
# 8434 Sub119                change mode resets IO and starts run mode? (self test to run? )

# Important addresses:
# 786B Chkbase               set to zero to skip ROM checksum
# 780D Do_KOEO               Key On Engine Off (KOEO) Self -Tests
# 57FC                       code section to retard timing if overspeed (via VSS)
# 980D HSS_retard            table (mph).
#
##############################################################################

##############################################################################
# CPU starts executing at 2000 when reset
##############################################################################

  RESET: 
2000: ff                  nop                    
2001: fa                  di                     disable ints;
2002: 21,45               sjmp  2149             goto Initialise;


2004: 00,00               word     0             FIXSUM                            # (Almost) always 0 (GUFB p. 23-2)
2006: ff,df,00,ff
200a: de,ec               word  ecde             ROM_TO                            # Inverse of CHECKSUM (GUFB p. 23-2)
200c: 00,a0               word  a000                                               # End of ROM

200e: 5d,00               word    5d                                               # IO ticks for HSO #2 timer (see 0x84c2)
                                                                                   # 93 ticks = 223.2 us
#
# Interrupt vectors
#
2010: 51,27               vect  2751,            I_HSO_2                           # HSO Port Output 2 (Calibration Console timer)
2012: 3d,27               vect  273d,            I_Timer_OVF                       # I/O Timer Overflow
2014: 50,27               vect  2750,            I_Ignore                          # A/D End of Conversion
2016: 50,27               vect  2750,            I_Ignore                          # HSI Port Input Data Available
2018: 50,27               vect  2750,            I_Ignore                          # External Interrupt Vector
201a: b9,25               vect  25b9,            I_HSO_1                           # HSO Port Output 1 (1ms tick)
201c: 50,27               vect  2750,            I_Ignore                          # HSI 1 Interrupt Vector
201e: 2b,27               vect  272b,            I_HSI_0                           # HSI 0 Interrupt Vector

################# 'Base + offset' (Rbase) register setup - used throughout -> Rf0 - Rfe

2020: 08                  byte    8                                                # no of regs
2021: 01                  byte    1

2022: 00,8c               word   8c00                                              # Rf0
2024: 5a,8e               word   8e5a
2026: d6,8f               word   8fd6
2028: a8,93               word   93a8
202a: 30,94               word   9430                                              # Rfa - spark
202c: a8,97               word   97a8
202e: 7e,9a               word   9a7e
2030: 5a,9e               word   9e5a                                              # Rfe


#############################################################
# Master Reset Subroutine
#############################################################

  Reset_All:
2032: fa                  di                     disable ints;
2033: ff                  nop                    
2034: 11,0c               clrb  Rc               HSI_Mask = 0;                     # disable all interrupts
2036: b0,2a,12            ldb   R12,R2a          Tmr_OVF_cnt = VIP_flags;          # save VIP mode
#
# Zero all registers from R16, & RAM up to 489 (48A is return address of this routine) 
#
2039: a1,16,00,14         ldw   R14,16           R14 = 16;
 Clr_Regs_Loop:
203d: c6,15,00            stb   R0,[R14++]       [R14++] = 0;
2040: 17,05               incb  R5               WDG_Timer++;                      # Tickle watchdog
2042: 89,8a,04,14         cmpw  R14,48a          
2046: d3,f5               jltu  203d             if ((uns) R14 < 48a) goto Clr_Regs_Loop;

2048: 51,60,12,14         an3b  R14,R12,60       R14 = Tmr_OVF_cnt & 60;
204c: d7,05               jne   2053             if (R14 == 0)  {
204e: 91,01,ef            orb   Ref,1            Power_up = 1;
2051: 20,03               sjmp  2056             goto 2056; }
                                                 else
2053: c4,2a,12            stb   R12,R2a          VIP_flags = Tmr_OVF_cnt;          # In self test, restore mode

2056: 01,12               clrw  R12              Tmr_OVF_cnt = 0;
2058: a1,80,01,72         ldw   R72,180          Rp = &INJDLY;
205c: a1,7e,02,74         ldw   R74,27e          Rp2 = &TCF;                       # R72,R74,R76 RAM base ptrs
2060: a1,7a,03,76         ldw   R76,37a          Rp3 = 37a;

###########################
# Initialise various locations in memory, lists start at 862a
# 3 lists linked together
# each list has an address 'base' which is added to each address entry
# update is done with an OR, which allows checking
###########################

2064: a1,2a,86,14         ldw   R14,862a         R14 = 862a;
#
# Outer init loop
# R14 -> list descriptor
#
2068: 89,ff,ff,14         cmpw  R14,ffff                                           # outer loop
206c: df,20               je    208e             if (R14 = ffff) goto 208e;        # -1 = list processing done
206e: a2,15,1a            ldw   R1a,[R14++]      R1a = [R14++];                    # 'Base' address, in top byte (R1b)
2071: a2,15,16            ldw   R16,[R14++]      R16 = [R14++];                    # end of list (address of next list)
#
# Inner init loop
#
# R14 -> current init item
# R16 -> next list descriptor
# R1A = low byte of addresses to init
# R1B = high byte of addresses to init (unmodified in inner loop)
# R1C = temp
#
2074: 88,16,14            cmpw  R14,R16                                            # Inner loop
2077: db,0e               jgeu  2087             if (R14 >= R16)  {                # 
2079: b2,15,1a            ldb   R1a,[R14++]      R1a = [R14++];                    # get low byte of addr to init
207c: b2,1a,1c            ldb   R1c,[R1a]        R1c = [R1a];                      # get current contents (s/b 0?)
207f: 92,15,1c            orb   R1c,[R14++]      R1c |= [R14++];                   # OR byte from list
2082: c6,1a,1c            stb   R1c,[R1a]        [R1a] = R1c;                      # save new value
2085: 27,ed               sjmp  2074             goto 2074; }
#
2087: d9,a9               jgtu  2032             if (R14 > R16) goto Reset_All;    # Overran list, try again
2089: a2,16,14            ldw   R14,[R16]        R14 = [R16];                      # Address of next list
208c: 27,da               sjmp  2068             goto 2068;

#####################now do rest of checks

208e: 91,10,24            orb   R24,10           Console_init = 1;                 # Indicate this is initial call
2091: ef,1e,64            call  84b2             Check_console();                  # Init console, calibration base registers
2094: ef,0c,65            call  85a3             Check_Kam_1();                    # verify KAM Table 1 (702-7AF)
2097: ef,5b,65            call  85f5             Check_Kam_2();                    # verify KAM Table 2 (7E4-7EC)
#
# Initialize working registers and RAM
#
209a: a3,74,de,42         ldw   R42,[R74+de]     R42 = LOAD;                       # engine load (VE)
209e: c3,74,9e,42         stw   R42,[R74+9e]     AELOAD = R42;                     # Averaged Load
20a2: 45,e2,01,f0,42      ad3w  R42,Rf0,1e2      R42 = FN036;
20a7: c3,76,b4,42         stw   R42,[R76+b4]     Maf_ptr = R42;                    # Save ptr to MAF transfer func
                                                                                   # (see table lookup @ 0x2DDC for details)
20ab: a3,f0,02,42         ldw   R42,[Rf0+2]      R42 = RATIV;                      # Initial value, typically 1.25V
20af: c3,72,80,42         stw   R42,[R72+80]     TPBAR = R42;                      # filtered TP to start value
20b3: b3,fc,53,b3         ldb   Rb3,[Rfc+53]     PPCTR = PIPNUM;
20b7: b3,fa,31,42         ldb   R42,[Rfa+31]     R42 = PFEHP;                      # EGR Type (0=sonic, 1=PFE, 2=none)
20bb: 30,42,03            jnb   B0,R42,20c1      if (B0_R42 == 1)  {
20be: 91,40,e6            orb   Re6,40           Pfehp_flg = 1; }                  # PFE EGR is present (A9L uses sonic)
#
20c1: a1,db,b6,42         ldw   R42,b6db         R42 = b6db;                       # = 1.428 for 8 cyl (35% duty cycle)
20c5: b3,fe,07,30         ldb   R30,[Rfe+7]      R30 = ENGCYL;                     # = 8 (PIPs per rev x2)
20c9: 3b,30,04            jb    B3,R30,20d0      if (B3_R30 == 0)  {
20cc: a1,55,d5,42         ldw   R42,d555         R42 = d555; }                     # = 1.666 for 6 and 4 cyl (30% duty cycle)
#
20d0: c3,76,c0,42         stw   R42,[R76+c0]     SIGKAL = R42;                     # ratio for Signature PIP (cyl 1)
20d4: a3,01,ee,07,30      ldw   R30,[R0+7ee]     R30 = EPTZER;                     # get EVP from KAM
20d9: 8b,f3,38,01,30      cmpw  R30,[Rf2+138]    
20de: d1,07               jleu  20e7             if ((uns) R30 <= VEPTLL) goto 20e7;
20e0: 8b,f3,3a,01,30      cmpw  R30,[Rf2+13a]    
20e5: d3,09               jltu  20f0             if ((uns) R30 >= VEPTHL)  {
#
20e7: a1,80,a2,30         ldw   R30,a280         R30 = a280;                       # default EVP if outside limits
20eb: c3,01,ee,07,30      stw   R30,[R0+7ee]     EPTZER = R30; }                   # filtered EVP saved in KAM
20f0: 11,09               clrb  R9               INT_Pend = 0;
#
20f2: 32,0a,06            jnb   B2,Ra,20fb       if (HSI_Ready == 1)  {
20f5: b0,0d,00            ldb   R0,Rd            R0 = HSI_Data;                    # Clear any pending HSI input data
20f8: ff                  nop                    
20f9: 27,f7               sjmp  20f2             goto 20f2; }
#
20fb: b0,0b,90            ldb   R90,Rb           Last_HSI = HSI_Sample;
#
# N.B. HSO 2 interrupt can be ignored if no calibration console present.
# The resulting INT_Mask value is 0x21 (HSI 0, HSO 1).
# 
20fe: b1,a1,08            ldb   R8,a1            INT_Mask = a1;                    # HSI 0, HSO 1, HSO 2
#
# N.B. Calculation of HSI_Mask could be collapsed into simply loading a constant
# For A9L, that constant is 0xC5: PIP, BP, VSS, IDM
#
2101: b1,87,0c            ldb   Rc,87            HSI_Mask = 87;                    # PIP, KI, BP, IDM enabled
2104: 9b,f8,4a,00         cmpb  R0,[Rf8+4a]      
2108: d7,03               jne   210d             if (0 == KIHP)  {
210a: b1,85,0c            ldb   Rc,85            HSI_Mask = 85; }                  # Drop chan 1 - No knock sensor (not present on A9L)
#
210d: 9b,fe,0c,00         cmpb  R0,[Rfe+c]       
2111: df,03               je    2116             if (0 != HP_CID)  {                
2113: 91,20,0c            orb   Rc,20            HSI_Mask |= 20; }                 # Add chan 5 - CID sensor (not present on A9L)
#
2116: 9b,f2,47,00         cmpb  R0,[Rf2+47]      
211a: df,03               je    211f             if (0 != VSTYPE)  {               # VSTYPE = 1 for A9L
211c: 91,40,0c            orb   Rc,40            HSI_Mask |= 40; }                 # Add chan 6 - VSS sensor

######## set up HSO event for first 1ms timer interrupt

211f: 45,03,00,06,0e      ad3w  Re,R6,3          HSO_Time = IO_Timer + 3;
2124: b1,2a,0d            ldb   Rd,2a            HSO_Cmd = 2a;                     # Output Interrupt #1 (ch 10) in 3 state times
#
# Select dwell and spark trigger types
#
2127: 9b,f8,1a,00         cmpb  R0,[Rf8+1a]      
212b: df,0a               je    2137             if (0 != CCDSW)  {                
212d: a1,96,22,92         ldw   R92,2296         TPtr = 2296;                      # Computer controlled dwell (not present on A9L)
2131: 91,08,4c            orb   R4c,8            Immediate = 1;                    # address in data Table - SPOUT On
2134: ef,86,02            call  23bd             Send_HSO_Cmd(); }
#
2137: 9b,f8,19,00         cmpb  R0,[Rf8+19]
213b: df,0a               je    2147             if (0 != HP_HIDRES)  {            # 
213d: a1,9e,22,92         ldw   R92,229e         TPtr = 229e;                      # High Data Rate Electronic Spark H/W (not present on A9L)
2141: 91,08,4c            orb   R4c,8            Immediate = 1;                    # address in data Table - SPOUT Off
2144: ef,76,02            call  23bd             Send_HSO_Cmd(); }
#
2147: fb                  ei                     enable ints;
2148: f0                  ret                    return;


#############################################################
# EEC main (background) loop - cycles thru these routines
# R9A (Bg_offset) is current routine offset
# Runs subroutines in Table starting at index 0
## Jump here from RESET
#############################################################

  Initialise:
2149: 11,2a               clrb  R2a              VIP_flags = 0;                    # clear all VIP mode flags
214b: a1,8c,04,10         ldw   R10,48c          STACK = 48c;                      # set stack pointer
214f: 2e,e1               scall 2032             Reset_All();
#
# Background loop routines return to here
#
  Backg_loop:
2151: 99,a4,9a            cmpb  R9a,a4                                                                                      0.8 us
2154: db,1c               jgeu  2172             if (Bg_offset < a4)  {            # goto loopstop (DEAD) if too big        0.8    (branch not taken)
2156: ac,9a,30            ldzbw R30,R9a          R30 = (uns)Bg_offset;             # zero extend routine offset             0.8
2159: 65,8a,21,30         ad2w  R30,218a         R30 += 218a;                      # address of subroutine from list        1.0
215d: c9,51,21            push  2151             push(Backg_loop);                 # push return address                    2.4
2160: ca,30               push  [R30]            push([R30]);                      # push subroutine address to stack       2.4
2162: a1,80,01,72         ldw   R72,180          Rp = &INJDLY;                     # Reinit RAM pointers every time through 1.0
2166: a1,7e,02,74         ldw   R74,27e          Rp2 = &TCF;                                                                1.0
216a: a1,7a,03,76         ldw   R76,37a          Rp3 = 37a;                                                                 1.0
216e: 75,02,9a            ad2b  R9a,2            Bg_offset += 2;                   # next subroutine                        0.8
2171: f0                  ret                    return; }                         # indirect jump to routine               3.2
                                                                                                                          -----
                                                                                                                           15.2 us
2172: 27,fe               sjmp  2172             goto 2172;                        # LOOPSTOP - DEAD


#################################################################
# Update loop selection and restart loop
# from task list routine at 2151, do each of 3 loops
# LIST A - Normal Operation
# List B - KOEO Engine off self tests (and engine on cruise controls self test?)
# List C - KOER Engine running self tests
# Note that last entry in each list is Set_Tasklist
#################################################################

  Set_Tasklist:
2174: 3e,2a,03            jb    B6,R2a,217a      if (No_start == 1) goto 217a;
2177: 31,2a,04            jnb   B1,R2a,217e      if (Vscst == 1)  {                # Vehicle Speed Control Self Test ?

217a: b1,52,9a            ldb   R9a,52           Bg_offset = 52;                   # set List B
217d: f0                  ret                    return; }

217e: 35,2a,04            jnb   B5,R2a,2185      if (RUNNING == 1)  {
2181: b1,74,9a            ldb   R9a,74           Bg_offset = 74;                   # set List C
2184: f0                  ret                    return; }

2185: b1,00,9a            ldb   R9a,0            Bg_offset = 0;                    # set List A
2188: f0                  ret                    return;

2189: ff                        

####### Tasklist Subroutine Lists
####### List A - normal operation - no self tests

218a: b1,84               vect  84b1,            Check_ConsoleD                    # Check console, init RF0 regs
218c: 5d,23               vect  235d,            check_KAM                         # Validate/initialise KAM
218e: 52,58               vect  5852,            Update_dwell                      # Update Computer Controlled Dwell
                                                                                   # (not present in A9L, routine can be deleted)
2190: 86,37               vect  3786,            set_rpm_flgs                      # Set RPM Flags
2192: 2e,22               vect  222e,            Read_AD                           # Read AD channels
2194: 4e,38               vect  384e,            Update_AD                         # Read/update raw AD vals
2196: f3,37               vect  37f3,            Update_WOT                        # Update WOT flag
2198: f4,4e               vect  4ef4,            Do_accelpump
219a: 5a,3d               vect  3d5a,            Update_HWND                       # Update heated windshield flag    (not present on A9L)
219c: e4,3c               vect  3ce4,            Update_MPH                        # Update (MPH) vehicle speed values
219e: ac,3d               vect  3dac,            Update_rpm                        # Update RPM?
21a0: dd,63               vect  63dd,            Update_AC                         # Update A/C clutch control, idle increment
                                                                                   #  (can be bypassed if no A/C)
21a2: d4,65               vect  65d4,            Set_Timers
21a4: fe,68               vect  68fe,            Update_timers                     # Update Timers
21a6: 8f,84               vect  848f,            Set_ign_timers                    # Check whether PIP, IDM, BAP still active
21a8: ca,4c               vect  4cca,            Update_flDOL                      # Update fuel consumption for DOL (can be deleted)
21aa: 7c,3e               vect  3e7c,            Load_Calc
21ac: 30,85               vect  8530,            Update_PFE_EGR                    # Update PFE EGR (not present in A9L)
21ae: ba,40               vect  40ba,            Update_Egr                        # Update EGR stuff?
21b0: 41,41               vect  4141,            Check_spd_lim                     # Check for RPM and Speed limiters (patched by Z_LC_SW in GUFB.xls)
21b2: a1,41               vect  41a1,            Update_clolp                      # Update closed loop flags
21b4: 00,47               vect  4700,            Adapt?                            # Adaptive something               (patched by Z_ADPSW in GUFB.xls)
21b6: d7,4a               vect  4ad7,            Calc_BG_Fuel                      # Background fuel calculation
21b8: ee,50               vect  50ee,            Update_fpump                      # Update fuel pump enable
21ba: 36,51               vect  5136,            Calc_EVP                          # EVP something
21bc: d9,54               vect  54d9,            Calc_EGR                          # EGR stuff - must follow Calc_EVP
21be: c3,55               vect  55c3,            Update_advance                    # Update spark advance
21c0: 17,6d               vect  6d17,            UPd_KnkRet                        # Update Knock and Tip-in Retard (no-op in A9L)
21c2: 8c,64               vect  648c,            Update_fans                       # Update electric cooling fans (not present in A9L)
21c4: 91,61               vect  6191,            Upd_air_mgt                       # Update thermactor air
21c6: b5,62               vect  62b5,            Upd_HiFan                         # Update high speed electric fan (not present in A9L)
21c8: 35,63               vect  6335,            Upd_canpTm                        # Update Canister Purge timing
21ca: 66,65               vect  6566,            Upd_Suprchrgr_Byp                 # Update supercharger bypass (not present in A9L)
21cc: b0,58               vect  58b0,            Update_Idle                       # Update idle speed
21ce: c4,5e               vect  5ec4,            Upd_VSC                           # SCCS stuff checks VBAT
21d0: 7b,6a               vect  6a7b,            Upd_ShiftL                        # Update shift light (not present in A9L)
21d2: dd,6a               vect  6add,            Upd_Adj_Shocks                    # (De)Activate adjustable shocks (not present in A9L)
21d4: a1,65               vect  65a1,            Upd_Iacflg                        # Update Air Management
21d6: 2e,73               vect  732e,            Cont_Self_Test
21d8: 49,6e               vect  6e49,            Do_SelfTest                       # diagnostic Self Tests
21da: 74,21               vect  2174,            Set_Tasklist                      # recheck list A

################# List B - Engine Off (KOEO) self tests (and engine on cruise controls self test? )

21dc: b1,84               vect  84b1,            Check_ConsoleD                    # check console, init RF0 regs
21de: 86,37               vect  3786,            set_rpm_flgs                      # Set RPM Flags
21e0: 2e,22               vect  222e,            Read_AD                           # Read AD channels to Table
21e2: 4e,38               vect  384e,            Update_AD                         # Read/update raw AD vals
21e4: e4,3c               vect  3ce4,            Update_MPH                        # Update vehicle speed vals
21e6: ac,3d               vect  3dac,            Update_rpm                        # Update RPM
21e8: d4,65               vect  65d4,            Set_Timers
21ea: fe,68               vect  68fe,            Update_timers                     # Update Timers
21ec: 8f,84               vect  848f,            Set_ign_timers                    # Check whether PIP, IDM, BAP are active
21ee: ba,40               vect  40ba,            Update_Egr                        # Update EGR stuff?
21f0: d7,4a               vect  4ad7,            Calc_BG_Fuel
21f2: ee,50               vect  50ee,            Update_fpump                      # Update fuel pump enable
21f4: e7,5e               vect  5ee7,            Upd_SCCS                          # Update Vehicle Speed Control
21f6: 49,6e               vect  6e49,            Do_SelfTest                       # Diagnostic Self Tests
21f8: 87,55               vect  5587,            Update_EGR2                       # Update EGR stuff
21fa: ca,63               vect  63ca,            Upd_canP                          # Update Canister Purge
21fc: 74,21               vect  2174,            Set_Tasklist                      # Recheck list B

######### List C - Engine Running (KOER) self tests

21fe: b1,84               vect  84b1,            Check_ConsoleD                    # Check console, init RF0 regs
2200: 2e,22               vect  222e,            Read_AD                           # Read AD channels
2202: 4e,38               vect  384e,            Update_AD                         # Read/update raw AD vals
2204: f3,37               vect  37f3,            Update_WOT                        # Update WOT flag
2206: e4,3c               vect  3ce4,            Update_MPH                        # Update vehicle speed values
2208: 52,58               vect  5852,            Update_dwell                      # Update Computer Controlled Dwell
                                                                                   # (not present in A9L, routine can be deleted)
220a: ac,3d               vect  3dac,            Update_rpm                        # Update RPM
220c: d4,65               vect  65d4,            Set_Timers
220e: fe,68               vect  68fe,            Update_timers                     # Update Timers
2210: 8f,84               vect  848f,            Set_ign_timers                    # Check whether PIP, IDM, BAP are active
2212: ca,4c               vect  4cca,            Update_flDOL                      # Update fuel comsumption for DOL (can be deleted)
2214: 7c,3e               vect  3e7c,            Load_Calc
2216: ba,40               vect  40ba,            Update_Egr                        # Update EGR stuff?
2218: 5b,4b               vect  4b5b,            Sub19                             # Something Injection ?
221a: f4,4e               vect  4ef4,            Do_accelpump
221c: ee,50               vect  50ee,            Update_fpump                      # Update fuel pump enable
221e: b0,58               vect  58b0,            Update_Idle                       # Ccheck idle speed?
2220: c4,5e               vect  5ec4,            Upd_VSC                           # SCCS stuff checks VBAT
2222: 3f,82               vect  823f,            Chk_HEGO                          # Check HEGO sensors
2224: 28,82               vect  8228,            Sub115                            # Check brake and PS flags (not present on A9L)
2226: 49,6e               vect  6e49,            Do_SelfTest                       # Ddiagnostic Self Tests
2228: 87,55               vect  5587,            Update_EGR2                       # Update EGR stuff
222a: ca,63               vect  63ca,            Upd_canP                          # Update Canister Purge
222c: 74,21               vect  2174,            Set_Tasklist                      # List C (rechecks List)


#################################################################
# Read and save A/D converter values.
# Background routine
# Inputs:
#  Table @ 225f
#  A/D converter
# Outputs:
#  R29 bit 6  - Evpout (not referenced elsewhere?)
#  ADC reading - See table @ 225f
# Clobbers: R30-R35
#################################################################

  Read_AD:
222e: a1,5f,22,30         ldw   R30,225f         R30 = AD_channel_tbl;             # A/D Lookup Structure
#
# R30 (word): pointer to ADC channel in a 225f table entry
#
  Read_AD_Loop:
2232: fb                  ei                     enable ints;
2233: 56,30,00,04         ad3b  R4,R0,[R30]      AD_Cmd = [R30];                   # get, and set, AD channel reqd
2237: de,22               jlt   225b             if (AD_Cmd < 0) goto Read_AD_Exit; # exit if at end of table
#
2239: 33,0a,fd            jnb   B3,Ra,2239       if (AD_Ready == 0) goto 2239;     # spin wait for AD ready w/ ints enabled
                                                                                   # 9 states/loop = 1.8 us
                                                                                   # conversion time = 35.2 us
#
# Check that ADC read the channel we requested
# Interrupts were enabled during the spin wait;
# PIP or 1ms timer interrupt handlers could have read MAF while we were waiting
#
223c: fa                  di                     disable ints;
223d: ff                  nop                    
223e: 51,0f,04,34         an3b  R34,R4,f         R34 = AD_Low & f;                 # get channel returned
2242: 9a,30,34            cmpb  R34,[R30]                                          # check correct channel
2245: d7,eb               jne   2232             if (R34 != [R30]) goto Read_AD_Loop; # No, try read again
#
2247: 51,f0,04,34         an3b  R34,R4,f0        R34 = AD_Low & f0;                # AD Low value
224b: b0,05,35            ldb   R35,R5           R35 = AD_High;                    # AD High value
224e: 07,30               incw  R30              R30++;                            # incr table ptr to save address
2250: b2,31,32            ldb   R32,[R30++]      R32 = [R30++];
2253: b2,31,33            ldb   R33,[R30++]      R33 = [R30++];                    # get destination address (hi+lo)
2256: c2,32,34            stw   R34,[R32]        [R32] = R34;                      # save AD value to destination.
2259: 27,d7               sjmp  2232             goto Read_AD_Loop;                # loop with R30 pointing at next channel to read
  Read_AD_exit:
225b: 91,40,29            orb   R29,40           Evpout = 1;                       # *** flag seems to be unused ***
225e: f0                  ret                    return;


#############################################################
# A/D Definition.  3 byte entries
# byte 1   = A/D channel no (0-12) 
# byte 2&3 = destination address
# NB AD Ch 6 (MAF) is read and saved elsewhere, to IMAF (0x124)
#############################################################

 AD_channel_tbl:
225f: 00,20,01   struct           0,ITAR                                           # Throttle position sensor rate
2262: 01,10,01   struct           1,IVCAL                                          # Reference Voltage (2.5V)
2265: 02,0c,01   struct           2,IIVPWR                                         # Battery voltage
2268: 03,0e,01   struct           3,IOCC                                           # Output Circuit Check
226b: 04,18,01   struct           4,IVSCCS                                         # Speed control driver switches (not present on A9L)
226e: 05,1e,01   struct           5,IEGO2                                          # Exhaust Gas Oxygen sensor 2
2271: 07,22,01   struct           7,ITP                                            # Throttle position sensor
2274: 08,12,01   struct           8,IECT                                           # Engine Coolant Temperature
2277: 09,14,01   struct           9,IACT                                           # Air charge temperature
227a: 0a,1a,01   struct           a,INDS                                           # Multiplexed: Neutral Drive Switch (NDS),
                                                                                   #  Air Conditioner Cycling Control (A3C),
                                                                                   #  Heated Windscreen (not present on A9L)
227d: 0b,1c,01   struct           b,IEGO1                                          # Exhaust Gas Oxygen sensor 1
2280: 0c,16,01   struct           c,IEVP                                           # EGR Valve position
2283: ff         byte           ##  terminator                                     # end of Table marker


##########################
# Table used for High Speed Output (HSO).  Called from several places
# 8 byte entries are - 
# Offset  Description
# 0,1  Subroutine call address
# 2    Always 0 ??
# 3    HSO command to send, plus bits 6 & 7
#       B6 = 1 Don't keep o/p state in HSOut_Flags   
#       B7 = 1 Do extra subroutine at [ptr+6] if set (only in Do_CmdP)   
#         (Do_CmdN always calls the routine)
# 4    Max count of Queued HSO events (hardware is 12 max); use s/w queue if count is >= 
# 5    RAM table offset for this entry - add 2C5 for address
# 6,7  Subroutine call address
# commands entries are therefore 
# 2286  ch 9 (KTS)    ON, no int, don't keep state,   call Do_CmdN  then calls Add_H_Delta    (clears C flag)
# 228e  ch 9 (KTS)   OFF,    int, no ON, clear bit 9, call Do_CmdP  then calls Add_H_Beta     (clears C flag)
# 2296  ch 5 (SPOUT)  ON, no int, don't keep state,   call Do_CmdN  then calls Add_SpoutLo    (clears C flag)
# 229e  ch 5 (SPOUT) OFF,    int, no ON, clear bit 5, call Do_CmdP  then calls upd_Htime_pend (clears C flag)
############################################

  HSOTable:
2284: 58,23               vect  2358,            Clr_cell

2286: f9,24,00,59,0b,5d,11,6d   struct Do_CmdN,  0, 59,  b, Q9, Add_H_Delta
228e: 0d,25,00,c9,0b,5d,d8,6c   struct Do_CmdP,  0, c9,  b, Q9, Add_H_Beta
2296: f9,24,00,55,0c,03,88,2c   struct Do_CmdN,  0, 55,  c, Q0, Add_SpoutLo
229e: 0d,25,00,c5,0c,03,61,2c   struct Do_CmdP,  0, c5,  c, Q0, upd_Htime_pend


##################################################################
# Injector timing Table. 22 bytes per cyl (12 ON, 10 OFF ?) 
# See Send_HSO_Cmd()
#
# (Offset, Size, Purpose)
#
# 0  subroutine call - 325a is 'Send HSO' command
# 2  Always 0 ??
# 3  byte  HSO command to send:
#   - bits 0-3: 0-9 - output port #
#               a-e - no output, but bit 5 generates HSO int #1; ch. a (10) used for 1ms tick
#                 f - no output, generates HSO int #2, used for engineering console service routine
#   - bit 4: 1 = output high (on); 0 = output low (off)
#   - bit 5: 1 = generate output interrupt #1; 0 = no interrupt
#   - bits 6-7: ignored
# 4  byte  Schedule event in s/w queue if HSO CAM already has this many entries or more
# 5  byte  offset into 2C5 scheduling Table
# 6  byte  bit mask for setting
# 7  byte  bit mask for clearing
# 8  word  injector cyl no (port no)
# A  word  HSOut_Flags bit mask
# #######################
# C  (0) Subroutine call - 3273 is 'Send HSO' Command 
# F  (3) byte HSO (OFF) command to send
# 10 (4) byte 12 = count of or max for HSO queue ?
# 11 (5) byte offset into 2C5 scheduling Table
# 12 (6) byte bit mask for setting
# 13 (7) byte bit mask for clearing
# 14 (8) word injector cyl no (port no)

##################################################################

  InjTTab:
#
#                                                    fn,  0, cmd,          bit, mask, cyl#,
22a6: 5a,32,00,16,0a,0f,01,fe,01,00,40,00   struct Sub6,  0,  16,  a,  Q1,   1,   fe,    1,   40,
22b2: 73,32,00,06,0c,0f,01,fe,01,00         struct Sub7,  0,   6,  c,  Q1,   1,   fe,    1
22bc: 5a,32,00,17,0a,1b,02,fd,02,00,80,00   struct Sub6,  0,  17,  a,  Q2,   2,   fd,    2,   80,
22c8: 73,32,00,07,0c,1b,02,fd,02,00         struct Sub7,  0,   7,  c,  Q2,   2,   fd,    2
22d2: 5a,32,00,10,0a,25,04,fb,03,00,01,00   struct Sub6,  0,  10,  a,  Q3,   4,   fb,    3,    1,
22de: 73,32,00,00,0c,25,04,fb,03,00         struct Sub7,  0,   0,  c,  Q3,   4,   fb,    3
22e8: 5a,32,00,11,0a,2f,08,f7,04,00,02,00   struct Sub6,  0,  11,  a,  Q4,   8,   f7,    4,    2,
22f4: 73,32,00,01,0c,2f,08,f7,04,00         struct Sub7,  0,   1,  c,  Q4,   8,   f7,    4
22fe: 5a,32,00,14,0a,39,10,ef,05,00,10,00   struct Sub6,  0,  14,  a,  Q5,  10,   ef,    5,   10,
230a: 73,32,00,04,0c,39,10,ef,05,00         struct Sub7,  0,   4,  c,  Q5,  10,   ef,    5
2314: 5a,32,00,12,0a,43,20,df,06,00,04,00   struct Sub6,  0,  12,  a,  Q6,  20,   df,    6,    4,
2320: 73,32,00,02,0c,43,20,df,06,00         struct Sub7,  0,   2,  c,  Q6,  20,   df,    6
232a: 5a,32,00,13,0a,4d,40,bf,07,00,08,00   struct Sub6,  0,  13,  a,  Q7,  40,   bf,    7,    8,
2336: 73,32,00,03,0c,4d,40,bf,07,00         struct Sub7,  0,   3,  c,  Q7,  40,   bf,    7
2340: 5a,32,00,18,0a,57,80,7f,08,00,00,01   struct Sub6,  0,  18,  a,  Q8,  80,   7f,    8,  100,
234c: 73,32,00,08,0c,57,80,7f,08,00         struct Sub7,  0,   8,  c,  Q8,  80,   7f,    8
 InjTTab_end:
2356: 07,00               word      7


##################################################################
# called from HSOTable
##################################################################

  Clr_cell:
2358: c7,7e,01,00         stb   R0,[R7e+1]       [Rtab+1] = 0;
235c: f0                  ret                    return;


#################################################################
# Validate KAM signature and initialize if invalid
##################################################################

  check_KAM:
235d: a1,5a,07,22         ldw   R22,75a          R22 = LTMTB200;
2361: 71,7f,28            an2b  R28,7f           KAM_ERROR = 0;
2364: b1,aa,42            ldb   R42,aa           R42 = aa;                         # to check KAM signature
2367: b1,c6,30            ldb   R30,c6           R30 = c6;
236a: b1,75,32            ldb   R32,75           R32 = 75;
236d: 9b,22,a6,42         cmpb  R42,[R22+a6]
2371: d7,0f               jne   2382             if (aa = KAMQA)  {                # Z_KAMCLR replaces this JNE with SJMP
2373: 9b,22,56,30         cmpb  R30,[R22+56]     
2377: d7,09               jne   2382             if (c6 = KAMQB)  {
2379: 9b,23,88,00,32      cmpb  R32,[R22+88]     
237e: d7,02               jne   2382             if (75 != KAMQC) goto 2382;
2380: 20,3a               sjmp  23bc             return; } }                       # KAM valid

2382: 91,80,28            orb   R28,80           KAM_ERROR = 1;                    # KAM invalid
# Write expected signature 
2385: c7,22,a6,42         stb   R42,[R22+a6]     KAMQA = R42;                      # 700 = 0xAA
2389: c7,22,56,30         stb   R30,[R22+56]     KAMQB = R30;                      # 7b0 = 0xC6
238d: c7,23,88,00,32      stb   R32,[R22+88]     KAMQC = R32;                      # 7e2 = 0x75
2392: 91,40,d8            orb   Rd8,40           Vip_kam = 1;
2395: ef,08,54            call  77a0             clear_KAM();
2398: a1,80,a2,38         ldw   R38,a280         R38 = a280;                       # default EVP value
239c: c3,01,ee,07,38      stw   R38,[R0+7ee]     EPTZER = R38;                     # Rolling avg of EPT sensor at Idle (counts)
23a1: ef,2f,62            call  85d3             Sub121();                         # Init tables at 703 and 759
23a4: a1,04,00,32         ldw   R32,4            R32 = 4;
23a8: a1,e4,07,30         ldw   R30,7e4          R30 = &ISCKAM0;
23ac: c2,31,00            stw   R0,[R30++]       [R30++] = 0;                      # clear Idle Speed KAM IPSIBR cells
23af: e0,32,fa            djnz  R32,23ac         R32--;
                                                 if (R32 != 0) goto 23ac;
23b2: c3,01,ec,07,00      stw   R0,[R0+7ec]      ISKSUM = 0;
23b7: c7,22,66,00         stb   R0,[R22+66]      [R22+66] = 0;                     # Clear KAM Flags (7C0)
23bb: f0                  ret                    return;

23bc: f0                  ret                    return;


###############################################################
# Send command to HSO, does actual output unless HSO CAM full
#
# Input Parameter Registers:
#  R4c - HSO mode/status -
#   bit 1: Bypass_time_check - caller knows this is neither too late or too early, just do it
#   bit 2: Bypass_limit 
#   bit 3: Immediate 
#   bit 7: No_queue - do not schedule in s/w queue if CAM full
#  R80,1,2 = Requested time to fire event (24 bits)
#   (ignored if Immediate set)
#  R92 (TPtr) points to one of 2284 (ROM) table entries
#   [R92 + 3] = HSO Command to send
#   - bits 0-3: 0-9 - output port #
#               a-e - no electrical output, but bit 5 generates HSO int #1; ch. a (10) used for 1ms tick
#                 f - no electrical output, generates HSO int #2, used for engineering console service routine
#   - bit 4: 1 = output high (on); 0 = output low (off)
#   - bit 5: 1 = generate output interrupt #1; 0 = no interrupt
#   - bit 6: ignored by h/w; 1 = don't record in HSOut_Flags
#   - bit 7: ignored
#   [R92 + 4] = Schedule in s/w queue if HQcnt is this number or higher;
#               fail if No_queue set
#  Rcf (HQcnt) - Count of HSO CAM entries in use
#
# Outputs:
#  R44 (HSOut_Flags): Reflects commanded state of HSO outputs if B6 of HSO Command is NOT set
#  R4c - HSO status -
#   bit 3: Immediate
#   bit 4: No_service - failed to schedule the event
#   bit 5: Output will be later than requested
#   bit 6: Was scheduled in S/W queue
#  Rcf (HQcnt) - Count of HSO CAM entries in use
# sends injector pulses via HSO outputs
# NOTE - this proc short cuts the caller, forcing its exit, if no queue flag is set
###############################################################

  Send_HSO_Cmd:
23bd: b3,92,03,7d         ldb   R7d,[R92+3]      Cmd = [TPtr+3];                   # HSO command to send 
23c1: 71,8f,4c            an2b  R4c,8f           No_service = 0;                   # Clear HSO status flags
                                                 Late_output = 0;
                                                 Queued = 0;
# Update Reftime
# Bump ReftimeH if IO_Timer has wrapped since Reftime last updated
23c4: 48,8c,06,84         sb3w  R84,R6,R8c       R84 = IO_Timer - Reftime;
23c8: 64,84,8c            ad2w  R8c,R84          Reftime += R84;
23cb: b4,00,8e            adcb  R8e,R0           ReftimeH += CY;
#
23ce: 3b,4c,34            jb    B3,R4c,2405      if (Immediate == 1) goto 2405;
23d1: 39,4c,26            jb    B1,R4c,23fa      if (Bypass_time_check == 1) goto 23fa;  # caller has done time checks already
#
# Does requested time require special handling?
# 
23d4: 48,8c,80,84         sb3w  R84,R80,R8c      R84 = HSO_time - Reftime;
23d8: b0,82,86            ldb   R86,R82          R86 = HSO_timeH;
23db: b8,8e,86            sbbb  R86,R8e          R86 -= ReftimeH - CY;             # time until event needs to fire (24 bit)
23de: 3f,86,24            jb    B7,R86,2405      if (B7_R86 == 1) goto 2405;       # Event time in past - do immediately
23e1: d7,0c               jne   23ef             if (R86 != 0) goto 23ef;          # interval > 65536 ticks (157.3 ms) in future
23e3: 89,0c,00,84         cmpw  R84,c            
23e7: d3,1c               jltu  2405             if ((uns) R84 < c) goto 2405;     # interval < 29 uS - do immediately
23e9: 89,46,04,84         cmpw  R84,446          
23ed: d3,0b               jltu  23fa             if ((uns) R84 < 446) goto 23fa;   # interval < 2.626 ms
#
# Jump here from:
#  23e1 (Event > 65535 ticks in future)
#  2403 (HQcnt >= [TPtr+4])
#  2419 (HSO CAM full)
#  
23ef: 3f,4c,65            jb    B7,R4c,2457      if (No_queue == 1) goto 2457;     # time > 2.625 mS or queue full -
                                                                                   #  take failure exit
#
# Schedule in software queue
23f2: 71,20,4c            an2b  R4c,20           B0_Flags_4C = 0;
                                                 Bypass_time_check = 0;
                                                 Bypass_limit = 0;
                                                 Immediate = 0;
                                                 No_service = 0;
                                                 Queued = 0;
                                                 No_queue = 0;
23f5: 91,40,4c            orb   R4c,40           Queued = 1;
23f8: 20,63               sjmp  245d             goto Sched_HSO;                   # schedule command execution (via 2284/2C5 Table)
#
# Jump here from:
#  23d1 (Bypass_time_check requested)
#  23ed (29 us < Event < 2.626 ms)
#
# Check requested limit against HQcnt
23fa: 3a,4c,16            jb    B2,R4c,2413      if (Bypass_limit == 1) goto 2413;
23fd: 9b,92,04,cf         cmpb  Rcf,[R92+4]                                        # compare to HQCnt [Table+4] - count?
2401: d3,10               jltu  2413             if ((uns) HQcnt < [TPtr+4]) goto 2413; # we _think_ there's room in the CAM
2403: 27,ea               sjmp  23ef             goto 23ef;                        # Schedule in software
#
# Jump here from:
#  23ce (Immediate requested)
#  23de (Event time in past)
#  23e7 (Event time effectively now)
#
# Schedule event ASAP
2405: 91,28,4c            orb   R4c,28           Immediate = 1;
                                                 Late_output = 1;
2408: b0,8e,82            ldb   R82,R8e          HSO_timeH = ReftimeH;
240b: 45,0d,00,8c,80      ad3w  R80,R8c,d        HSO_time = Reftime + d;           # bump requested time into the (near) future
2410: b4,00,82            adcb  R82,R0           HSO_timeH += CY;
#
# Jump here from:
#  23fa (Bypass_limit)
#  2401 (HQcnt < [TPtr+4])
#
# Check if HSO CAM full
2413: 30,0a,05            jnb   B0,Ra,241b       if (HSO_OVF == 1)  {               
2416: b1,0c,cf            ldb   Rcf,c            HQcnt = c;                        # oops, HSO CAM is full, update HQcnt to reflect this
2419: 27,d4               sjmp  23ef             goto 23ef; }                      # jmp back to schedule on s/w queue

########### Set up HSO entry in h/w
241b: 49,01,00,80,0e      sb3w  Re,R80,1         HSO_Time = HSO_time - 1;          # set output change time
2420: b0,7d,0d            ldb   Rd,R7d           HSO_Cmd = Cmd;                    # command to send - from R92 entry[3]
2423: 3b,4c,17            jb    B3,R4c,243d      if (Immediate == 0)  {
2426: 3a,4c,14            jb    B2,R4c,243d      if (Bypass_limit == 0)  {
#
# Normal request
2429: 01,84               clrw  R84              R84 = 0;
242b: 51,07,81,84         an3b  R84,R81,7        R84 = R81 & 7;                    # = (timelo/256) & 7
242f: b3,85,b4,03,86      ldb   R86,[R84+3b4]    R86 = [R84+Slice_0];              # each slice is event count, in 614uS (0.6mS) slots ?
2434: 17,86               incb  R86              R86++;
2436: c7,85,b4,03,86      stb   R86,[R84+3b4]    [R84+Slice_0] = R86;              # increment relevant slice
243b: 17,cf               incb  Rcf              HQcnt++; } }
#
# Jump here from:
#  2423 (Immediate)
#  2426 (Bypass_limit)
#
243d: 71,71,4c            an2b  R4c,71           Bypass_time_check = 0;
                                                 Bypass_limit = 0;
                                                 Immediate = 0;
                                                 No_queue = 0;
2440: 3e,7d,13            jb    B6,R7d,2456      if (B6_Cmd == 1) return;          # no flag update requested
#
# Update HSOut_Flags to match commanded state
#
2443: 51,0f,7d,86         an3b  R86,R7d,f        R86 = Cmd & f;
2447: ad,01,84            ldzbw R84,1            R84 = (uns)1;
244a: 09,86,84            shlw  R84,R86          R84 <<= R86;
244d: 80,84,44            orw   R44,R84          HSOut_Flags |= R84;               # turn on corresponding bit
2450: 3c,7d,03            jb    B4,R7d,2456      if (B4_Cmd == 1) return;          # exit if was turn on cmd
2453: 84,84,44            xrw   R44,R84          HSOut_Flags ^= R84; }             # turn off corresponding bit
#
# Jump here from:
#  2440 (Interrupt requested)
#  2450 (Is turn on command)
#
2456: f0                  ret                    return;


# No_queue requested but HSO CAM was full or interval exceeded 16 bits
# Report failure
2457: b1,10,4c            ldb   R4c,10           Flags_4C = 10;                    # flags = No_service=1 others 0
245a: cc,00               pop   R0               R0 = pop();                       # SHORT CUT, return to GRANDcaller
245c: f0                  ret                    return;


##############################################################
# This proc defines a PWM ON or OFF event.
# The volatile info (time etc) are saved in the 2C5 Table in spots from
# 2284 Table  2286(KTS ON), 228E(KTS OFF), 2296(SPOUT ON), 229E(SPOUT OFF)
# 22A6 Table of injector events
# Inputs:
#  R80-82 24 bit time for event to execute (call events execute proc)
#  R92 (TPtr) - pointer to event entry in ROM table
# check if this functions entry is currently scheduled
# reserved for each ROM Table entry ( ROM offset 5 points to 2C5 Table entry)
# schedule subroutine for timed execution
#
# link (2c5) first byte is status ? jmps to activate if N=1, FF = NOT scheduled
#
# clobbers R7e-R7f, R86-R8a
##############################################################

  Sched_HSO:
245d: af,92,05,7e         ldzbw R7e,[R92+5]      Rtab = (uns)[TPtr+5];             # = 2C5 RAM Table offset for this entry
#
# R7e (word): RAM table offset corresponding to ROM table entry @ TPtr
#
2461: 57,7f,c5,02,00,88   ad3b  R88,R0,[R7e+2c5] R88 = [Rtab+HSOQ];                # = 1st byte(link) of 2C5 entry
2467: de,1a               jneg  2483             if (R88 >= 0)  {
2469: b1,ff,8a            ldb   R8a,ff           R8a = ff;                         # FF = out of service
246c: c7,7f,c5,02,8a      stb   R8a,[R7e+2c5]    [Rtab+HSOQ] = R8a;                # = link deactivated
2471: 57,7f,ca,02,00,8a   ad3b  R8a,R0,[R7e+2ca] R8a = [Rtab+2ca];                 # +5, link to next entry (OFF?)
2477: c7,89,c5,02,8a      stb   R8a,[R88+2c5]    [R88+HSOQ] = R8a;                 # = link deactivated
247c: da,05               jle   2483             if ((uns) R8a > 0)  {             # jump if end (no next entry)
247e: c7,8b,c5,02,88      stb   R88,[R8a+2c5]    [R8a+HSOQ] = R88; } }             # entry is valid so update link?
#
# Jump here from:
#  2467 (link of HSOQ entry is negative)
#  247c (R8a <= 0)
#
### populate entry - 2284 offset and new 24 bit activation time
#
# R7E (word): RAM table offset loaded from ROM table at entry
#
2483: 49,84,22,92,88      sb3w  R88,R92,2284     R88 = TPtr - HSOTable;            # convert to Table offset
2488: c7,7f,c6,02,88      stb   R88,[R7e+2c6]    [Rtab+SvStack] = R88;             # save low byte of *ROM* OFFSET in this 2C5 Table entry [1]
248d: c3,7f,c7,02,80      stw   R80,[R7e+2c7]    [Rtab+2c7] = HSO_time;            # save TimeLo16
2492: c7,7f,c9,02,82      stb   R82,[R7e+2c9]    [Rtab+2c9] = HSO_timeH;           # save TimeHi8
2497: af,92,02,88         ldzbw R88,[R92+2]      R88 = (uns)[TPtr+2];              # load offset (2C5) to list head (?) from 2284 Table pointer
                                                                                   # (is always 0??)
249b: 57,89,c5,02,00,8a   ad3b  R8a,R0,[R88+2c5] R8a = [R88+HSOQ];                 # R8A is offset of RAM list head ??
24a1: 20,0a               sjmp  24ad             goto 24ad;                        # insert into list by activation time

#### insert entry in 2C5 list by activation time
#
#
# Jump here from:
#  24c6 (link field of HSOQ entry == 0)
#
24a3: 55,05,8a,88         ad3b  R88,R8a,5        R88 = R8a + 5;                    # flip to other 'side' of entry ?
24a7: 57,8b,ca,02,00,8a   ad3b  R8a,R0,[R8a+2ca] R8a = [R8a+2ca];                  # traverse link + 5

# Enter loop here from 2467 - will fall through
#   *** what is value of R8A???
# Enter loop here from 247c - R8a <= 0 - will jump
# R8A (byte?) = offset of entry to check
24ad: d2,12               jgt   24c1             if (R8a <= 0)  {                  #

### end of list - insert at end of list
# R7E (word) = RAM table offset loaded at entry
# R88 (word?) = offset to RAM table entry ?
24af: c7,7f,ca,02,8a      stb   R8a,[R7e+2ca]    [Rtab+2ca] = R8a;                 # save in other 'side' link?
24b4: c7,89,c5,02,7e      stb   R7e,[R88+2c5]    [R88+HSOQ] = Rtab;                #
24b9: 65,c5,02,7e         ad2w  R7e,2c5          Rtab += HSOQ;                     # convert 2C5 offset to address
24bd: c6,7e,88            stb   R88,[R7e]        [Rtab] = R88;
24c0: f0                  ret                    return; }
#
24c1: 9b,8b,c6,02,00      cmpb  R0,[R8a+2c6]                                       # (ROM offset? )offset 1 (0 value means time/entry not valid/active? )
24c6: df,db               je    24a3             if (0 == [R8a+SvStack]) goto 24a3; # loop if offset link = 0

### this is an active entry - compare event times

24c8: 8b,8b,c7,02,80      cmpw  R80,[R8a+2c7]                                      # execute time Lo 16 bits
24cd: b0,82,86            ldb   R86,R82          R86 = HSO_timeH;
24d0: bb,8b,c9,02,86      sbbb  R86,[R8a+2c9]    R86 -= [R8a+2c9] - CY;            # execute time Hi 8 bits
24d5: 37,86,cb            jnb   B7,R86,24a3      if (B7_R86 == 0) goto 24a3;       # if new event time is after this entry time then loop

### insert in list before R8A entry

24d8: a0,8a,88            ldw   R88,R8a          R88 = R8a;
24db: af,89,c5,02,8a      ldzbw R8a,[R88+2c5]    R8a = (uns)[R88+HSOQ];
24e0: c7,8b,c5,02,7e      stb   R7e,[R8a+2c5]    [R8a+HSOQ] = Rtab;
24e5: 75,05,7e            ad2b  R7e,5            Rtab += 5;                        # offset to flip side of RAM table entry
24e8: c7,89,c5,02,7e      stb   R7e,[R88+2c5]    [R88+HSOQ] = Rtab;
24ed: 65,c0,02,7e         ad2w  R7e,2c0          Rtab += MPHTIM1H;                 # pointer to base side of entry
24f1: c6,7e,8a            stb   R8a,[R7e]        [Rtab] = R8a;
24f4: c7,7e,05,88         stb   R88,[R7e+5]      [Rtab+5] = R88;
24f8: f0                  ret                    return;


#############################################################
# subroutine called from .
# send command from Tptr+3, then change TPtr to next entry (+8)
# and execute subroutine at [Tptr-2]  ([Tptr+6] from orig locn)
#############################################################

  Do_CmdN:
24f9: 2e,c2               scall 23bd             Send_HSO_Cmd();                   # send HSO command and other stuff
24fb: 3e,4c,2a            jb    B6,R4c,2528      if (Queued == 1) return;          # HSO CAM full, can't do right now
24fe: 65,08,00,92         ad2w  R92,8            TPtr += 8;                        # move to next entry
2502: c9,09,25            push  2509             push(Sub1);                       # push return address
2505: cb,92,fe            push  [R92+fe]         call([TPtr-2]);                   # call subroutine from -2 of next entry
2508: f0                  ret
#
# Return here from indirect call
#
  Sub1:
2509: db,25               jc    2530             if (C flag set) goto 2530;        # must reschedule the event
250b: 20,00               sjmp  250d             goto Do_CmdP;                     # drop through if reschedule


#############################################################
# subroutine called from .
# send command from Tptr+3,
# IF B7 Cmd SET - change TPtr to prev entry (-8)
# and execute subroutine at [Tptr-14]  ([Tptr+6] from orig locn)
#############################################################

  Do_CmdP:
250d: 2e,ae               scall 23bd             Send_HSO_Cmd();                   # send HSO command and other stuff
250f: 3e,4c,16            jb    B6,R4c,2528      if (Queued == 1) return;
2512: 37,7d,0f            jnb   B7,R7d,2524      if (B7_Cmd == 0) goto 2524;
2515: 69,08,00,92         sb2w  R92,8            TPtr -= 8;                        # R92 pointer to Previous entry
2519: c9,20,25            push  2520             push(Sub2);                       # push return address
251c: cb,92,0e            push  [R92+e]          call([TPtr+e]);                   # get subroutine address from ON entry
251f: f0                  ret                                                      # and call it
#
# Return here from indirect call
#
  Sub2:
2520: db,0e               jc    2530             if (C flag set) goto 2530;        # must reschedule event
2522: 27,d5               sjmp  24f9             goto Do_CmdN;                     # schedule ON event execution
#
2524: c7,7e,01,00         stb   R0,[R7e+1]       [Rtab+1] = 0;                     # processed ?
2528: f0                  ret                    return;

#
# Never gets to here??
#
2529: c9,30,25            push 2530              push(address of Sched_HSO call);  # Push return address 
252c: cb,92,04            push [R92+4]           call([Tptr+4]);                   # Get subroutine address from OFF entry
252f: f0                  ret                                                      # and call it
#
# Return here from indirect call
#
# Jump here from:
#  2509 (Carry set)
#
2530: 2f,2b               scall 245d             Sched_HSO();                      # schedule a routine for execution in 2284/2C5 Table
2532: f0                  ret                    return;


###########################################################
# Read HSI data
# The opening arithmetic converts the 16 bit IO TIMER (o/flow every 0.157 secs) into 24 bit value
# (with overflow every 40.2 secs). 
# R7a,b,c is the EVENT time for the HSI Interrupt
# HSI data is then processed and reqd handlers called
# *** CALLED IN INTERRUPT HANDLER CONTEXT ***
###########################################################

  Read_hsi:
2533: 34,d8,01            jnb   B4,Rd8,2537      if (Sto_pending == 1)  {                                       1.8 us
2536: f0                  ret                    return; }
#
# Update Reftime
# Bump ReftimeH if IO_Timer has wrapped since Reftime last updated
2537: 48,8c,06,84         sb3w  R84,R6,R8c       R84 = IO_Timer - Reftime;         # time diff                  1.0 us
253b: 64,84,8c            ad2w  R8c,R84          Reftime += R84;                   # add diff (24 bits)         0.8
253e: b4,00,8e            adcb  R8e,R0           ReftimeH += CY;                                                0.8
#
# Calculate Event_time from Reftime
2541: b0,8e,7c            ldb   R7c,R8e          Event_timeH = ReftimeH;           # set event time Hi          0.8
2544: 48,0e,8c,84         sb3w  R84,R8c,Re       R84 = Reftime - HSI_Time;         # time diff since event (Lo) 1.0
2548: 65,02,00,84         ad2w  R84,2            R84 += 2;                         # add propagation delay ?    1.0
254c: 48,84,8c,7a         sb3w  R7a,R8c,R84      Event_time = Reftime - R84;       # corrected event time       1.0
2550: b8,00,7c            sbbb  R7c,R0           Event_timeH -= CY;                # (24 bit)                   0.8
#
# Determine which HSI signal(s) changed
2553: b0,0d,83            ldb   R83,Rd           HSI_State = HSI_Data;             # read HSI data              0.8
2556: b0,90,87            ldb   R87,R90          New_irqs = Last_HSI;              # current state              0.8
2559: 94,83,87            xorb  R87,R83          New_irqs ^= HSI_State;            # get changed bits           0.8
255c: 70,0c,87            an2b  R87,Rc           New_irqs &= HSI_Mask;             # mask for valid inputs      0.8
255f: b0,83,90            ldb   R90,R83          Last_HSI = HSI_State;             # New state                  0.8
2562: 11,4c               clrb  R4c              Flags_4C = 0;                                                  0.8
#
# Handle the changed signals
#
2564: 98,87,00            cmpb  R0,R87           
2567: df,4a               je    25b3             if (0 != New_irqs)  {
2569: 37,87,03            jnb   B7,R87,256f      if (Idm_irq == 1)  {
256c: ef,16,5f            call  8485             Idm_inth(); }                     # handle Ign Diag Mon
256f: 36,87,03            jnb   B6,R87,2575      if (Mph_irq == 1)  {
2572: ef,a0,04            call  2a15             Vss_inth(); }                     # handle VSS counts
2575: 35,87,03            jnb   B5,R87,257b      if (Cid_irq == 1)  {
2578: ef,53,04            call  29ce             Cid_inth(); }                     # handle CID (not used in A9L)
257b: 32,87,03            jnb   B2,R87,2581      if (Bap_irq == 1)  {
257e: ef,0f,10            call  3590             Bap_inth(); }                     # handle BP/MAP
2581: 31,87,03            jnb   B1,R87,2587      if (Knk_irq == 1)  {
2584: ef,08,47            call  6c8f             Knk_inth(); }                     # handle KNK (not used in A9L)
2587: 30,87,03            jnb   B0,R87,258d      if (Pip_irq == 1)  {
258a: ef,3d,02            call  27ca             Pip_inth(); }                     # handle PIP
258d: 98,00,87            cmpb  R87,R0           
2590: df,21               je    25b3             if (New_irqs != 0)  {             # any more events?
#
# Unexpected event - recalculate HSI interrupt mask
#
# N.B. Calculation of HSI_Mask could be collapsed into simply loading a constant
# For A9L, that constant is 0xC5: PIP, BP, VSS, IDM
#
2592: b1,87,0c            ldb   Rc,87            HSI_Mask = 87;                    # PIP, KI, BP, IDM enabled
2595: 9b,f8,4a,00         cmpb  R0,[Rf8+4a]      
2599: d7,03               jne   259e             if (0 == KIHP)  {                 # knock sensor fitted? (not in A9L)
259b: b1,85,0c            ldb   Rc,85            HSI_Mask = 85; }                  # No, mask int
#
259e: 9b,fe,0c,00         cmpb  R0,[Rfe+c]       
25a2: df,03               je    25a7             if (0 != HP_CID)  {               # CID sensor fitted? (not in A9L)
25a4: 91,20,0c            orb   Rc,20            HSI_Mask |= 20; }                 # Yes, allow int
#
25a7: 9b,f2,47,00         cmpb  R0,[Rf2+47]                                        # VSS sensor fitted? (VSTYPE = 1 on A9L)
25ab: df,03               je    25b0             if (0 != VSTYPE)  {               #
25ad: 91,40,0c            orb   Rc,40            HSI_Mask |= 40; }                 # Yes, allow int
#
25b0: 91,01,4e            orb   R4e,1            Hsi_error = 1; } }                # flag extra events
#
# Jump here from 2590
25b3: 32,0a,02            jnb   B2,Ra,25b8       if (HSI_Ready == 0) return;
25b6: 27,7b               sjmp  2533             goto Read_hsi;                    # repeat until HSI stack empty

25b8: f0                  ret                    return;


#############################################################
# High Speed Output Port Output Interrupt Handler
# Software interrupt every 1 msec
# Input:
#  R91 = Slice ptr, is changed every 614uS? (0.6 mS) and is 0-7 (3b4-3bb)
# This base s/w clock int is used to drive a large Table of s/w routines
# including updating the MAF integrator and creating PWM output signals.
##############################################################

  I_HSO_1:
25b9: f2                  pushp                  push(PSW);
25ba: 38,d8,08            jb    B0,Rd8,25c5      if (Sto_holdoff == 0)  {
# Reset timer
25bd: 45,a1,01,06,0e      ad3w  Re,R6,1a1        HSO_Time = IO_Timer + 1a1;        # = 1msec at 15Mhz
25c2: b1,2a,0d            ldb   Rd,2a            HSO_Cmd = 2a; }                   # int enabled, level low, channel 10
#
25c5: c3,74,06,06         stw   R6,[R74+6]       Last_HSO = IO_Timer;              # save current IO time
25c9: c3,74,48,10         stw   R10,[R74+48]     SvStack = STACK;                  # save background stack pointer
25cd: ad,72,10            ldzbw R10,72           STACK = (uns)72;                  # switch to interrupt stack
25d0: ac,91,50            ldzbw R50,R91          R50 = (uns)Slice_ptr;             # Hang on to previous value of Slice_ptr
25d3: 51,07,8d,91         an3b  R91,R8d,7        Slice_ptr = R8d & 7;              # Reftime/256 & 0x7
#
# Mark the HSO events between last update and now done
#
# R50 = index of slice to be counted, range 0-7
#
25d7: 98,50,91            cmpb  R91,R50          
25da: df,15               je    25f1             if (Slice_ptr != R50)  {          # Caught up to present yet?
25dc: 7b,51,b4,03,cf      sb2b  Rcf,[R50+3b4]    HQcnt -= [R50+Slice_0];           # Count the events in this slice as done
25e1: db,02               jgeu  25e5             if (HQcnt < 0)  {
25e3: 11,cf               clrb  Rcf              HQcnt = 0; }                      # Clip to 0 on underflow
#
25e5: c7,51,b4,03,00      stb   R0,[R50+3b4]     [R50+Slice_0] = 0;                # Clear count of this slice
25ea: 17,50               incb  R50              R50++;                            # Look at next slice
25ec: 71,07,50            an2b  R50,7            R50 &= 7;                         #  modulo 8
25ef: 27,e6               sjmp  25d7             goto 25d7; }                      # loop back
#
25f1: e7,ed,0d            jump  33e1             goto HSO_1_continued;

 ##### Code segment 33e1 to 358d - mostly low speed bit-banging I/O - executed here and continues at 25f4 #####
 
25f4: 91,01,47            orb   R47,1            B0_Flags_47 = 1;                  # BIDI O/P line 0 ON
25f7: a0,46,50            ldw   R50,R46          R50 = IO_Port_State;              # R50 = (new ?) LSO and BIDI OP values
25fa: 85,00,00,50         xrw   R50,0            R50 ^= 0;                         # *** This could be xrw R50,R0
25fe: b0,50,02            ldb   R2,R50           LSO_Port = R50;
2601: b0,51,03            ldb   R3,R51           LIO_Port = R51;                   # write OUTPUTS
2604: 18,02,51            shrb  R51,2            R51 /= 4;                         # shift over low 2 bits
2607: c7,01,2f,09,51      stb   R51,[R0+92f]     [92f] = R51;                      # Write to RAM off-chip port

#### traverse the 2C5 queue, execute subroutine for each entry whose time is up
#### does not remove or add any queue entries
260c: 01,94               clrw  R94              R94 = 0;
260e: 01,96               clrw  R96              R96 = 0;
#
# Jump here from:
#  269f 
#
2610: b1,80,4c            ldb   R4c,80           Flags_4C = 80;                    # don't enqueue the HSO command, we're reading from the queue!
#
# Jump here from:
#  2641 (get next queue entry)
#
# R94 (word) = offset of previous entry into 2c5 queue
#  N.B. Initial value of 0 points loads Rtab from 2c5, which is initialized to 3
#
2613: 57,95,c5,02,00,7e   ad3b  R7e,R0,[R94+2c5] Rtab = [R94+HSOQ];
2619: d7,02               jnz   261d             if (Rtab != 0) goto 261d;
261b: 20,84               sjmp  26a1             goto 26a1;                        # exit when 2C5[R94] == 0
#
# R7e (Rtab) word = offset of current entry in 2c5 queue
#  N.B. First pass that will be 3
#
261d: 11,7f               clrb  R7f              R7f = 0;                          # clear hi byte of R7e word to use as index
#
# *** N.B. R92 is a *byte* which is an *offset* into the 2284 table here ***
#     NOT a word pointer to a table entry
#
261f: 57,7f,c6,02,00,92   ad3b  R92,R0,[R7e+2c6] R92 = [Rtab+HSOQ+1];              # offset of 2284 Table entry
2625: d7,1c               jnz   2643             if (R92 != 0) goto 2643;          # valid entry
#
# R92 == 0
2627: b1,ff,50            ldb   R50,ff
262a: c7,7f,c5,02,50      stb   R50,[R7e+2c5]    [Rtab+HSOQ] = ff;                 # mark entry
262f: 57,7f,ca,02,00,96   ad3b  R96,R0,[R7e+2ca] R96 = [Rtab+HSOQ+5];              # calc next entry
2635: c7,95,c5,02,96      stb   R96,[R94+2c5]    [R94+HSOQ] = R96;
263a: df,65               jz    26a1             if (R96 == 0) goto 26a1;          # loop exit when R96 == 0
263c: c7,97,c5,02,94      stb   R94,[R96+2c5]    [R96+HSOQ] = R94;
2641: 27,d0               sjmp  2613             goto 2613;                        # loop back for next entry
#
# Jump here from
#  2643 (R92 != 0)
#
# R7e (Rtab) word = offset of current entry in 2c5 queue
# R92 (TPtr) word = offset of corresponding entry in HSOTable
#
2643: 11,93               clrb  R93              R93 = 0;                          # clear hi byte of R92 word to use as index
#
# Update Reftime
# Bump ReftimeH if IO_Timer has wrapped since Reftime last updated
2645: 48,8c,06,84         sb3w  R84,R6,R8c       R84 = IO_Timer - Reftime;
2649: 64,84,8c            ad2w  R8c,R84          Reftime += R84;
264c: b4,00,8e            adcb  R8e,R0           ReftimeH += CY;                   # update master ref time
264f: a3,7f,c7,02,80      ldw   R80,[R7e+2c7]    HSO_time = [Rtab+HSOQ+2];         # event time for this entry
2654: b3,7f,c9,02,82      ldb   R82,[R7e+2c9]    HSO_timeH = [Rtab+HSOQ+4];
2659: 48,8c,80,84         sb3w  R84,R80,R8c      R84 = HSO_time - Reftime;         # time left to event
265d: b0,82,86            ldb   R86,R82          R86 = HSO_timeH;
2660: b8,8e,86            sbbb  R86,R8e          R86 -= ReftimeH - CY;
2663: 3f,86,0a            jb    B7,R86,2670      if (B7_R86 == 1) goto 2670;        # -ve, time passed, do immediately
2666: d7,39               jnz   26a1             if (R86 == 0)  {                   # still time left 
2668: 89,46,04,84         cmpw  R84,446          
266c: d1,05               jleu  2673             if ((uns) R84 <= 446) goto 2673;  # < 2.626 ms to go, process it ?
266e: 20,31               sjmp  26a1             goto 26a1;                        # skip until later ?
#
# Jump here from 2663 (event time in past)
#
2670: 91,08,4c            orb   R4c,8            Immediate = 1;                    # late event, flag immediate
#
# Jump here from 266c (event time < 2.626 ms in future)
#
2673: 89,42,00,84         cmpw  R84,42           
2677: d1,03               jleu  267c             if ((uns) R84 > 42 )  {
2679: 91,02,4c            orb   R4c,2            Bypass_time_check = 1; }          # Bypass time checks in Send_HSO_Cmd, we've done them already
#
267c: 65,c5,02,7e         ad2w  R7e,2c5          Rtab += HSOQ;                     # map to 2C5 Table pointer
2680: 65,84,22,92         ad2w  R92,2284         TPtr += HSOTable;                 # map to 2284 Table entry
2684: c9,8a,26            push  268a             push(Sub3);                       # return address for call
#
# Indirect call to routine address pointed to by TPtr
2687: ca,92               push  [R92]            push([TPtr]);
2689: f0                  ret                    return;                           # call subroutine from 2284 Table
#
# "Return" here from the indirect call
#
  Sub3:
268a: 34,4c,0c            jnb   B4,R4c,2699      if (No_service == 0) goto 2699;
#
# Failed to schedule an event
268d: 57,95,c5,02,00,94   ad3b  R94,R0,[R94+2c5] R94 = [R94+HSOQ];
2693: df,0c               jz    26a1             if (R94 != 0)  {
2695: 65,05,00,94         ad2w  R94,5            R94 += 5;                         # next 2C5 Table entry
#
# Jump here from:
#  268a (!No_service)
#
2699: 32,0a,03            jnb   B2,Ra,269f       if (HSI_Ready == 1)  {
269c: ef,94,fe            call  2533             Read_hsi(); }
#
269f: 27,6f               sjmp  2610             goto 2610; } }                    # back for next entry
#
# Jump here from:
#  261b ([R94+2c5] == 0)
#  263a (R96 == 0)
#  2666 (event > 65535 ticks in future)
#  266e (event > 2.626 ms in future)
#  2693 (R94 == 0)
#
26a1: 32,0a,02            jnb   B2,Ra,26a6       if (HSI_Ready == 1)  {
26a4: 2e,8d               scall 2533             Read_hsi(); }
#
26a6: 11,4c               clrb  R4c              Flags_4C = 0;
26a8: 88,48,00            cmpw  R0,R48           
26ab: df,10               jz    26bd             if (0 != Flags_48)  {
26ad: 37,48,03            jnb   B7,R48,26b3      if (CHANGE_FUELPW == 1)  {        # Update PW of injections in progress for bank
26b0: ef,8b,0c            call  333e             Sub9(); }
#
26b3: 35,48,02            jnb   B5,R48,26b8      if (HSO_CAM_Full == 1)  {         # HSO CAM was full during last console service interrupt
26b6: 28,ee               scall 27a6             Sched_Console_Intp(); }           # Try to reschedule console service again
#
26b8: 32,0a,02            jnb   B2,Ra,26bd       if (HSI_Ready == 1)  {
26bb: 2e,76               scall 2533             Read_hsi(); } }
#
# Jump here from:
#  26ab (R48 == 0)
#  26b8 (!HSI_Ready)
#
# Read low speed I/O
#
26bd: b3,01,30,09,51      ldb   R51,[R0+930]     R51 = [930];                      # ROM Port input
26c2: 19,02,51            shlb  R51,2            R51 *= 4;
26c5: b0,03,52            ldb   R52,R3           R52 = LIO_Port;                   # read bidirectional port (only place it is read)
26c8: 71,03,52            an2b  R52,3            R52 &= 3;                         # keep bits 0 and 1
26cb: 90,52,51            orb   R51,R52          R51 |= R52;
26ce: b0,0b,50            ldb   R50,Rb           R50 = HSI_Sample;                 # HSI sample
26d1: 85,00,00,50         xrw   R50,0            R50 ^= 0;                         # Redundant ?
26d5: c8,50               push  R50              push(R50);                        # save HSI AND Low speed sample
26d7: a3,74,c4,94         ldw   R94,[R74+c4]     R94 = Post_image;                 # last time HSI+ LS Sample
26db: 84,94,50            xrw   R50,R94          R50 ^= R94;                       # bits changed since last read
26de: 02,50               cplw  R50              R50 = ~R50;                       # swop bits back ?
26e0: a0,de,96            ldw   R96,Rde          R96 = Input_image;                # Last sample
26e3: 84,94,96            xrw   R96,R94          R96 ^= R94;                       # compare for changes
26e6: 60,96,50            an2w  R50,R96          R50 &= R96;
26e9: 84,50,de            xrw   Rde,R50          Input_image ^= R50;               # HSI and LS changes
26ec: cf,74,c4            pop   [R74+c4]         Post_image = pop();               # save this sample for next time
#
# Stave off watchdog timer
# R59 (high byte of IO_Timer read) increments every 614.4 (2.4 * 256) usec
# Watchdog needs to be written to every 9.22 msec or less
#
26ef: a0,06,58            ldw   R58,R6           R58 = IO_Timer;
26f2: 58,8f,59,50         sb3b  R50,R59,R8f      R50 = R59 - Wd_time;              # Time since last watchdog write
26f6: 99,02,50            cmpb  R50,2            
26f9: d3,1f               jltu  271a             if ((uns) R50 >= 2)  {
26fb: 95,40,02            xorb  R2,40            CPU_OK ^= 1;                      # keep alive
26fe: b0,59,8f            ldb   R8f,R59          Wd_time = R59;                    # update watchdog write time
2701: 17,05               incb  R5               WDG_Timer++;                      # keep the watchdog at bay
2703: 95,40,02            xorb  R2,40            CPU_OK ^= 1;                      # toggle line 6 (LOS)
#
# HSO table
#
2706: ad,09,50            ldzbw R50,9            R50 = (uns)9;                     # no of byte locations to add up
2709: 01,54               clrw  R54              R54 = 0;                          # init sum
# top of loop
270b: e0,50,05            djnz  R50,2713         R50--;
                                                 if (R50 != 0) goto 2713;          # test for done adding
270e: b0,54,cf            ldb   Rcf,R54          HQcnt = R54;                      # move sum to RCF
2711: 20,07               sjmp  271a             goto 271a; }                      # exit loop
#
2713: 77,51,b3,03,54      ad2b  R54,[R50+3b3]    R54 += [R50+ARCHCOR];             # add 8 bytes at Slice_0 save to HQcnt
2718: 27,f1               sjmp  270b             goto 270b; }                      # loop
#
# Prepare to exit handler
#
271a: 31,09,03            jnb   B1,R9,INT_RTN    if (Tmr_Ovfl_INT_Pend == 1)  {    # IO timer overflow pending
271d: b1,02,08            ldb   R8,2             INT_Mask = 2; }                   # allow only IO timer OVF interrupts
#
  INT_RTN:
2720: a3,74,48,10         ldw   R10,[R74+48]     STACK = SvStack;                  # restore saved stack pointer
2724: ff                  nop                    
2725: ff                  nop                    
2726: ff                  nop                    
2727: ff                  nop                                                      # safety delay ?
2728: fa                  di                     disable ints;
2729: f3                  popp                   PSW = pop();
272a: f1                  reti                   return;


#############################################################
## High Speed Input # 0 Interrupt Handler (read HSI data)
#############################################################

  I_HSI_0:
272b: f2                  pushp                  push(PSW);
272c: 91,00,02            orb   R2,0             LSO_Port |= 0;                    # clear interrupt request
272f: c3,74,48,10         stw   R10,[R74+48]     SvStack = STACK;                  # save background stack pointer
2733: ad,72,10            ldzbw R10,72           STACK = (uns)72;                  # use interrupt stack
2736: 32,0a,02            jnb   B2,Ra,273b       if (HSI_Ready == 1)  {            # could branch directly back to INT_RTN
2739: 2d,f8               scall 2533             Read_hsi(); }                     # read HSI data if avail
#
273b: 27,e3               sjmp  2720             goto INT_RTN;                     # restore background stack ptr and return


#############################################################
# Master I/O Timer Overflow Interrupt Handler
# neatly uses overflow to increment 24 bit counter.
# N.B. does NOT use interrupt stack
#############################################################

  I_Timer_OVF:
273d: f2                  pushp                  push(PSW);
273e: 07,12               incw  R12              Tmr_OVF_cnt++;                    # increment I/O Timer overflow
2740: d7,03               jne   2745             if (Tmr_OVF_cnt == 0)  {
2742: 91,04,4f            orb   R4f,4            Clkext_ovr = 1; }                 # flag Tmr wraparound
# Update Reftime
2745: b0,12,8e            ldb   R8e,R12          ReftimeH = Tmr_OVF_cnt;
2748: a0,06,8c            ldw   R8c,R6           Reftime = IO_Timer;               # save 24 bit time
274b: fa                  di                     disable ints;
274c: b1,a1,08            ldb   R8,a1            INT_Mask = a1;                    # reset int mask
274f: f3                  popp                   PSW = pop();                      # restore PSW and fall through to reti


#############################################################
# Handler for unused/unexpected interrupts
#############################################################

  I_Ignore:
2750: f1                  reti                   return;

#############################################################
# Calibration Console Timer Interrupt Handler
# Reset S/W interrupt every 5 ms, (2083 IOTimer ticks = 5 mS)
# and check Cal Console status and enter [console] routine if required
# effectively gives console a timeslice every 5mS
# N.B. does NOT use interrupt stack.
# N.B. Is not invoked if console H/W not present
#############################################################

  I_HSO_2:
2751: f2                  pushp                  push(PSW);
2752: fa                  di                     disable ints;
2753: ff                  nop                    
2754: 47,74,1a,00,50      ad3w  R50,R0,[R74+1a]  R50 = LastSWtime;                 # Time this interrupt was scheduled for
2759: df,21               je    277c             if (R50 != 0)  {                  # zero means set no more SW ints
275b: 48,06,50,52         sb3w  R52,R50,R6       R52 = R50 - IO_Timer;
275f: 37,53,1a            jnb   B7,R53,277c      if (R50 < IO_Timer)  {            # interrupt received earlier than time requested?
2762: 30,0a,05            jnb   B0,Ra,276a       if (HSO_OVF == 1)  {              # 
2765: 91,20,48            orb   R48,20           HSO_CAM_Full = 1;                 # HSO CAM full, can't reschedule now
2768: 20,12               sjmp  277c             goto 277c; }
# 
# Schedule next 5ms interrupt
276a: 65,23,08,50         ad2w  R50,823          R50 += 0x823;                     # Next s/w interrupt in 5 ms
276e: d7,02               jne   2772             if (R50 == 0)  {
2770: 07,50               incw  R50              R50++; }                          # avoid zero which means s/w ints are off
2772: c3,74,1a,50         stw   R50,[R74+1a]     LastSWtime = R50;                 # save NEXT scheduled s/w int time
2776: a0,50,0e            ldw   Re,R50           HSO_Time = R50;
2779: b1,0f,0d            ldb   Rd,f             HSO_Cmd = f; } }                  # set new software interrupt
#
# Check console status
#
277c: a3,01,00,0d,50      ldw   R50,[R0+d00]     R50 = [d00];                      # CONSOLE STATUS check
2781: 47,01,1a,c1,00,52   ad3w  R52,R0,[R0+c11a] R52 = [c11a];                     # [C11A] = scheduled time of this interrupt
                                                                                   #  - see 84cc
2787: df,19               je    27a2             if (R52 != 0)  {                  #                
2789: 99,2a,51            cmpb  R51,2a           
278c: d7,14               jne   27a2             if (R51 == 2a)  {                 # exit if no console
#
# Console is present
278e: 8b,01,1a,c1,00      cmpw  R0,[R0+c11a]     
2793: df,0d               je    27a2             if (0 != [c11a])  {
2795: 68,06,52            sb2w  R52,R6           R52 -= IO_Timer;
2798: 37,53,07            jnb   B7,R53,27a2      if (R52 < IO_Timer)  {            # if time has passed ?
279b: fa                  di                     disable ints;
279c: ff                  nop                    
279d: f3                  popp                   PSW = pop();
279e: c9,09,d0            push  d009             push(d009);                       # indirect call to console entry outside of interrupt context
27a1: f1                  reti                   return; } } } }
#
# No console or not yet time to hand off, just return
# Jump here from 2787, 278c, 2793, 2798
27a2: fa                  di                     disable ints;
27a3: ff                  nop                    
27a4: f3                  popp                   PSW = pop();
27a5: f1                  reti                   return;


##############################################################
# Reschedule 5ms console service software interrupt
# sets next software interrupt 5 millisecs after time in LastSWtime
# Ignores if HSO overflow
# *** CALLED IN INTERRUPT HANDLER CONTEXT ***
# Called from HSO port #1 interrupt handler
############################################################### 

  Sched_Console_Intp:
27a6: 38,0a,19            jb    B0,Ra,27c2       if (HSO_OVF == 0)  {              # simply return if queue still full
27a9: a3,74,1a,50         ldw   R50,[R74+1a]     R50 = LastSWtime;                 # scheduled time of most recent interrupt
27ad: 65,23,08,50         ad2w  R50,823          R50 += 823;                       # last int + 5msec
27b1: d7,02               jne   27b5             if (R50 == 0)  {
27b3: 07,50               incw  R50              R50++; }                          # avoid zero
#
27b5: c3,74,1a,50         stw   R50,[R74+1a]     LastSWtime = R50;                 # save NEXT time
27b9: a0,50,0e            ldw   Re,R50           HSO_Time = R50;
27bc: b1,0f,0d            ldb   Rd,f             HSO_Cmd = f;                      # schedule interrupt
27bf: 71,df,48            an2b  R48,df           HSO_CAM_Full = 0; }               # clear HSO overflowed flag
#
27c2: f0                  ret                    return;


27c3: ff                        


###############################################################
# Table 4,6,8 cyls - used at 3E5D initialization for Seq_max.
# Maximum PIP period (minimum RPM) to switch to sequential injection
###############################################################

27c4: 00,19               word   1900           # 4 cyl
27c6: ab,10               word   10ab           # 6 cyl
27c8: 80,0c               word    c80           # 8 cyl - 3200 ticks = 7.68 ms = ~1953 RPM


###############################################################
# handle HSI line 0 data (PIP)
# R7a,b,c = last HSI event time 24 bits
# R50,1,2 = time delta (time since last PIP event), ticks
# *** CALLED FROM HSI INTERRUPT HANDLER ***
###############################################################

  Pip_inth:
27ca: b1,06,04            ldb   R4,6             AD_Cmd = 6;                       # initiate read of MAF (AD ch 6)
27cd: 71,fe,87            an2b  R87,fe           Pip_irq = 0;                      # clear Pip IRQ pending flag
27d0: a3,76,46,54         ldw   R54,[R76+46]     R54 = MNPIP;                      # min plausible # of ticks between PIP High events
                                                                                   #  (hard rev limit)
27d4: 4b,74,50,7a,50      sb3w  R50,R7a,[R74+50] R50 = Event_time - Prev_PIP_time;
27d9: b0,7c,52            ldb   R52,R7c          R52 = Event_timeH;                # interval since last PIP high, ticks (24 bits)
27dc: bb,74,52,52         sbbb  R52,[R74+52]     R52 -= Prev_PIP_timeH - CY;       #  (overflows 16 bits at 0.157284 sec)
27e0: 38,90,02            jb    B0,R90,27e5      if (B0_Last_HSI == 1) goto PIP_Rising_Edge;
27e3: 21,35               sjmp  291a             goto PIP_Falling_Edge;

##### PIP Rising Edge handler
# R52:R50: # of ticks since last PIP rising edge (24 bits)
# R54 (word): MNPIP
#
  PIP_Rising_Edge:
27e5: 3c,2d,23            jb    B4,R2d,280b      if (FIRST_PIP == 0)  {
#
# Very first PIP rising edge event
# Initialize the injector events in the HSO RAM table (2c5) from InjTab table (22a6)
#
27e8: 91,10,2d            orb   R2d,10           FIRST_PIP = 1;
27eb: a1,a6,22,56         ldw   R56,22a6         R56 = InjTTab;                    # Base of ROM Table
#
27ef: 89,56,23,56         cmpw  R56,2356         
27f3: db,14               jgeu  2809             if (R56 < InjTTab_end)  {         # Are we done yet?
27f5: af,56,05,58         ldzbw R58,[R56+5]      R58 = (uns)[R56+5];               # offset of entry in 2C5 Table
                                                                                   #  - 0f on first pass -> Q1

                                                                                   #  Increments by 0a each entry for in InjTTab
27f9: c7,59,c2,02,7c      stb   R7c,[R58+2c2]    [R58+HSOQ-3] = Event_timeH;       # Store time of PIP rising edge (24 bits) (high byte first?)
27fe: c3,59,c3,02,7a      stw   R7a,[R58+2c3]    [R58+HSOQ-2] = Event_time;        
2803: 65,16,00,56         ad2w  R56,16           R56 += 16;                        # next InjTab entry (22 bytes)
2807: 27,e6               sjmp  27ef             goto 27ef; }                      # loop
#
2809: 20,2c               sjmp  2837             goto PIP_Rising_Edge_Common; }

##### PIP rising edge handler (not very first pip)
# R52:R50: # of ticks since last PIP High (24 bits)
# R54 (word): MNPIP
#
280b: 98,52,00            cmpb  R0,R52           
280e: d7,09               jne   2819             if (0 != R52) goto Valid_PIP;     # don't bother comparing MNPIP if > 65535 ticks
2810: 88,50,54            cmpw  R54,R50          
2813: d1,04               jleu  2819             if ((uns) MNPIP <= R50) goto Valid_PIP;
#
# PIP interval too small - ignore this event
2815: 71,fe,90            an2b  R90,fe           Last_HSI &= fe;                   # clear last PIP flag
2818: f0                  ret                    return;                           # and return
#
# Valid PIP interval
#
  Valid_PIP:
2819: 91,0c,4e            orb   R4e,c            New_Bpv = 1;
                                                 New_rpm = 1;
281c: 91,02,28            orb   R28,2            PTPFLG = 1;
281f: 9b,fe,0c,00         cmpb  R0,[Rfe+c]       
2823: d7,09               jne   282e             if (0 == HP_CID)  {               # CID sensor present ? (Not on A9L)
#
# Disable Dual_edge if fuel not in sync
#
2825: 3e,2e,06            jb    B6,R2e,282e      if (SYNFLG == 0)  {               # AE fuel - sync = 1, async = 0. Init to 0
2828: 3a,25,03            jb    B2,R25,282e      if (Mhpfd_neg == 0)  {            # Mhpfd_neg == 1 if MHPFD >= .50
                                                                                   # NOTE: MHPFD will always be fixed and less than .50
                                                                                   #  if HP_CID == 0 - see GUFB p. 6-102
282b: 71,fb,2d            an2b  R2d,fb           Dual_edge = 0; } } }
#
# Jump here from 2825 if fuel in sync
282e: 71,fe,4f            an2b  R4f,fe           Pip_double = 0;
2831: 32,2d,03            jnb   B2,R2d,2837      if (Dual_edge == 1)  {
2834: 91,01,4f            orb   R4f,1            Pip_double = 1; }
#
# Jump here from 2809 on very first PIP rising edge event
# Common code from here down
#
# R52:R50: # of ticks since last PIP High (24 bits)
# RBA (word): low 16 bits of DT12S
#
  Pip_Rising_Edge_Common:
2837: 91,80,4e            orb   R4e,80           New_pip = 1;
283a: c3,76,ba,ba         stw   Rba,[R76+ba]     DT23S = DT12S;                    # Previous PIP period
283e: a0,50,ba            ldw   Rba,R50          DT12S = R50;                      # new PIP period 24 bits
2841: b0,52,bc            ldb   Rbc,R52          DT12SH = R52;                     # period = time since last PIP High
2844: 9b,f8,19,00         cmpb  R0,[Rf8+19]      
2848: d7,03               jne   284d             if (0 == HP_HIDRES)  {            # High Data Rate Electronic Spark Present? (not present on A9L)
284a: ef,44,04            call  2c91             Calc_dwell(); }                   # first check is for TFI controlled dwell
#
284d: 98,00,bc            cmpb  Rbc,R0                                             # PIP time hi 8 bits
2850: d7,10               jne   2862             if (DT12SH == 0)  {
2852: 8b,76,48,ba         cmpw  Rba,[R76+48]                                       # PIP time lo 16 bits
2856: d9,0a               jgtu  2862             if ((uns) DT12S <= Seq_max)  {
2858: b3,fc,33,50         ldb   R50,[Rfc+33]     R50 = OUTINJ;                     # Sequential (1) or simultaneous (2) inject from calibration
285c: 39,50,03            jb    B1,R50,2862      if (B1_OUTINJ == 0)  {
285f: 71,f7,2e            an2b  R2e,f7           Simultaneous = 0; } } }           # Transition to sequential injection
#
2862: c3,74,50,7a         stw   R7a,[R74+50]     Prev_PIP_time = Event_time;       # PIP HSI event time lo 16 bits
2866: c7,74,52,7c         stb   R7c,[R74+52]     Prev_PIP_timeH = Event_timeH;     # PIP HSI event time hi 8 bits
#
# Part of Decel Fuel Shutoff Logic
# GUFB p. 6-71
#
286a: 39,ca,0c            jb    B1,Rca,2879      if (Declflg == 0)  {
286d: 17,b3               incb  Rb3              PPCTR++;                          # Count PIPs after coming out of DSO
286f: 9b,fc,53,b3         cmpb  Rb3,[Rfc+53]
2873: d1,04               jleu  2879             if ((uns) PPCTR > PIPNUM )  {
2875: b3,fc,53,b3         ldb   Rb3,[Rfc+53]     PPCTR = PIPNUM; } }               # Clip PPCTR to PIPNUM
#
# Jump here from:
#  258b (Declflg)
#  2864 (PPCTR <= PIPNUM)
#
# PIPCNT is used to transition out of crank mode only.
# It is cleared by set_rpm_flags() background task when CRKFLG == 0 or N <= NRUN
# It is NOT cleared when CRKFLG == 1 && N > NRUN && (ECTCNT < 8 || PIPCNT <= NCNT);
#  i.e. RPM is above run threshold, but haven't counted 2 revs worth of PIPs since
# At all other times it should be close to 0.
#
2879: 17,b4               incb  Rb4              PIPCNT++;                         # increment PIPCNT
287b: d7,02               jne   287f             if (PIPCNT == 0)  {
287d: 15,b4               decb  Rb4              PIPCNT--; }                       # clip to 255
#
287f: 17,9c               incb  R9c              ANPIP1++;
2881: d7,02               jne   2885             if (ANPIP1 == 0)  {
2883: 15,9c               decb  R9c              ANPIP1--; }                       # clip to 255
2885: 17,9d               incb  R9d              ANPIP2++;
2887: d7,02               jne   288b             if (ANPIP2 == 0)  {
2889: 15,9d               decb  R9d              ANPIP2--; }                       # clip to 255
288b: 35,2a,0a            jnb   B5,R2a,2898      if (RUNNING == 1)  {
#
# RUNNING == 1 - KOER self test mode
#
288e: a3,72,76,50         ldw   R50,[R72+76]     R50 = Vcb_pip_cnt;
2892: 07,50               incw  R50              R50++;
2894: c3,72,76,50         stw   R50,[R72+76]     Vcb_pip_cnt = R50; }
#
# Jump here from:
#  288b (!RUNNING)
#
2898: 75,20,d1            ad2b  Rd1,20           SYNCTR += 20;
289b: 9b,f8,19,00         cmpb  R0,[Rf8+19]      
289f: d7,03               jne   28a4             if (0 == HP_HIDRES)  {
28a1: ef,65,42            call  6b09             Sub36(); }                        # Call if HIDRES not present (not present on A9L)
#
28a4: 33,0a,fd            jnb   B3,Ra,28a4       if (AD_Ready == 0) goto 28a4;     # spin wait for MAF A/D conversion complete
#
28a7: 51,f0,04,50         an3b  R50,R4,f0        R50 = AD_Low & f0;                # mask out channel no
28ab: b0,05,51            ldb   R51,R5           R51 = AD_High;
28ae: c3,72,a4,50         stw   R50,[R72+a4]     IMAF = R50;                       # save as IMAF
28b2: 30,4f,03            jnb   B0,R4f,28b8      if (Pip_double == 1)  {
28b5: ef,5c,43            call  6c14             Sub37(); }                        # Transient spark compensation - only caller
#
28b8: 71,7f,4f            an2b  R4f,7f           KNOCK_OCCURRED = 0;
28bb: 33,4f,09            jnb   B3,R4f,28c7      if (KNOCK_DETECTED == 1)  {       # always 0 on A9L
28be: 91,80,4f            orb   R4f,80           KNOCK_OCCURRED = 1;
28c1: 39,90,03            jb    B1,R90,28c7      if (B1_Last_HSI == 0)  {
28c4: 71,f7,4f            an2b  R4f,f7           KNOCK_DETECTED = 0; } }
#
28c7: a1,96,22,92         ldw   R92,2296         TPtr = 2296;                      # SPOUT ON entry in 2284 Table
28cb: 9b,f8,19,00         cmpb  R0,[Rf8+19]      
28cf: df,07               je    28d8             if (0 == HP_HIDRES) goto 28d8;    # no HIDRES h/w in A9L
#
# Only executed if HIDRES present (not on A9L)
28d1: 3a,a1,2e            jb    B2,Ra1,2902      if (UNDSP == 0)  {                # Underspeed Flag
28d4: 29,76               scall 2a4c             Spark_calc();
28d6: 20,2a               sjmp  2902             goto 2902;
# End HIDRES present
#
# R92 (word) = 2296
#
28d8: 32,a1,16            jnb   B2,Ra1,28f1      if (UNDSP == 1)  {
28db: 39,2d,06            jb    B1,R2d,28e4      if (Undsp_trans == 0)  {
#
# In underspeed, not transitioned
# Fire spark NOW (@ 10 degrees BTDC)
#
28de: 91,08,4c            orb   R4c,8            Immediate = 1;
28e1: ef,d9,fa            call  23bd             Send_HSO_Cmd(); }                 # R92=2296 - SPOUT On
#
# Jump here from:
#  28db (transition into underspeed from run)
#
28e4: 71,fb,2d            an2b  R2d,fb           Dual_edge = 0;                    # Base spark on rising edge of PIP
28e7: a1,00,80,50         ldw   R50,8000         R50 = 8000;                       # Presume 50% PIP duty cycle until we know better
28eb: c3,74,04,50         stw   R50,[R74+4]      Old_beta = R50;
28ef: 20,11               sjmp  2902             goto 2902; }
#
# Jump here from:
#  28d8 (!UNDSP)
#
28f1: 38,4f,0e            jb    B0,R4f,2902      if (Pip_double == 0)  {
#
# Either very high RPM or fuel not in sync
#
28f4: 31,2d,09            jnb   B1,R2d,2900      if (Undsp_trans == 1)  {
#
# Transitioned out of underspeed
#
28f7: 91,08,4c            orb   R4c,8            Immediate = 1;
28fa: ef,fc,fb            call  24f9             Do_CmdN();
28fd: 71,fd,2d            an2b  R2d,fd           Undsp_trans = 0; }
#
# Jump here from:
#  28f4 (!UNDSP && !Pip_double && !Undsp_trans)
#
# Pip_double == 0, so calculate spark from rising edge
#
2900: 29,4a               scall 2a4c             Spark_calc(); } }
#
# Jump here from:
#  28d6 (HIDRES present)
#  28ef (UNDSP)
#  28f1 (!UNDSP && Pip_double, i.e. normal run)
#
2902: b1,ff,50            ldb   R50,ff           R50 = ff;
2905: c7,72,11,50         stb   R50,[R72+11]     Inj_pip = R50;
2909: 91,20,2f            orb   R2f,20           Maf_pip = 1;
290c: a0,7a,52            ldw   R52,R7a          R52 = Event_time;
290f: ef,25,04            call  2d37             MAF_calc();                       # Complete MAF calculations for one cylinder
2912: ef,46,05            call  2e5b             Foreground_Fuel();                # Calculate foreground fuel, injector pulsewidth
2915: ef,b0,06            call  2fc8             Schedule_Injectors();             # Schedule injectors
2918: 20,b3               sjmp  29cd             goto PIP_Inth_Exit;

######## PIP Falling Edge handler ####### 
#
# R50-52 (3 bytes): # of ticks from most recent PIP rising edge to current falling edge
# R54 (word): MNPIP
#
# *** N.B. R52 (high byte of interval) does not appear to be checked anywhere ***
  PIP_Falling_Edge:
291a: 34,2d,0c            jnb   B4,R2d,2929      if (FIRST_PIP == 1)  {
291d: 08,02,54            shrw  R54,2            R54 /= 4;
2920: 88,50,54            cmpw  R54,R50          
2923: d1,04               jleu  2929             if ((uns) R54 > R50)  {
2925: 91,01,90            orb   R90,1            Last_HSI |= 1;                    # Too soon to be valid, clear interrupt and return
2928: f0                  ret                    return; } }
#
# Jump here from:
#  291a (!FIRST_PIP)
#  2923 (plausible high-low interval)
#
2929: a0,ba,58            ldw   R58,Rba          R58 = DT12S;                      # Most recent PIP cycle time (low 16 bits)
292c: 08,01,58            shrw  R58,1            R58 /= 2;                         # half (for equal Hi/Lo)
292f: c3,76,bc,be         stw   Rbe,[R76+bc]     PHFDLT = HFDLTA;
2933: a0,50,be            ldw   Rbe,R50          HFDLTA = R50;                     # PIP hi-lo time delta (Pulsewidth)
2936: 9b,fe,0c,00         cmpb  R0,[Rfe+c]       
293a: d7,62               jne   299e             if (0 == HP_CID)  {               # Skip this if Cyl ID sensor present (not present in A9L)
#
# Part of MKAY/SIGKAL Calculations for signature PIP
# GUFB p. 7-19
#
# R58 (word): DT12S/2 (half most recent PIP high-high cycle time)
# Rbe (word): HFDLTA (current PIP high-low time)
#
293c: 71,fd,eb            an2b  Reb,fd           SIGPIP = 0;
293f: 3a,a1,57            jb    B2,Ra1,2999      if (UNDSP == 1) goto 2999;
2942: 48,be,58,52         sb3w  R52,R58,Rbe      R52 = DT12S/2 - HFDLTA;           # = PIP Hi-Hi time/2 - Pip Hi-lo time
2946: da,48               jle   2990             if (R52 <= 0) goto 2990;          # Jump if duty cycle >= 50% (is not signature PIP)
2948: 01,50               clrw  R50              R50 = 0;
294a: 8c,58,50            divw  R50,R58          R51:R50 = R53:R50 / R59:R58;      # R50 = 65536 * (DT12S/2 - HFDLTA) / DT12S/2
294d: 8b,fe,0e,50         cmpw  R50,[Rfe+e]                                        # MHPFD = Signature PIP duty cycle * 65536
2951: d1,3d               jleu  2990             if ((uns) R50 <= MHPFD) goto 2990;
#
# This is signature PIP
#
2953: 91,02,eb            orb   Reb,2            SIGPIP = 1;                       # This is Cyl 1 - narrow blade/slot
2956: 9b,fc,2a,d1         cmpb  Rd1,[Rfc+2a]     
295a: df,02               je    295e             if (SYNCTR == NUMCYL % 100) goto 295e;
295c: 20,3b               sjmp  2999             goto 2999;                        # not in sync
#
# Signature PIP when expected, we're in sync
# R58 (word): DT12S/2
#
295e: 91,50,2e            orb   R2e,50           SYNC_UP_FUEL = 1;
                                                 SYNFLG = 1;                       # OK - cyl 1 expected do/keep SYNC 
2961: a3,76,c2,52         ldw   R52,[R76+c2]     R52 = SIGDLT;
2965: c3,76,c4,52         stw   R52,[R76+c4]     PSGDLT = R52;
2969: c3,76,c2,be         stw   Rbe,[R76+c2]     SIGDLT = HFDLTA;
296d: a3,76,c0,50         ldw   R50,[R76+c0]     R50 = SIGKAL;
2971: 6c,be,50            ml2w  R50,Rbe          R53:R50 = SIGKAL * HFDLTA;
2974: 8c,c0,50            divw  R50,Rc0          R51:R50 = SIGKAL * HFDLTA / MKAY;
2977: dd,05               jnv   297e             if (OVF == 1)  {
2979: a0,58,be            ldw   Rbe,R58          HFDLTA = R58;                     # Clip HFDLTA to DT12S/2
297c: 20,03               sjmp  2981             goto 2981; }
#
297e: c0,be,50            stw   R50,Rbe          HFDLTA = R50;                     # Store result of calculation
#
# N.B. PIPOUT, NUMCYL are both constants - and are equal in any calibration where OUTINJ == 1 (sequential EFI)
#
2981: a3,fc,2e,50         ldw   R50,[Rfc+2e]     R50 = PIPOUT;
2985: 8b,fc,2a,50         cmpw  R50,[Rfc+2a]
2989: df,03               je    298e             if (PIPOUT != NUMCYL)  {          # # of cylinders x 0x20
298b: 71,ef,2e            an2b  R2e,ef           SYNC_UP_FUEL = 0; }               # *** will never execute on A9L
#
298e: 11,d1               clrb  Rd1              SYNCTR = 0;                       # First cyl in sequence
#
# Jump here from:
#  2946 (duty cycle >= 50%)
#  2951 (not signature PIP)
#
2990: ac,d1,58            ldzbw R58,Rd1          R58 = (uns)SYNCTR;
2993: 8b,fc,2a,58         cmpw  R58,[Rfc+2a]                                       # BEWARE! Comparing SYNCTR (byte) to NUMCYL (word)
2997: d3,05               jltu  299e             if ((uns) SYNCTR >= NUMCYL)  {    # *** Jump always taken on 8 cylinder SEFI calibrations
                                                                                   # ***  because SYNCTR CANNOT be >= 0x100
#
# Not in sync
# Jump here from:
#  293f (UNDSP)
#  295c (SYNCTR != NUMCYL)
#
2999: 11,d1               clrb  Rd1              SYNCTR = 0;
299b: 71,2f,2e            an2b  R2e,2f           SYNC_UP_FUEL = 0;
                                                 SYNFLG = 0;
                                                 FUEL_IN_SYNC = 0; } }             # UNSYNC  
#### end of signature PIP processing
#
# Jump here from:
#  293e (HP_CID != 0)
#  2997 (SYNCTR < NUMCYL)
#
299e: c9,9f,6c            push  6c9f             push(Sub38);                      # knock detection (returns immediately if KIHP == 0)
29a1: c9,c8,2f            push  2fc8             push(Schedule_Injectors);         # Schedule injectors
#
# Stack is:
#  Schedule_Injectors
#  Sub38
#  Return address in Read_HSI
#
29a4: 9b,f8,19,00         cmpb  R0,[Rf8+19]      
29a8: df,01               je    29ab             if (0 != HP_HIDRES)  {            # HDRES not present in A9L
29aa: f0                  ret                    return; }                         # actually call Schedule_Injectors(); call Sub38(); return; if HDRES present
#
# Logic below is for non-HIDRES
#
29ab: a1,9e,22,92         ldw   R92,229e         TPtr = 229e;                      # SPOUT Off command
29af: 32,a1,0d            jnb   B2,Ra1,29bf      if (UNDSP == 1)  {
# Crank or underspeed
29b2: 31,2d,04            jnb   B1,R2d,29b9      if (Undsp_trans == 1)  {          # just entered underspeed from run
#
# Jump here from 29c8 (!UNDSP && Pip_double)
29b5: 71,fd,2d            an2b  R2d,fd           Undsp_trans = 0;                  # Transition acknowledged
29b8: f0                  ret                    return; }                         # actually call Schedule_Injectors(); call Sub38(); return;
#
# Jump here from:
#  29b2 (UNDSP && !Undsp_trans)
#   TPtr = 229e (SPOUT Off cmd)
#  29ca (!UNDSP && !Pip_double && Undsp_trans)
#   TPtr = 229e (SPOUT On cmd)
#
29b9: 91,08,4c            orb   R4c,8            Immediate = 1;
29bc: e7,fe,f9            jump  23bd             goto Send_HSO_Cmd; }              # send HSO command NOW
                                                                                   # then call Schedule_Injectors(); call Sub38(); return;
#
# Jump here from:
#  29af (!UNSPD)
#
# Run mode
29bf: 30,4f,08            jnb   B0,R4f,29ca      if (Pip_double == 1)  {
#
# Run mode and not high RPM
29c2: a1,96,22,92         ldw   R92,2296         TPtr = 2296;                      # SPOUT On command
29c6: 28,84               scall 2a4c             Spark_calc();
29c8: 27,eb               sjmp  29b5             goto 29b5; }                      # Go turn off Undsp_trans and exit
#
# Jump here from 29bf (!Pip_double)
# Run mode and high rpm, or fuel not in sync at last PIP rising edge
29ca: 39,2d,ec            jb    B1,R2d,29b9      if (Undsp_trans == 1) goto 29b9;  # jump if transitioned out of underspeed
#
# Jump here from 2918 (PIP up-edge handler exit)
#
  PIP_Inth_Exit:
29cd: f0                  ret                    return;                           # if we fell through, actually call Schedule_Injectors(); call Sub38(); return;


########################################################
# handle CID (cylinder ident) Interrupt  - sync to cyl no 1
# SYNCTR (byte) is incremented by 32 (->2898) in PIPHi handler, so wraps 
# each 8 sparks.  SYNCTR = 0 for cyl 1. Compares with 9aa8
# are done as byte AND word, so the 256 word value is probably a flag marker
# for newly synched ?  The 128 use may show that CID changes state at cyl 4,
# which would be a state switch for each crank revolution ?
# N.B. Not used in A9L
# *** CALLED IN INTERRUPT HANDLER CONTEXT ***
########################################################

  Cid_inth:
29ce: 71,df,87            an2b  R87,df           Cid_irq = 0;
29d1: 9b,fe,0d,00         cmpb  R0,[Rfe+d]       
29d5: d7,16               jne   29ed             if (0 != HP_CIDSEL) goto 29ed;    # Jump if variable reluctance CID sensor
#
# Hall effect sensor logic
#
29d7: 3d,90,17            jb    B5,R90,29f1      if (B5_Last_HSI == 0)  {
#
# CID High handler
#
# Hall effect sensor only
#
29da: b3,fe,07,50         ldb   R50,[Rfe+7]      R50 = ENGCYL;                     # PIPs/rev * 2
29de: 19,04,50            shlb  R50,4            R50 *= 10;
29e1: 98,50,d1            cmpb  Rd1,R50          
29e4: df,06               je    29ec             if (SYNCTR != ENGCYL * 10)  {
#
# Unsynced
#
29e6: b0,50,d1            ldb   Rd1,R50          SYNCTR = R50;                     # UNSYNC cyls, set SYNCTR to ENGCYL * 10 for next time & return
29e9: 71,2f,2e            an2b  R2e,2f           SYNC_UP_FUEL = 0;
                                                 SYNFLG = 0;
                                                 FUEL_IN_SYNC = 0; }
#
# Jump here from 29e4 (synced)
29ec: f0                  ret                    return;
#
# Jump here from 29d5 (HP_CIDSEL != 0, i.e. variable reluctance CID sensor)
29ed: 35,90,01            jnb   B5,R90,29f1      if (B5_Last_HSI == 1)  {
29f0: f0                  ret                    return; } }
#
# CID Low handler
#
# Common to both types of sensor
#
29f1: b0,d1,50            ldb   R50,Rd1          R50 = SYNCTR;
29f4: 11,d1               clrb  Rd1              SYNCTR = 0;
29f6: 3a,a1,06            jb    B2,Ra1,29ff      if (UNDSP == 1) goto 29ff;        # UNSYNC if underspeed
29f9: 9b,fc,2a,50         cmpb  R50,[Rfc+2a]     
29fd: df,04               je    2a03             if (R50 != NUMCYL % 100)  {       #
29ff: 71,2f,2e            an2b  R2e,2f           SYNC_UP_FUEL = 0;
                                                 SYNFLG = 0;
                                                 FUEL_IN_SYNC = 0;                 # not = 0 so UNSYNC cyls & return
2a02: f0                  ret                    return; }

2a03: 91,50,2e            orb   R2e,50           SYNC_UP_FUEL = 1;
                                                 SYNFLG = 1;                       # OK - SYNC Cyl no 
2a06: a3,fc,2e,50         ldw   R50,[Rfc+2e]     R50 = PIPOUT;                     # 9aac = 256 
2a0a: 8b,fc,2a,50         cmpw  R50,[Rfc+2a]     
2a0e: d7,01               jne   2a11             if (R50 == NUMCYL)  {             # 9aa8 = 256
2a10: f0                  ret                    return; }

2a11: 71,ef,2e            an2b  R2e,ef           SYNC_UP_FUEL = 0;
2a14: f0                  ret                    return;


#######################################################
# Vehicle Speed sensor counts
# handle VSS
# *** CALLED IN HSI INTERRUPT HANDLER CONTEXT ***
#######################################################

  Vss_inth:
2a15: 71,bf,87            an2b  R87,bf           Mph_irq = 0;                      # masked input line data
2a18: 36,90,16            jnb   B6,R90,2a31      if (B6_Last_HSI == 1)  {          # rising edge only, ignore falling edge
2a1b: 17,b2               incb  Rb2              MPHCNT++;                         # count of VSS ring clicks
2a1d: c7,74,3d,00         stb   R0,[R74+3d]      TSLMPH = 0;                       # timer - time since last click
2a21: 3a,c4,05            jb    B2,Rc4,2a29      if (First_mph == 0)  {
2a24: 91,04,c4            orb   Rc4,4            First_mph = 1;                    # set interval start
2a27: 11,b2               clrb  Rb2              MPHCNT = 0; }                     # clear click count
#
2a29: c3,74,40,7a         stw   R7a,[R74+40]     MPHTIM1L = Event_time;
2a2d: c7,74,42,7c         stb   R7c,[R74+42]     MPHTIM1H = Event_timeH; }         # save event time 24 bit 
#
2a31: f0                  ret                    return;


#######################################################
# cyl/spark angle degrees (*4) = 180,120,90
#######################################################

2a32: d0,02               word    2d0           # 4 cylinder
2a34: e0,01               word    1e0           # 6 cylinder
2a36: 68,01               word    168           # 8 cylinder

#######################################################
# Table used by HIDRES spark calculation
#######################################################

2a38: ab,2a               word   2aab           # 4 cyl
2a3a: 00,40               word   4000           # 6 cyl
2a3c: 55,55               word   5555           # 8 cyl


#################################
# start with R50 = pip counter.
# If R50 > KNKCYL, Decrement R50 until it equals KNKCYL
# if R50 < KNKCYL then return unchanged
# Why go to all this trouble with a loop ?
#
# GUFB strategy doc suggests 2 values for KNKCYL: 1, or the # of cylinders.
# If 1, every time this routine is entered, R50 will contain 1 at exit.
# If KNKCYL = no of cyls, R50 will contain the initial R50 - 1;
#  if R50 = 1 at entry, it will wrap around to KNKCYL at exit.
#
# Setting KNKCYL to 4 appears to have been a mistake,
# possibly a copy-paste error from a 4 cylinder engine.
#
# None of this is relevant to A9L, as there is no knock detection hardware.
#################################

  knck4:
2a3e: e0,50,04            djnz  R50,2a45         R50--;                                                             1.0     1.8
                                                 if (R50 != 0) goto 2a45;
2a41: af,f8,48,50         ldzbw R50,[Rf8+48]     R50 = (uns)KNKCYL; }                                               2.2
#
2a45: 9b,f8,48,50         cmpb  R50,[Rf8+48]                                                                        2.2     2.2
2a49: d9,f6               jgtu  2a41             if ((uns) R50 > KNKCYL) goto 2a41;                                 0.8     0.8
2a4b: f0                  ret                    return;                                                            2.4     2.4
                                                                                                                   ----    ----
                                                                                                                    8.6 typ 7.2 min


#################################
# Calculate spark advance
# Handle knock retard, tip-in retard
#
# Called from PIP rising edge handler if Pip_double == 0
# (i.e. crank, underspeed, fuel not in sync, or very high RPM)
# or equipped with HIDRES and in underspeed
#
# Called from PIP falling edge handler if Pip_double == 1
# (i.e. normal run mode)
#################################

  Spark_calc:
#
# Knock retard logic
# GUFB p. 7-40
#
2a4c: ac,dc,50            ldzbw R50,Rdc          R50 = (uns)Pip_counter;
2a4f: 36,4f,21            jnb   B6,R4f,2a73      if (KNOCK_ENABLED == 1)  {        # always 0 in A9L
2a52: 37,4f,1e            jnb   B7,R4f,2a73      if (KNOCK_OCCURRED == 1)  {
2a55: 98,e1,00            cmpb  R0,Re1           
2a58: d7,19               jne   2a73             if (0 == TIPRET)  {
2a5a: b3,51,2b,02,52      ldb   R52,[R50+22b]    R52 = [R50+SPKADn];               # SparkAdvance[ cyl 1 -8 ]
2a5f: 78,e2,52            sb2b  R52,Re2          R52 -= RETINC;
2a62: dd,06               jv    2a6a             if (OVF == 1) goto 2a6a;
2a64: 9b,f8,30,52         cmpb  R52,[Rf8+30]                                       # Max degrees retard
2a68: d6,04               jge   2a6e             if (R52 < RETLIM)  {              # Clip to RETLIM
# Jump here from 2a62 (arithmetic overflow)
2a6a: b3,f8,30,52         ldb   R52,[Rf8+30]     R52 = RETLIM; }
# Jump here from 2a68 (R52 >= RETLIM)
2a6e: c7,51,2b,02,52      stb   R52,[R50+22b]    [R50+SPKADn] = R52; } } }         # SparkAdvance[ cyl 1 -8 ]
#
# Jump here from 2a4f (!KNOCK_ENABLED), 2a52 (!KNOCK_OCCURRED), 2a58 (TIPRET != 0)
2a73: 2f,c9               scall 2a3e             knck4();
2a75: c4,dc,50            stb   R50,Rdc          Pip_counter = R50;                # Only place Pip_counter is assigned
#
# Tip-In Spark Logic
# GUFB p. 7-42 (bottom)
# R50 = Pip_counter
#
2a78: 36,4f,0c            jnb   B6,R4f,2a87      if (KNOCK_ENABLED == 0) goto 2a87; # always 0 in A9L 
2a7b: 37,4f,09            jnb   B7,R4f,2a87      if (KNOCK_OCCURRED == 0) goto 2a87;
2a7e: b3,f8,48,54         ldb   R54,[Rf8+48]     R54 = KNKCYL;
2a82: 99,01,54            cmpb  R54,1            
2a85: d7,03               jne   2a8a             if (KNKCYL != 1) goto 2a8a;
# Jump here from 2a78 (!KNOCK_ENABLED), 2a7b (!KNOCK_OCCURRED)
2a87: 35,2d,12            jnb   B5,R2d,2a9c      if (CTFLG == 1)  {                # set when throttle closed and LOAD < TIPLOD;
                                                                                   # cleared when LOAD > TIPLOD + TIPHYS
# Jump here from 2a85 (KNKCYL != 1)
2a8a: 98,00,e1            cmpb  Re1,R0           
2a8d: d7,0d               jne   2a9c             if (TIPRET == 0)  {
#
# No tip-in retard in progress, check whether it's needed
2a8f: 36,2d,0a            jnb   B6,R2d,2a9c      if (TIPFLG == 1)  {               # N.B. TIPFLG will always be 0 in A9L
                                                                                   # because NTIP is 0
#
# New tip-in is occurring
#
2a92: b3,f8,32,e1         ldb   Re1,[Rf8+32]     TIPRET = TIPMAX;                  # tip in retard max = 0 in A9L
2a96: c3,74,ac,aa         stw   Raa,[R74+ac]     TBART = TP;                       # Update smoothed throttle position
2a9a: 20,11               sjmp  2aad             goto 2aad; } } }
#
# Possibly working off a previous tip-in retard
# Jump here from 2a87, 2a8d, 2a8f
2a9c: b0,e1,52            ldb   R52,Re1          R52 = TIPRET;
2a9f: 77,f8,33,52         ad2b  R52,[Rf8+33]     R52 += TIPINC;                    # (degrees)
2aa3: da,02               jle   2aa7             if (R52 > 0)  {
2aa5: 11,52               clrb  R52              R52 = 0; }                        # clip to 0 if positive
#
2aa7: c4,e1,52            stb   R52,Re1          TIPRET = R52;
2aaa: 36,4f,15            jnb   B6,R4f,2ac2      if (KNOCK_ENABLED == 1)  {        # always 0 in A9L
#
2aad: 2f,8f               scall 2a3e             knck4();
2aaf: 9b,f8,19,00         cmpb  R0,[Rf8+19]      
2ab3: df,02               je    2ab7             if (0 != HP_HIDRES)  {            # HDRES not present on A9L
2ab5: 2f,87               scall 2a3e             knck4(); }
#
2ab7: 57,51,2b,02,e1,52   ad3b  R52,Re1,[R50+22b] R52 = TIPRET + [R50+SPKADn];     # Add tip-in retard and knock detect retard
2abd: d5,03               jnv   2ac2             if (OVF == 1) {
2abf: b1,80,52            ldb   R52,80           R52 = 80; } }                     # Clip to min (-32 degrees) on overflow
#
# Jump here from 2aaa (!KNOCK_ENABLED)
# R52 = tip-in and/or knock detect adjustment, 1/4 degree
2ac2: 16,52               sexb  R52              R52 = (int)R52;
2ac4: 44,c2,52,54         ad3w  R54,R52,Rc2      R54 = R52 + SAF;
2ac8: c3,74,1c,54         stw   R54,[R74+1c]     SAFTOT = R54;
2acc: bf,f8,0c,52         ldsbw R52,[Rf8+c]      R52 = (int)SPLCLP;                # Lower limit spark clip
2ad0: 88,52,54            cmpw  R54,R52          
2ad3: d6,05               jge   2ada             if (R54 < R52)  {
2ad5: a0,52,54            ldw   R54,R52          R54 = R52;
2ad8: 20,0c               sjmp  2ae6             goto 2ae6; }
#
2ada: af,f8,0d,52         ldzbw R52,[Rf8+d]      R52 = (uns)SPUCLP;                # Upper limit spark clip
2ade: 88,52,54            cmpw  R54,R52          
2ae1: da,03               jle   2ae6             if ((uns) R54 < R52)  {
2ae3: a0,52,54            ldw   R54,R52          R54 = R52; }
#
2ae6: 9b,f8,19,00         cmpb  R0,[Rf8+19]      
2aea: df,62               je    2b4e             if (0 != HP_HIDRES)  {            # HDRES not present on A9L
#
# Only for HIDRES equipped cars
2aec: fe,6d,c0,ff,54      sml2w R54,ffc0         R57:R54 = R55:R54 * 0x-40;
2af1: 11,52               clrb  R52              R52 = 0;
2af3: 37,57,09            jnb   B7,R57,2aff      if (R57 < 0)  {
2af6: 17,52               incb  R52              R52++;
2af8: 03,54               negw  R54              R54 = -R54;
2afa: a4,00,56            adcw  R56,R0           R56 += CY;
2afd: 02,56               cplw  R56              R56 = ~R56; }
#
2aff: 8d,0a,00,54         divw  R54,a            R55:R54 = R57:R54 / 0xa;
2b03: 30,52,02            jnb   B0,R52,2b08      if (B0_R52 == 1)  {
2b06: 03,54               negw  R54              R54 = -R54; }
#
2b08: 65,04,06,54         ad2w  R54,604          R54 += 604;
2b0c: 89,44,00,54         cmpw  R54,44           
2b10: db,06               jgeu  2b18             if (R54 > 44)  {                  # Clip to 0x44
2b12: a1,44,00,54         ldw   R54,44           R54 = 44;
2b16: 20,0a               sjmp  2b22             goto 2b22; }
#
2b18: 89,04,07,54         cmpw  R54,704          
2b1c: d1,04               jleu  2b22             if ((uns) R54 > 704 )  {
2b1e: a1,04,07,54         ldw   R54,704          R54 = LTMTB100; }
#
2b22: c3,74,1e,54         stw   R54,[R74+1e]     SAPW = R54;                       # Spark Angle Pulse Width, msec.
2b26: 6d,ab,6a,54         ml2w  R54,6aab         R57:R54 = R55:R54 * 0x6aab;
2b2a: 75,80,55            ad2b  R55,80           R55 += 80;
2b2d: a4,00,56            adcw  R56,R0           R56 += CY;
2b30: c3,74,ca,56         stw   R56,[R74+ca]     Spout_low_time = R56;
2b34: af,fe,07,50         ldzbw R50,[Rfe+7]      R50 = (uns)ENGCYL;                # no of PIPs/rev x 2
2b38: a3,51,34,2a,50      ldw   R50,[R50+2a34]   R50 = [R50+2a34];
2b3d: 6c,ba,50            ml2w  R50,Rba          R53:R50 = R51:R50 * DT12S;        # PIP time lo 16 bits
2b40: a3,74,50,54         ldw   R54,[R74+50]     R54 = Prev_PIP_time;
2b44: b3,74,52,56         ldb   R56,[R74+52]     R56 = Prev_PIP_timeH;
2b48: 91,04,28            orb   R28,4            Newsa = 1;
2b4b: e7,e6,00            jump  2c34             goto 2c34; }
# End HIDRES only
#
# Non HIDRES jumps to here from 0x2AEA
#
# R54 (word) = total spark advance, units 1/4 degree
#
2b4e: af,fe,07,56         ldzbw R56,[Rfe+7]      R56 = (uns)ENGCYL;                # no of PIPs/rev x 2
2b52: a3,57,2e,2a,56      ldw   R56,[R56+2a2e]   R56 = [R56+2a2e];                 # degrees between PIPs (x4)
2b57: 45,28,00,56,52      ad3w  R52,R56,28       R52 = R56 + 28;                   # + 10 degrees BTDC base timing
2b5c: 68,54,52            sb2w  R52,R54          R52 -= R54;                       # subtract total advance to get
                                                                                   #  degrees between PIP high and next SPOUT
2b5f: 01,50               clrw  R50              R50 = 0;
2b61: 09,01,56            shlw  R56,1            R56 *= 2;
2b64: 8c,56,50            divw  R50,R56          R51:R50 = R53:R50 / R57:R56;      # R50 (word) = advance as fraction of PIP interval (x 32768)
2b67: d5,06               jnv   2b6f             if (OVF == 1)  {
2b69: a3,74,04,58         ldw   R58,[R74+4]      R58 = Old_beta;                   # Reuse old beta on overflow
2b6d: 20,17               sjmp  2b86             goto 2b86; }
#
2b6f: c0,58,50            stw   R50,R58          R58 = R50;
2b72: a3,74,04,50         ldw   R50,[R74+4]      R50 = Old_beta;
2b76: 6b,f8,46,50         sb2w  R50,[Rf8+46]     R50 -= SPKLIM;                    # Max allowed advance in spark timing between spout outputs
2b7a: 88,58,50            cmpw  R50,R58          
2b7d: d1,03               jleu  2b82             if ((uns) R50 > R58 )  {
2b7f: a0,50,58            ldw   R58,R50          R58 = R50; }
#
2b82: c3,74,04,58         stw   R58,[R74+4]      Old_beta = R58;
#
# Jump here from:
#  2b6d (division overflow)
#
2b86: 38,4f,0e            jb    B0,R4f,2b97      if (Pip_double == 0)  {
2b89: 4c,58,ba,50         ml3w  R50,Rba,R58      R53:R50 = DT12S * Old_beta;       # PIP time lo 16 bits
2b8d: a3,74,50,54         ldw   R54,[R74+50]     R54 = Prev_PIP_time;
2b91: b3,74,52,56         ldb   R56,[R74+52]     R56 = Prev_PIP_timeH;
2b95: 20,6a               sjmp  2c01             goto 2c01; }
#
# Jump here from:
#  2b86 (Pip_double == 1)
#
# Transient spark compensation logic
# GUFB pp. 7-28
#
# R58 (word) = beta (advance as fraction of PIP interval)
#
2b97: 49,00,40,58,50      sb3w  R50,R58,4000     R50 = R58 - 4000;
2b9c: 09,01,50            shlw  R50,1            R50 *= 2;
2b9f: b3,76,be,52         ldb   R52,[R76+be]     R52 = TL0FLG;
2ba3: 37,52,36            jnb   B7,R52,2bdc      if (B7_R52 == 0) goto 2bdc;
2ba6: a3,fe,10,52         ldw   R52,[Rfe+10]     R52 = TRSRPM;                     # Min RPM to enable transient spark routine
2baa: 88,52,ae            cmpw  Rae,R52          
2bad: d9,11               jgtu  2bc0             if ((uns) N > TRSRPM) goto 2bc0;
2baf: 6b,fe,12,52         sb2w  R52,[Rfe+12]     R52 -= TRSRPH;                    # Hysteresis for TRSRPM
2bb3: d3,08               jltu  2bbd             if ((uns) R52 >= 0)  {
2bb5: 88,52,ae            cmpw  Rae,R52          
2bb8: db,03               jgeu  2bbd             if ((uns) N < TRSRPM - TRSRPH)  {
2bba: 71,ef,26            an2b  R26,ef           Trsprpml = 0; } }
#
2bbd: 34,26,1c            jnb   B4,R26,2bdc      if (Trsprpml == 0) goto 2bdc;     # Use MKAY
#
2bc0: 91,10,26            orb   R26,10           Trsprpml = 1;                     # Use transient spark calculation
2bc3: a3,76,bc,54         ldw   R54,[R76+bc]     R54 = PHFDLT;
2bc7: 6c,c0,54            ml2w  R54,Rc0          R57:R54 = PHFDLT * MKAY;
2bca: 0d,01,54            shldw R54,1            R57:R54 *= 2;                     # Correct scale
2bcd: 48,56,ba,56         sb3w  R56,Rba,R56      R56 = DT12S - (PHFDLT * MKAY);
2bd1: 01,54               clrw  R54              R54 = 0;
2bd3: 0c,01,54            shrdw R54,1            R57:R54 /= 2;
2bd6: 8f,76,bc,54         divw  R54,[R76+bc]     R55:R54 = R57:R54 / PHFDLT;
2bda: d5,03               jnv   2bdf             if (OVF == 1)  {
#
2bdc: a0,c0,54            ldw   R54,Rc0          R54 = MKAY; }                     # Clip result to MKAY
#
# R50 (word): (beta - 0x4000) * 2
# R54 (word): (DT12S - PHFDLT * MKAY) / PHFDLT or MKAY
#
2bdf: 6c,54,50            ml2w  R50,R54          R53:R50 = R51:R50 * R55:R54;
2be2: a0,c0,50            ldw   R50,Rc0          R50 = MKAY;
2be5: 08,01,50            shrw  R50,1            R50 /= 2;
2be8: 64,50,52            ad2w  R52,R50          R52 += R50;
2beb: 69,00,40,52         sb2w  R52,4000         R52 -= 4000;
2bef: 09,01,52            shlw  R52,1            R52 *= 2;
2bf2: 4c,be,52,50         ml3w  R50,R52,Rbe      R53:R50 = R53:R52 * HFDLTA;
2bf6: 11,56               clrb  R56              R56 = 0;
2bf8: 47,74,50,be,54      ad3w  R54,Rbe,[R74+50] R54 = HFDLTA + Prev_PIP_time;
2bfd: b7,74,52,56         adcb  R56,[R74+52]     R56 += Prev_PIP_timeH + CY;
#
# Jump here from 0x2b95 (Pip_double == 0)
2c01: 0d,01,50            shldw R50,1            R53:R50 *= 2;
2c04: 75,80,51            ad2b  R51,80           R51 += 80;                        # Round result in R52
2c07: a4,00,52            adcw  R52,R0           R52 += CY;
2c0a: 91,04,28            orb   R28,4            Newsa = 1;
#
# Rising/Falling Edge Timing Decision
# GUFB p. 7-21
# R52 (word) = Available time to desired SPOUT (ticks)
# Rba (word) = DT12S = most recent PIP-PIP interval (ticks)
#
2c0d: 32,2d,11            jnb   B2,R2d,2c21      if (Dual_edge == 1)  {
#
# Currently in Falling-Edge mode
2c10: 89,a1,01,52         cmpw  R52,1a1                                            # TICKS_SINGLE: 0x1a1 = 417 ticks x 2.4 us = 1 ms
2c14: d3,06               jltu  2c1c             if ((uns) R52 < TICKS_SINGLE) goto 2c1c; # Not enough time, switch to Rising-Edge
2c16: 8b,f8,16,ba         cmpw  Rba,[Rf8+16]     
2c1a: db,03               jgeu  2c1f             if (DT12S < SPKSWH)  {            # Check RPM threshold (= 7972 RPM)
#
# Jump here from:
#  2c14 (not enough time left for Falling-Edge)
#
2c1c: 71,fb,2d            an2b  R2d,fb           Dual_edge = 0; }                  # Switch to Rising-Edge mode
#
2c1f: 20,13               sjmp  2c34             goto 2c34; }
#
# Jump here from:
#  2c0d (!Dual_edge)
#
# Currently in Rising-Edge mode
#
2c21: 48,be,52,50         sb3w  R50,R52,Rbe      R50 = R52 - HFDLTA;
2c25: 89,f4,01,50         cmpw  R50,1f4                                            # TICKS_DOUBLE: 0x1f4 = 500 ticks x 2.4 us = 1.2 ms
2c29: da,09               jle   2c34             if ((uns) R50 < TICKS_DOUBLE) {
2c2b: 8b,f8,14,ba         cmpw  Rba,[Rf8+14]     
2c2f: d1,03               jleu  2c34             if ((uns) DT12S > SPKSWL) {       # SPKSWL: 0x310 = 784 ticks x 2.4 us = 1.8816 ms = 7972 RPM!
2c31: 91,04,2d            orb   R2d,4            Dual_edge = 1; } }                # Switch to Falling-Edge mode
#
# Jump here from:
#  2c1f (was in Falling-Edge mode, may still be)
#  2c29 (in Rising-Edge, not enough time left to switch)
#  2c2f (in Rising-Edge, RPM too high to switch)
#
2c34: c3,74,5c,52         stw   R52,[R74+5c]     Next_spout_beta = R52;            # 27E+5C=02DA = 2C5 -15 right in the middle of our Table
2c38: 28,34               scall 2c6e             Upd_Htime_Prev();
2c3a: a1,c8,02,7e         ldw   R7e,2c8          Rtab = Q0;
2c3e: 9b,7e,01,00         cmpb  R0,[R7e+1]       
2c42: d6,19               jge   2c5d             if (0 < [Rtab+1])  {
2c44: 91,01,2d            orb   R2d,1            Spout_pending = 1;
2c47: 4b,7e,02,80,50      sb3w  R50,R80,[R7e+2]  R50 = HSO_time - [Rtab+2];
2c4c: 37,51,0d            jnb   B7,R51,2c5c      if (B7_R51 == 0) return;
2c4f: 91,08,4c            orb   R4c,8            Immediate = 1;
2c52: af,7e,01,92         ldzbw R92,[R7e+1]      TPtr = (uns)[Rtab+1];             # odd 2284 Table offset
2c56: 65,84,22,92         ad2w  R92,2284         TPtr += HSOTable;
2c5a: ca,92               push  [R92]            push([TPtr]); }                   # jump with existing return
#
2c5c: f0                  ret                    return; }
#
# Jump here from 2c42
2c5d: ef,99,f8            call  24f9             Do_CmdN();
2c60: f0                  ret                    return;

#
#
# Returns with carry flag cleared
#
  upd_Htime_pend:
2c61: 38,2d,07            jb    B0,R2d,2c6b      if (Spout_pending == 0)  {

# 22a0 proc - save zero flag in 2C5 entry or add PIP & ? time to R80/81/82
2c64: c7,7e,01,00         stb   R0,[R7e+1]       [Rtab+1] = 0;
2c68: cc,00               pop   R0               R0 = pop();                       # *** throw away return address ***
2c6a: f0                  ret                    return; }                         # *** return to next address on the stack ***
#
2c6b: 71,fe,2d            an2b  R2d,fe           Spout_pending = 0;

  Upd_Htime_Prev:
2c6e: a3,74,50,80         ldw   R80,[R74+50]     HSO_time = Prev_PIP_time;
2c72: b3,74,52,82         ldb   R82,[R74+52]     HSO_timeH = Prev_PIP_timeH;
2c76: 67,74,5c,80         ad2w  R80,[R74+5c]     HSO_time += Next_spout_beta;
2c7a: b4,00,82            adcb  R82,R0           HSO_timeH += CY;
2c7d: 30,4f,0f            jnb   B0,R4f,2c8f      if (Pip_double == 1)  {
2c80: 64,be,80            ad2w  R80,Rbe          HSO_time += HFDLTA;
2c83: b4,00,82            adcb  R82,R0           HSO_timeH += CY;
2c86: 20,07               sjmp  2c8f             goto 2c8f;

#
# Add Spout_Low_time to current value of HSO_time
# Return with carry flag cleared
#
  Add_SpoutLo:
2c88: 67,74,ca,80         ad2w  R80,[R74+ca]     HSO_time += Spout_low_time;       # 2284 entry proc 
2c8c: b4,00,82            adcb  R82,R0           HSO_timeH += CY; }
#
2c8f: f8                  clc                    CY = 0
2c90: f0                  ret                    return;


  Calc_dwell:
2c91: 9b,f8,1a,00         cmpb  R0,[Rf8+1a]                                        # 0 = TFI Controlled Dwell (used by A9L)
2c95: d7,05               jne   2c9c             if (0 == CCDSW)  {                # 
2c97: a0,be,52            ldw   R52,Rbe          R52 = HFDLTA;
2c9a: 20,80               sjmp  2d1c             goto 2d1c; }
#
# Dwell calculation for Computer Controlled Dwell (not used on A9L)
#
2c9c: 4d,44,28,ba,54      ml3w  R54,Rba,2844     R57:R54 = DT12S * 0x2844;
2ca1: a0,56,58            ldw   R58,R56          R58 = R56;
2ca4: 8b,74,c6,56         cmpw  R56,[R74+c6]     
2ca8: d3,22               jltu  2ccc             if ((uns) R56 >= Ppereng)  {
2caa: a3,f8,20,50         ldw   R50,[Rf8+20]     R50 = PACSLO;                     # Slope for PIP acceleration
2cae: 6c,56,50            ml2w  R50,R56          R53:R50 = R51:R50 * R57:R56;
2cb1: 0c,04,50            shrdw R50,4            R53:R50 /= 10;
2cb4: 88,52,00            cmpw  R0,R52           
2cb7: d7,0f               jne   2cc8             if (0 != R52) goto 2cc8;
2cb9: 4b,74,c8,50,58      sb3w  R58,R50,[R74+c8] R58 = R50 - Poffeng;
2cbe: db,02               jc    2cc2             if (R58 > 0)  {
2cc0: 01,58               clrw  R58              R58 = 0; }
#
2cc2: 8b,f8,22,58         cmpw  R58,[Rf8+22]     
2cc6: d1,04               jleu  2ccc             if ((uns) R58 > PACLIM )  {
# 
2cc8: a3,f8,22,58         ldw   R58,[Rf8+22]     R58 = PACLIM; } }                 # Limit of PIP acceleration
# jump here from 2ca8, 2cc6
2ccc: c3,74,ba,58         stw   R58,[R74+ba]     PIPACL = R58;
2cd0: a1,00,80,50         ldw   R50,8000         R50 = 8000;
2cd4: 6b,f8,24,50         sb2w  R50,[Rf8+24]     R50 -= SPTADV;
2cd8: 68,58,50            sb2w  R50,R58          R50 -= R58;
2cdb: 6c,ba,50            ml2w  R50,Rba          R53:R50 = R51:R50 * DT12S;
2cde: 0d,01,50            shldw R50,1            R53:R50 *= 2;
2ce1: 6b,74,bc,52         sb2w  R52,[R74+bc]     R52 -= Dwlbst;
2ce5: db,02               jc    2ce9             if (R52 > 0)  {
2ce7: 01,52               clrw  R52              R52 = 0; }
#
2ce9: a0,52,58            ldw   R58,R52          R58 = R52;
2cec: 01,50               clrw  R50              R50 = 0;
2cee: 8c,ba,50            divw  R50,Rba          R51:R50 = R53:R50 / DT12S;
2cf1: d5,03               jnv   2cf6             if (OVF == 1)  {
2cf3: bd,ff,50            ldsbw R50,ff           R50 = 0xffff; }
#
2cf6: a0,50,54            ldw   R54,R50          R54 = R50;
2cf9: 8b,f8,2c,56         cmpw  R56,[Rf8+2c]                                       # Dwell Switch point
2cfd: d1,0d               jleu  2d0c             if ((uns) R56 <= dwLTSW) goto 2d0c;
2cff: a3,f8,26,50         ldw   R50,[Rf8+26]     R50 = Lowdwell;                   # max low speed dwell
2d03: 6c,ba,50            ml2w  R50,Rba          R53:R50 = R51:R50 * DT12S;
2d06: 8b,f8,26,54         cmpw  R54,[Rf8+26]     
2d0a: d1,10               jleu  2d1c             if ((uns) R54 > Lowdwell )  {
#
2d0c: a3,f8,28,50         ldw   R50,[Rf8+28]     R50 = Hidwell;                    # max high speed dwell
2d10: 6c,ba,50            ml2w  R50,Rba          R53:R50 = R51:R50 * DT12S;
2d13: 8b,f8,28,54         cmpw  R54,[Rf8+28]     
2d17: d1,03               jleu  2d1c             if ((uns) R54 > Hidwell )  {
2d19: a0,58,52            ldw   R52,R58          R52 = R58; } }
#
# end Computer Controlled Dwell calculation
#
# Jump here from 2c9a (CCDSW == 0)
# R52 (word) = SPOUT low time, ticks
# 
2d1c: c3,74,ca,52         stw   R52,[R74+ca]     Spout_low_time = R52;             # Used by SPOUT HSO handler - see Add_SpoutLo
2d20: 48,52,ba,52         sb3w  R52,Rba,R52      R52 = DT12S - R52;
2d24: c3,74,be,52         stw   R52,[R74+be]     Dwell = DT12S - Spout_low_time;   # Used by SPOUT HSO handler - see Upd_Htime_Prev
2d28: f0                  ret                    return;

################################################################
#
# Entry point from 1 ms timer interrupt handler
# R52 = time of last timer interrupt
#
# A/D command to read MAF was issued long before this call
#
  MAF_rd_calc:
2d29: 33,0a,fd            jnb   B3,Ra,2d29       if (AD_Ready == 0) goto 2d29;     # spin wait for A/D conversion complete
2d2c: 51,f0,04,54         an3b  R54,R4,f0        R54 = AD_Low & f0;                # mask off low bits (channel #)
2d30: b0,05,55            ldb   R55,R5           R55 = AD_High;
2d33: c3,72,a4,54         stw   R54,[R72+a4]     IMAF = R54;                       # save Raw MAF A/D reading
                                                                                   # and fall through
#
# Entry point from PIP high interrupt handler
# MAF has already been read and stored into IMAF
#
# R52 = time of event that provoked this call
#
  MAF_calc:
2d37: 4b,76,ae,52,50      sb3w  R50,R52,[R76+ae] R50 = R52 - MAF_TIME;
2d3c: c3,76,ae,52         stw   R52,[R76+ae]     MAF_TIME = R52;
2d40: c3,76,b8,50         stw   R50,[R76+b8]     INTM = R50;
2d44: ef,80,00            call  2dc7             Integrate_MAF();                  # MAF calibrate/lookup 
2d47: 35,2f,7c            jnb   B5,R2f,2dc6      if (Maf_pip == 0) return;         # Return if 1ms timer interrupt
#
# Finalize MAF input for 1 cylinder
# GUFB pp. 19-17, 19-18
#
2d4a: c3,76,36,00         stw   R0,[R76+36]      AMINT_L = 0;                      # Clear integrator low bits
2d4e: a3,76,b0,50         ldw   R50,[R76+b0]     R50 = AMINT;
2d52: c3,76,b6,50         stw   R50,[R76+b6]     RAWAIRCHG = R50;
2d56: af,76,39,52         ldzbw R52,[R76+39]     R52 = (uns)ARCHCOR;               # 0x80 = 1.00
2d5a: 6c,52,50            ml2w  R50,R52          R53:R50 = R51:R50 * R52;
2d5d: 0c,07,50            shrdw R50,7            R53:R50 /= 80;                    # rescale for ARCHCOR
2d60: 67,74,d6,50         ad2w  R50,[R74+d6]     R50 += ARCHLI;                    # R50 <- RAWAIRCHG * ARCHCOR + ARCHLI
2d64: db,06               jc    2d6c             if (unsigned overflow) goto 2d6c;
2d66: 8b,76,2c,50         cmpw  R50,[R76+2c]     
2d6a: d1,04               jleu  2d70             if ((uns) R50 > AIR37 )  {
#
2d6c: a3,76,2c,50         ldw   R50,[R76+2c]     R50 = AIR37; }                    # clip result to AIR37
#
2d70: c3,74,d8,50         stw   R50,[R74+d8]     ARCHI = R50;                      # Save instantaneous air charge
2d74: a0,50,54            ldw   R54,R50          R54 = R50;
2d77: 31,26,44            jnb   B1,R26,2dbe      if (Archflg == 1)  {
#
# Manifold filling model
# GUFB pp. 19-20 - 19-22
# R50 (word) = ARCHI
# R54 (word) = ARCHI
#
2d7a: 01,52               clrw  R52              R52 = 0;
2d7c: 0d,08,50            shldw R50,8            R53:R50 *= 100;                   # Scale ARCHI for division
2d7f: a3,74,da,58         ldw   R58,[R74+da]     R58 = ARCHFG;                     # Value of ARCHFG from previous PIP
2d83: 8c,58,50            divw  R50,R58          R51:R50 = R53:R50 / R58:R59;      # If steady, result should be 0x100 
2d86: dd,0a               jv    2d92             if (OVF == 1) goto 2d92;          # Must be fast fill!
2d88: a3,f6,02,52         ldw   R52,[Rf6+2]      R52 = FKARCH;                     # Manifold filling - slow filter
2d8c: 8b,f6,06,50         cmpw  R50,[Rf6+6]                                        # Fraction - slow vs fast filter
2d90: d1,04               jleu  2d96             if ((uns) R50 > FILFRC)  {
#
2d92: a3,f6,04,52         ldw   R52,[Rf6+4]      R52 = FKARC1; }                   # Manifold filling - fast filter
#
2d96: 11,5a               clrb  R5a              R5a = 0;
2d98: 68,58,54            sb2w  R54,R58          R54 -= R58;                       # R54 <- AMINT - ARCHFG
2d9b: db,04               jgeu  2da1             if (R54 < 0)  {                   
2d9d: 17,5a               incb  R5a              R5a++;                            # Manifold NOT filling
2d9f: 03,54               negw  R54              R54 = -R54; }                     # Take absolute value
# Is airflow steady state?
2da1: 89,01,00,54         cmpw  R54,1            
2da5: d9,05               jgtu  2dac             if ((uns) R54 <= 1)  {
2da7: a0,58,50            ldw   R50,R58          R50 = R58;                        # R50 <- ARCHFG, close enough
2daa: 20,12               sjmp  2dbe             goto 2dbe; }
#
# Use manifold filling model
2dac: 6c,52,54            ml2w  R54,R52          R57:R54 = R55:R54 * R53:R52;      # R56 <- |AMINT-ARCHFG| * filter constant
2daf: 03,56               negw  R56              R56 = -R56;                       # Flip sign (delta is now negative)
2db1: d7,02               jne   2db5             if (R56 == 0)  {                  # If 0, set to -1 (??)
2db3: 05,56               decw  R56              R56--; }
#
2db5: 38,5a,02            jb    B0,R5a,2dba      if (B0_R5a == 0)  {               # If manifold filling, 
2db8: 03,56               negw  R56              R56 = -R56; }                     #  flip sign back to positive
#
2dba: 44,58,56,50         ad3w  R50,R56,R58      R50 = R56 + R58; }                # R50 <- delta + ARCHFG
#
# Jump here from 2d77 if Archflg == 0
2dbe: c3,74,da,50         stw   R50,[R74+da]     ARCHFG = R50;                     # Store foreground air charge
2dc2: c3,76,b0,00         stw   R0,[R76+b0]      AMINT = 0; }                      # and clear integrator
#
2dc6: f0                  ret                    return;


################################################################
#
# Air Charge Calculations 
# GUFB p. 19-18
# Inputs:
#  IMAF - raw MAF voltage A/D
#  IVCAL - reference voltage A/D (2.5V)
#  INTM - interval since last MAF reading, in IO ticks
#  AMINT, AMINT_L - 32 bit running total air mass
#  MAF - last instantaneous airflow rate
# Outputs:
#  VMAF - result of scaling 
#  AMINT, AMINT_L - 32 bit running total air mass
#  MAF - instantaneous airflow rate corresponding to VMAF
#
  Integrate_MAF:
2dc7: a3,72,a4,50         ldw   R50,[R72+a4]     R50 = IMAF;                       # raw A/D count * 2^6
2dcb: 6d,00,28,50         ml2w  R50,2800         R53:R50 = R51:R50 * 2800;         # VCAL (= 10240 dec = 2^10 * 10)
                                                                                   # R53:R50 = raw A/D count x 10 * 2^16
2dcf: 8f,72,90,50         divw  R50,[R72+90]     R51:R50 = R53:R50 / IVCAL;        # Scale via Batt Ref Voltage (nom. 2.5V = 0x8000 = 2^15)
                                                                                   # R50 = raw A/D count x 20 (nom.)
                                                                                   # Full scale (5V) = 1024 * 20 = 20480
                                                                                   # -> VMAF = R50/4096
2dd3: d5,03               jnv   2dd8             if (OVF == 1)  {
2dd5: bd,ff,50            ldsbw R50,ff           R50 = 0xffff; }                  # clamp max MAF voltage
#
2dd8: c3,74,d0,50         stw   R50,[R74+d0]     VMAF = R50;                       # save value
#
# MAF transfer table lookup
# R50 = VMAF
#
2ddc: a3,76,b4,52         ldw   R52,[R76+b4]     R52 = Maf_ptr;                    # MAF transfer function pointer
                                                                                   # Initialized to top end of FN036 table
2de0: 8a,52,50            cmpw  R50,[R52]                                          # Table max MAF voltage
2de3: d7,06               jne   2deb             if (R50 == [R52])  {
2de5: a3,52,02,54         ldw   R54,[R52+2]      R54 = [R52+2];                    # exact match
2de9: 20,36               sjmp  2e21             goto 2e21; }
#
2deb: d3,0b               jltu  2df8             if ((uns) R50 >= [R52])  {
2ded: 69,04,00,52         sb2w  R52,4            R52 -= 4;                         # back up in MAF transfer function Table to the right value
2df1: 8a,52,50            cmpw  R50,[R52]        
2df4: d9,f7               jgtu  2ded             if ((uns) R50 > [R52] ) goto 2ded; # loop
2df6: 20,0d               sjmp  2e05             goto 2e05; }

2df8: 65,04,00,52         ad2w  R52,4            R52 += 4;                         # jmp ahead in the MAF transfer function to the right value
2dfc: 8a,52,50            cmpw  R50,[R52]        
2dff: d3,f7               jltu  2df8             if ((uns) R50 < [R52]) goto 2df8; # loop
2e01: 69,04,00,52         sb2w  R52,4            R52 -= 4;
#
# 
2e05: a2,53,58            ldw   R58,[R52++]      R58 = [R52++];                    # interpolate larger MAF
2e08: a2,53,54            ldw   R54,[R52++]      R54 = [R52++];                    # larger air flow
2e0b: 6a,52,58            sb2w  R58,[R52]        R58 -= [R52];                     # MAF difference
2e0e: 6a,53,50            sb2w  R50,[R52++]      R50 -= [R52++];                   # MAF delta to interpolate
2e11: 6a,52,54            sb2w  R54,[R52]        R54 -= [R52];                     # air flow difference
2e14: 6c,50,54            ml2w  R54,R50          R57:R54 = R55:R54 * R51:R50;
2e17: 8c,58,54            divw  R54,R58          R55:R54 = R57:R54 / R59:R58;
2e1a: 66,53,54            ad2w  R54,[R52++]      R54 += [R52++];                   # interpolated air flow
2e1d: 69,04,00,52         sb2w  R52,4            R52 -= 4;
#
# R52 -> nearest FN036 entry
# R54 = instantaneous airflow
#
2e21: c3,76,b4,52         stw   R52,[R76+b4]     Maf_ptr = R52;                    # Save the pointer for next time
#
# Integrate as sum of trapezoids
#
2e25: a3,74,d2,50         ldw   R50,[R74+d2]     R50 = MAF;                        # last MAF value
2e29: c3,74,d2,54         stw   R54,[R74+d2]     MAF = R54;                        # MAF not in Kg/Hr
2e2d: 01,52               clrw  R52              R52 = 0;
2e2f: 64,54,50            ad2w  R50,R54          R50 += R54;                       # Average previous & current MAF values
2e32: a5,00,00,52         adcw  R52,0            R52 += CY;
2e36: 0c,01,50            shrdw R50,1            R53:R50 /= 2;                     # R50 <- (old MAF + current MAF) / 2
                                                                                   # R52 <- 0
2e39: 6f,76,b8,50         ml2w  R50,[R76+b8]     R53:R50 = R51:R50 * INTM;         # INTM = IO ticks (2.4 us per)
2e3d: 0d,09,50            shldw R50,9            R53:R50 *= 200;
2e40: 67,01,b0,03,50      ad2w  R50,[R0+3b0]     R50 += AMINT_L;                   # Add to 32-bit integrator AMINT, AMINT_L
2e45: c3,01,b0,03,50      stw   R50,[R0+3b0]     AMINT_L = R50;
2e4a: a4,00,52            adcw  R52,R0           R52 += CY;
2e4d: 67,76,b0,52         ad2w  R52,[R76+b0]     R52 += AMINT;
2e51: d3,03               jnc   2e56             if (unsigned overflow)  {
2e53: bd,ff,52            ldsbw R52,ff           R52 = 0xffff; }                  # Clip if overflow
2e56: c3,76,b0,52         stw   R52,[R76+b0]     AMINT = R52;
2e5a: f0                  ret                    return;
##########################################################


  Foreground_Fuel:
#
# Fuel Pulsewidth, Foreground Fuel
# GUFB p. 6-85 top
# Called only from PIP rising edge handler
#
2e5b: 01,52               clrw  R52              R52 = 0;                          # start bank = bank 1
#
# Loop back here from 2fbf if NUMEGO = 2
#
# R52 (word) = 0 if bank 1, 2 if bank 2 (on 2nd pass)
#
2e5d: a3,53,94,03,54      ldw   R54,[R52+394]    R54 = [R52+BGFUL1];
2e62: 35,e7,2d            jnb   B5,Re7,2e92      if (FFULFLG == 1)  {              # jmp if background fuel
#
# Use foreground fuel
# fuelpwn = [(FFULMn * ARCHFG) / ARCHG_BG] + FFULCn per GUFB doc
#
2e65: a3,74,da,54         ldw   R54,[R74+da]     R54 = ARCHFG;
2e69: 6f,53,98,03,54      ml2w  R54,[R52+398]    R57:R54 = R55:R54 * [R52+FFULM1]; # PW for base fuel
2e6e: 8f,76,26,54         divw  R54,[R76+26]     R55:R54 = R57:R54 / ARCHG_BG;
2e72: d5,03               jnv   2e77             if (OVF == 1)  {
2e74: bd,ff,54            ldsbw R54,ff           R54 = 0xffff; }                   # handle overflow from divide
#
2e77: a3,53,9c,03,56      ldw   R56,[R52+39c]    R56 = [R52+FFULC1];               # FFULCn = PW adjustment for accel/transient fuel (signed)
2e7c: 37,57,0b            jnb   B7,R57,2e8a      if (B7_R57 == 0) goto 2e8a;       # jmp if positive
2e7f: 03,56               negw  R56              R56 = -R56;                       # subtract signed FFULCn from unsigned FFULMn
2e81: 68,56,54            sb2w  R54,R56          R54 -= R56;
2e84: db,0c               jgeu  2e92             if (R54 < 0)  {
2e86: 01,54               clrw  R54              R54 = 0;                          # clip to 0 on underflow
2e88: 20,08               sjmp  2e92             goto 2e92;
# FFULCn was positive
2e8a: 64,56,54            ad2w  R54,R56          R54 += R56;
2e8d: d3,03               jnc   2e92             if (unsigned overflow)  {
2e8f: bd,ff,54            ldsbw R54,ff           R54 = 0xffff; } } }               # handle overflow
#
# Jump here from:
#  2e62 (!FFULFLG)
#  2e84 ((-FFULCn) =< FFULMn)
#  2e88 ((-FFULCn) > FFULMn, clipped to 0)
#  2e8d (FFULCn > 0)
#
# R52 (word) = 0 if bank 1, 2 if bank 2
# R54 (word) = chosen pulsewidth in ms (scale factor??)
#
2e92: 6d,73,cb,54         ml2w  R54,cb73         R57:R54 = R55:R54 * 0xcb73;
2e96: a0,56,50            ldw   R50,R56          R50 = R56;                        # R50 <- high word of product
2e99: 01,5a               clrw  R5a              R5a = 0;
2e9b: 98,bc,00            cmpb  R0,Rbc           
2e9e: d7,31               jne   2ed1             if (0 == DT12SH)  {
#
# DT12S < 65536, check that PW doesn't exceed interval between injections
# (For a V8, at 600 RPM DT12S = 10417; at 6000 RPM, 1042.)
#
2ea0: 0c,0a,54            shrdw R54,a            R57:R54 /= 400;                   # R54 (dword) is PW in ticks * 0x20
2ea3: 8c,ba,54            divw  R54,Rba          R55:R54 = R57:R54 / DT12S;        # calculate # of PIPs for this PW
2ea6: 8b,fc,2e,54         cmpw  R54,[Rfc+2e]                                       # PIPOUT = # of PIPs between injection events same port (x 0x20)
2eaa: d3,10               jltu  2ebc             if ((uns) R54 >= PIPOUT)  {       # jmp if duty cycle < 100%
# Scale back pulsewidth to 99.6% duty cycle
2eac: a3,fc,2e,54         ldw   R54,[Rfc+2e]     R54 = PIPOUT;                     
2eb0: 05,54               decw  R54              R54--;
2eb2: 4c,ba,54,58         ml3w  R58,R54,Rba      R5b:R58 = R54 * DT12S;
2eb6: 0c,06,58            shrdw R58,6            R5b:R58 /= 0x40;                  # why not 0x20? make it too lean to hurt itself??
2eb9: a0,58,50            ldw   R50,R58          R50 = R58; }
#
# Jump here from:
#  2eaa (duty cycle < 100%)
#
# R50 (word) = pulsewidth in ticks
# R54 (word) = PIPOUT - 1
#
2ebc: 01,5a               clrw  R5a              R5a = 0;
2ebe: a3,72,0e,58         ldw   R58,[R72+e]      R58 = PWOFF;                      # Injector offset in ticks
2ec2: 0d,05,58            shldw R58,5            R5b:R58 *= 0x20;
2ec5: 8c,ba,58            divw  R58,Rba          R59:R58 = R5b:R58 / DT12S;
2ec8: 44,58,54,5a         ad3w  R5a,R54,R58      R5a = R54 + R58;                  # = (PWOFF * 0x20/DT12S) + PIPOUT - 1
2ecc: d3,03               jnc   2ed1             if (unsigned overflow)  {
2ece: ad,ff,5a            ldzbw R5a,ff           R5a = (uns)ff; } }                # ??? why zero extend, not sign extend?
#
# Jump here from:
#  2e9e (D12SH > 0)
#  2ecc (not unsigned overflow)
#
# Calculate delta PW from previous
# R50 (word) = pulsewidth in ticks
# R52 (word) = 0 if bank 1, 2 if bank 2
#
2ed1: 01,54               clrw  R54              R54 = 0;
2ed3: 4b,53,06,02,50,56   sb3w  R56,R50,[R52+206] R56 = R50 - [R52+FUELPW1];       # FUELPWn = previous Pulse Width in ticks
2ed9: db,02               jc    2edd             if (R56 < 0)  {                   # Take absolute value of delta
2edb: 03,56               negw  R56              R56 = -R56; }
#
2edd: 8f,53,06,02,54      divw  R54,[R52+206]    R55:R54 = R57:R54 / [R52+FUELPW1];
2ee2: 89,99,19,54         cmpw  R54,1999         
2ee6: d1,03               jleu  2eeb             if ((uns) R54 > 0x1999 )  {       # If delta >= 12.5%,
2ee8: 91,80,48            orb   R48,80           CHANGE_FUELPW = 1; }              # Update injections in progress for this bank
#
2eeb: c3,53,06,02,50      stw   R50,[R52+206]    [R52+FUELPW1] = R50;              # Save new PW for this bank
2ef0: 37,2e,13            jnb   B7,R2e,2f06      if (FUEL_IN_SYNC == 0) goto 2f06;
2ef3: 31,52,0a            jnb   B1,R52,2f00      if (B1_R52 == 0) goto 2f00;       # jump if bank 1
2ef6: 3e,2f,02            jb    B6,R2f,2efb      if (New_idelay2 == 1) goto 2efb;
2ef9: 20,9e               sjmp  2f99             goto 2f99;
#
2efb: 71,bf,2f            an2b  R2f,bf           New_idelay2 = 0;
2efe: 20,06               sjmp  2f06             goto 2f06;
#
# Jump here from 2ef3 (Bank 1)
2f00: 37,2f,f6            jnb   B7,R2f,2ef9      if (New_idelay1 == 0) goto 2ef9;
# New_idelay1 was 1
2f03: 71,7f,2f            an2b  R2f,7f           New_idelay1 = 0;
#
# jump here from:
#  2ef0 (!FUEL_IN_SYNC),
#  2efe (New_idelay2 was 1, now 0)
#
2f06: a3,f4,24,54         ldw   R54,[Rf4+24]     R54 = INJREF;                     # which edge for fuel pulse
2f0a: 6c,5a,54            ml2w  R54,R5a          R57:R54 = R55:R54 * R5b:R5a;
2f0d: 01,5a               clrw  R5a              R5a = 0;
2f0f: a3,72,00,58         ldw   R58,[R72+0]      R58 = INJDLY;
2f13: 31,52,02            jnb   B1,R52,2f18      if (B1_R52 == 1)  {               # was this bank 2?
2f16: 15,52               decb  R52              R52--; }                          # It's bank 1 now
#
2f18: 65,80,02,58         ad2w  R58,280          R58 += MINTIM1;
2f1c: 0d,01,58            shldw R58,1            R5b:R58 *= 2;
2f1f: 8f,fc,2c,58         divw  R58,[Rfc+2c]     R59:R58 = R5b:R58 / DEGPIP;
2f23: 68,54,58            sb2w  R58,R54          R58 -= R54;
2f26: db,04               jc    2f2c             if (R58 > 0)  {
2f28: 67,fc,2a,58         ad2w  R58,[Rfc+2a]     R58 += NUMCYL; }
#
2f2c: 37,2e,5c            jnb   B7,R2e,2f8b      if (FUEL_IN_SYNC == 1)  {
#
# Sequential injector firing logic
#
2f2f: 3b,2f,57            jb    B3,R2f,2f89      if (NLMT_FLG == 0)  {             # jump if rev limit fuel cutoff active
2f32: af,53,6e,02,54      ldzbw R54,[R52+26e]    R54 = (uns)[R52+Total_delay1];
2f37: af,fe,07,50         ldzbw R50,[Rfe+7]      R50 = (uns)ENGCYL;                # PIPs/rev x 2
2f3b: 6f,51,be,2f,54      ml2w  R54,[R50+2fbe]   R57:R54 = R55:R54 * [R50+2fbe];   # See table @ 2fc2 below
2f40: 6f,51,be,2f,58      ml2w  R58,[R50+2fbe]   R5b:R58 = R59:R58 * [R50+2fbe];
2f45: 0c,06,54            shrdw R54,6            R57:R54 /= 40;
2f48: 0c,06,58            shrdw R58,6            R5b:R58 /= 40;
2f4b: 68,54,58            sb2w  R58,R54          R58 -= R54;
2f4e: b8,00,56            sbbb  R56,R0           R56 -= CY;
2f51: d6,02               jge   2f55             if (R56 < 0)  {
2f53: 03,58               negw  R58              R58 = -R58; }
#
2f55: a3,fc,2a,5a         ldw   R5a,[Rfc+2a]     R5a = NUMCYL;
2f59: 09,07,5a            shlw  R5a,7            R5a *= 80;
2f5c: 88,58,5a            cmpw  R5a,R58          
2f5f: db,04               jgeu  2f65             if (R5a > R58)  {
2f61: 03,58               negw  R58              R58 = -R58;
2f63: 15,56               decb  R56              R56--; }
#
2f65: 89,00,10,58         cmpw  R58,1000         
2f69: d1,04               jleu  2f6f             if ((uns) R58 > 1000 )  {
2f6b: a1,00,10,58         ldw   R58,1000         R58 = 1000; }
#
2f6f: 30,56,02            jnb   B0,R56,2f74      if (B0_R56 == 1)  {
2f72: 03,58               negw  R58              R58 = -R58; }
#
2f74: 64,54,58            ad2w  R58,R54          R58 += R54;
2f77: a3,51,be,2f,50      ldw   R50,[R50+2fbe]   R50 = [R50+2fbe];                 # see table @ 2fc2 below
2f7c: 08,06,50            shrw  R50,6            R50 /= 40;
2f7f: 01,5a               clrw  R5a              R5a = 0;
2f81: 8c,50,58            divw  R58,R50          R59:R58 = R5b:R58 / R51:R50;
2f84: c7,53,6e,02,58      stb   R58,[R52+26e]    [R52+Total_delay1] = R58; }
#
# Jump here from 2f2f (NLMT_FLG)
#
2f89: 20,0e               sjmp  2f99             goto 2f99; }
#
# Jump here from 2f2c (!FUEL_IN_SYNC)
#
2f8b: 34,2e,0b            jnb   B4,R2e,2f99      if (SYNC_UP_FUEL == 1)  {
2f8e: c7,74,f0,58         stb   R58,[R74+f0]     Total_delay1 = R58;
2f92: c7,74,f1,58         stb   R58,[R74+f1]     Total_delay2 = R58;
2f96: 91,80,2e            orb   R2e,80           FUEL_IN_SYNC = 1; }
#
# Jump here from:
#  2ef9
#  2f89
#  2f8b (!SYNC_UP_FUEL)
#
2f99: 71,f7,2e            an2b  R2e,f7           Simultaneous = 0;
2f9c: b1,02,5a            ldb   R5a,2            R5a = 2;
2f9f: 9b,fc,33,5a         cmpb  R5a,[Rfc+33]     
2fa3: df,03               je    2fa8             if (2 == OUTINJ) goto 2fa8;       # calibration is bank fire (not A9L)
2fa5: 37,a1,0b            jnb   B7,Ra1,2fb3      if (CRKFLG == 1)  {
#
# Bank fire (CRKFLG || OUTINJ == 2)
#
2fa8: 91,08,2e            orb   R2e,8            Simultaneous = 1;
2fab: c7,74,ee,00         stb   R0,[R74+ee]      Inj_bank1 = 0;
2faf: c7,74,ef,00         stb   R0,[R74+ef]      Inj_bank2 = 0; }
#
2fb3: 88,00,52            cmpw  R52,R0           
2fb6: d7,09               jne   2fc1             if (R52 != 0) return;
2fb8: af,fe,16,52         ldzbw R52,[Rfe+16]     R52 = (uns)NUMEGO;                # = 2 in A9L
2fbc: 31,52,02            jnb   B1,R52,2fc1      if (B1_R52 == 0) return;          # Exit if mono EGO
2fbf: 26,9c               sjmp  2e5d             goto 2e5d; }                      # Else loop for bank 2
#
2fc1: f0                  ret                    return;

2fc2: 00,80               word   8000                                              # 4 cyl
2fc4: 80,55               word   5580                                              # 6 cyl
2fc6: 00,40               word   4000                                              # 8 cyl


######################################
# Schedule fuel injector firing
# Called from both PIP rising and falling edge handlers
######################################

  Schedule_Injectors:
2fc8: bd,ff,56            ldsbw R56,ff           R56 = 0xffff;
# Loop from 317D w/ R56 == 0
2fcb: 07,56               incw  R56              R56++;
#
# R56 (word) = 0: bank 1  = 1: bank 2
#
2fcd: b3,57,6a,02,54      ldb   R54,[R56+26a]    R54 = [R56+Inj_pip_cnt1];         # Get # of pips til scheduled
2fd2: 15,54               decb  R54              R54--;
2fd4: df,02               jz    2fd8             
2fd6: 20,e2               sjmp  30ba             if (R54 != 0) goto 30ba;          # not time to schedule this cylinder yet
#
# Schedule this cylinder
#
2fd8: 91,20,2e            orb   R2e,20           Base_fuel = 1;
2fdb: b3,01,be,03,54      ldb   R54,[R0+3be]     R54 = Piplim;                     # = 2 in A9L (see 3e42 - 3e51)
2fe0: 37,a1,19            jnb   B7,Ra1,2ffc      if (CRKFLG == 1)  {
#
# Cranking fuel logic
# GUFB p. 6-105
# NOT high RPM path
#
2fe3: 9b,fc,34,00         cmpb  R0,[Rfc+34]      
2fe7: d7,05               jne   2fee             if (0 != EDSEL) goto 2fee;        # EDSEL is 0 in A9L
#
# EDSEL == 0: Calibration says fire injectors on falling edge of PIP during crank
2fe9: 30,90,05            jnb   B0,R90,2ff1      if (B0_Last_HSI == 0) goto 2ff1;  # Jump if PIP transition was hi -> low
2fec: 20,09               sjmp  2ff7             goto 2ff7;
#
# EDSEL == 1: Calibration says fire injectors on rising edge of PIP during crank
2fee: 30,90,06            jnb   B0,R90,2ff7      if (B0_Last_HSI == 1)  {          # Jump if PIP transition was low -> hi
#
# This is the chosen PIP edge
2ff1: b3,fc,30,54         ldb   R54,[Rfc+30]     R54 = CRKPIP;                     # Reset PIP count for this cylinder
2ff5: 20,05               sjmp  2ffc             goto 2ffc; }                      # and prepare to fire injector
#
# Not the chosen PIP edge
2ff7: b1,01,54            ldb   R54,1            R54 = 1;                          # Fire it next time
2ffa: 20,be               sjmp  30ba             goto 30ba; }
#
# Jump here from:
#  2fe0 (!CRKFLG)
#   R54 = Piplim
#  2ff5 (CRKFLG && EDSEL == B0_Last_HSI, i.e. chosen PIP edge during crank)
#   R54 = CRKPIP
#
2ffc: 3b,2e,35            jb    B3,R2e,3034      if (Simultaneous == 1) goto 3034; # Skip this logic if in simultaneous mode
#
# Sequential fuel injection logic
# R54 = new # of PIPs to wait = Piplim
# R56 (word): 0 = bank 1; 1 = bank 2
# 
2fff: af,57,6c,02,52      ldzbw R52,[R56+26c]    R52 = (uns)[R56+Inj_bank1];       # 
3004: 17,52               incb  R52              R52++;
3006: 9b,fc,32,52         cmpb  R52,[Rfc+32]
300a: d3,02               jltu  300e             if ((uns) R52 >= NUMOUT)  {
300c: 11,52               clrb  R52              R52 = 0; }                        # wrap to 0 if R52 >= NUMOUT
#
300e: c7,57,6c,02,52      stb   R52,[R56+26c]    [R56+Inj_bank1] = R52;            # R52 is cyl sequence
#
3013: 45,e3,01,f4,5a      ad3w  R5a,Rf4,1e3      R5a = FN1329;                     # Sequence # to injector # table (0 based)
3018: 64,52,5a            ad2w  R5a,R52          R5a += R52;                       # ROM ptr to injector to fire from sequence no
301b: ae,5a,50            ldzbw R50,[R5a]        R50 = (uns)[R5a];                 # R50 is cyl no (1 - 8)
301e: 45,da,01,f4,5a      ad3w  R5a,Rf4,1da      R5a = FN1327;                     # Injector # to bank # table (1-based)
3023: 64,50,5a            ad2w  R5a,R50          R5a += R50;                       # 
3026: b2,5a,50            ldb   R50,[R5a]        R50 = [R5a];                      #
#
# R50 (byte): 0 = bank 1; 2 = bank 2 (corresponds to EGO # for selected cylinder)
# R56 (word): 0 = bank 1; 1 = bank 2
#
3029: 38,56,05            jb    B0,R56,3031      if (B0_R56 == 1) goto 3031;       # jump on R56 = bank 2
302c: 31,50,05            jnb   B1,R50,3034      if (B1_R50 == 0) goto 3034;       # jump on R50 = bank 1
302f: 20,89               sjmp  30ba             goto 30ba;                        # R50 and R56 disagree; not firing this time
#
# R56 (word) = 1, i.e. bank 2
#
3031: 31,50,fb            jnb   B1,R50,302f      if (B1_R50 == 0) goto 302f;       # jump on R50 = bank 1
                                                                                   # (jump to jump because out of range for conditional jump)
#
# jump here from:
#  2ffc (Simultaneous)
#  302c (R50, R56 indicate same bank)
#
# R56 = 0 (bank 1) or 1 (bank 2)
#
3034: 01,52               clrw  R52              R52 = 0;
3036: 34,2e,6c            jnb   B4,R2e,30a5      if (SYNC_UP_FUEL == 1)  {         # We're (getting?) synced 
3039: af,57,6c,02,52      ldzbw R52,[R56+26c]    R52 = (uns)[R56+Inj_bank1];

303e: b3,fc,32,5a         ldb   R5a,[Rfc+32]     R5a = NUMOUT;                     # # of injector ports (= 8 on A9L)
3042: 99,02,5a            cmpb  R5a,2            
3045: d7,0a               jne   3051             if (NUMOUT == 2)  {
#
# Bank fire hardware (not on A9L)
#
3047: 30,52,07            jnb   B0,R52,3051      if (B0_R52 == 1)  {
304a: af,fe,07,52         ldzbw R52,[Rfe+7]      R52 = (uns)ENGCYL;                # = PIPs/rev x 2
304e: 08,01,52            shrw  R52,1            R52 /= 2; } }                     # = PIPs/rev
#
# Jump here from 3045 (not bank fire hardware)
#
# R52 (word): if bank fire, PIPs/rev;
#             if sequential, seq # of current cylinder (0 - NUMOUT-1)
# R54 (byte): # of PIPs to delay
#
3051: 09,05,52            shlw  R52,5            R52 *= 20;                        # = PIPs/rev x 0x20 (in bank fire)
3054: ac,d1,50            ldzbw R50,Rd1          R50 = (uns)SYNCTR;                # = sequence # x 0x20
3057: 68,52,50            sb2w  R50,R52          R50 -= R52;
305a: db,04               jgeu  3060             if (R50 < 0)  {
305c: 67,fc,2a,50         ad2w  R50,[Rfc+2a]     R50 += NUMCYL; }                  # NUMCYL = # of cylinders * 0x20
#
3060: af,57,6e,02,52      ldzbw R52,[R56+26e]    R52 = (uns)[R56+Total_delay1];    #
3065: 68,50,52            sb2w  R52,R50          R52 -= R50;
3068: db,04               jgeu  306e             if (R52 < 0)  {
306a: 67,fc,2a,52         ad2w  R52,[Rfc+2a]     R52 += NUMCYL; }
#
306e: 99,30,52            cmpb  R52,30           
3071: d1,08               jleu  307b             if ((uns) R52 > 30 )  {
3073: 75,02,54            ad2b  R54,2            R54 += 2;
3076: b1,18,52            ldb   R52,18           R52 = 18;
3079: 20,2a               sjmp  30a5             goto 30a5; }
#
#
307b: 38,56,05            jb    B0,R56,3083      if (B0_R56 == 0)  {
307e: 91,80,2f            orb   R2f,80           New_idelay1 = 1;
3081: 20,03               sjmp  3086             goto 3086; }
#
3083: 91,40,2f            orb   R2f,40           New_idelay2 = 1;
#
3086: 99,20,52            cmpb  R52,20           
3089: db,1a               jgeu  30a5             if (R52 > 20)  {
308b: 38,90,02            jb    B0,R90,3090      if (B0_Last_HSI == 0)  {
308e: 15,54               decb  R54              R54--; }
#
3090: 99,10,52            cmpb  R52,10           
3093: db,10               jgeu  30a5             if (R52 < 10)  {
3095: 75,20,52            ad2b  R52,20           R52 += 20;
3098: 15,54               decb  R54              R54--;
309a: 38,56,05            jb    B0,R56,30a2      if (B0_R56 == 0)  {
309d: 71,7f,2f            an2b  R2f,7f           New_idelay1 = 0;
30a0: 20,03               sjmp  30a5             goto 30a5; }
#
30a2: 71,bf,2f            an2b  R2f,bf           New_idelay2 = 0; } } }
#
# Jump here from:
#  3036 (!SYNC_UP_FUEL)
#  3079 (B0_R56, i.e. bank 2)
#  3089 (B0_Last_HSI, i.e. PIP rising edge)
#  3093 (R52 >= 10)
#  30a0 (!B0_R56, i.e. bank 1, just cleared New_idelay1)
#
# R54 = # of PIPs to delay
#
30a5: c4,59,52            stb   R52,R59          R59 = R52;
30a8: 91,04,2e            orb   R2e,4            New_ibeta = 1;
30ab: 98,54,00            cmpb  R0,R54           
30ae: de,03               jlt   30b3             if (0 >= R54)  {
30b0: b1,01,54            ldb   R54,1            R54 = 1; }
#
30b3: c7,57,6a,02,54      stb   R54,[R56+26a]    [R56+Inj_pip_cnt1] = R54;
30b8: 20,07               sjmp  30c1             goto 30c1;
#
# Jump here from:
#  2ffa (not desired PIP edge during crank)
#  302f (cylinder # for other bank)
#
# R54 = # of PIPs to delay
#
30ba: c7,57,6a,02,54      stb   R54,[R56+26a]    [R56+Inj_pip_cnt1] = R54;
30bf: 20,a4               sjmp  3165             goto 3165;
#
30c1: b3,57,6c,02,58      ldb   R58,[R56+26c]    R58 = [R56+Inj_bank1];
#
# Jump here from 3163
# R56 (word): 0 = bank 1; 1 = bank 2
#
30c6: c8,56               push  R56              push(R56);                        # *** why? ***
30c8: af,57,6c,02,54      ldzbw R54,[R56+26c]    R54 = (uns)[R56+Inj_bank1];
30cd: 64,f4,54            ad2w  R54,Rf4          R54 += Rf4;
30d0: b3,55,e3,01,54      ldb   R54,[R54+1e3]    R54 = [R54+1e3];                  # FN1329 injector firing order
30d5: 35,2a,0a            jnb   B5,R2a,30e2      if (RUNNING == 1)  {              # not self test
#
# RUNNING == 1 - KOER self test (weak cylinder test?)
#
########### get cyl no (in R54)
30d8: 9b,74,94,54         cmpb  R54,[R74+94]                                       # what is in this location?
30dc: d7,04               jne   30e2             if (R54 == [212])  {
30de: cc,56               pop   R56              R56 = pop();
30e0: 20,83               sjmp  3165             goto 3165; } }                    # Not firing this cylinder
#
# Jump here from:
#  30d5 (!RUNNING)
#  30dc (R54 != [212]
#
# Old R56 on stack
#
# Alternate cylinder fuel cutoff (stage 2 vehicle speed limiter)
#
30e2: 30,e7,0a            jnb   B0,Re7,30ef      if (FOFFLG == 1)  {               # Stage 2 vehicle speed limiter - fire alternate cylinders
30e5: 95,02,e7            xorb  Re7,2            FGFFLG ^= 1;
30e8: 39,e7,04            jb    B1,Re7,30ef      if (FGFFLG == 0)  {
30eb: cc,56               pop   R56              R56 = pop();                      # Not firing this cylinder
30ed: 20,76               sjmp  3165             goto 3165; } }
#
# Old R56 on stack
#
30ef: 79,01,54            sb2b  R54,1            R54 -= 1;                         # entry no - 1
30f2: 5d,16,54,92         ml3b  R92,R54,16       TPtr = R54 * 16;                  # 2284 Table cell for cyl
30f6: 65,a6,22,92         ad2w  R92,22a6         TPtr += InjTTab;                  # convert cell to table pointer
30fa: 47,92,08,f4,54      ad3w  R54,Rf4,[R92+8]  R54 = Rf4 + [TPtr+8];             # = 91B8, Injector Output Port
30ff: af,55,da,01,54      ldzbw R54,[R54+1da]    R54 = (uns)[R54+Code_ones_ex];    # load bank from cyl no
3104: 8b,55,06,02,00      cmpw  R0,[R54+206]                                       # PulseWidth? - port 0 or 2
3109: df,17               je    3122             if (0 != [R54+FUELPW1])  {
310b: 32,a1,08            jnb   B2,Ra1,3116      if (UNDSP == 1)  {
310e: a0,8c,80            ldw   R80,R8c          HSO_time = Reftime;               # Fire this cylinder now (?)
3111: b0,8e,82            ldb   R82,R8e          HSO_timeH = ReftimeH;
3114: 20,08               sjmp  311e             goto 311e; }
#
# Jump here from 310b (!UNDSP)
#
3116: 28,82               scall 319a             Set_bank_inj();
3118: a0,50,80            ldw   R80,R50          HSO_time = R50;
311b: b0,52,82            ldb   R82,R52          HSO_timeH = R52;
#
# Jump here from 3114 (UNDSP)
#
311e: 28,a4               scall 31c4             Do_inj?();
3120: 20,10               sjmp  3132             goto 3132; }
#
# Jump here from:
#  3109 (pulsewidth was 0)
#
3122: af,92,05,7e         ldzbw R7e,[R92+5]      Rtab = (uns)[TPtr+5];             # 2C5 Table?
3126: 65,c5,02,7e         ad2w  R7e,2c5          Rtab += HSOQ;
312a: c3,7e,fe,8c         stw   R8c,[R7e+fe]     [Rtab-2] = Reftime;               # set time of most recent injector event
312e: c7,7e,fd,8e         stb   R8e,[R7e+fd]     [Rtab-3] = ReftimeH;
#
# Jump here from 3120
#
3132: cc,56               pop   R56              R56 = pop();
3134: 71,df,2e            an2b  R2e,df           Base_fuel = 0;
3137: 33,2e,2b            jnb   B3,R2e,3165      if (Simultaneous == 1)  {
#
# Simultaneous logic
# Increment injector being considered
#
313a: b3,57,6c,02,54      ldb   R54,[R56+26c]    R54 = [R56+Inj_bank1];
313f: 17,54               incb  R54              R54++;
3141: 9b,fc,32,54         cmpb  R54,[Rfc+32]                                       # NUMOUT - no of injector outputs
3145: d3,02               jltu  3149             if ((uns) R54 >= NUMOUT)  {
3147: 11,54               clrb  R54              R54 = 0; }                        # wrap injector count
#
3149: c7,57,6c,02,54      stb   R54,[R56+26c]    [R56+Inj_bank1] = R54;            # Store the injector bank(?) 
314e: 30,54,0a            jnb   B0,R54,315b      if (B0_R54 == 1)  {
3151: 95,40,02            xorb  R2,40            CPU_OK ^= 1;                      # Tickle watchdog timer on odd cylinder #s
3154: 17,05               incb  R5               WDG_Timer++;
3156: 17,05               incb  R5               WDG_Timer++;
3158: 95,40,02            xorb  R2,40            CPU_OK ^= 1; }                    # watchdog and LOS reset
#
315b: 98,54,58            cmpb  R58,R54          
315e: df,05               je    3165             if (R58 != R54)  {
3160: 91,20,2e            orb   R2e,20           Base_fuel = 1;
3163: 27,61               sjmp  30c6             goto 30c6; } }
#
# Jump here from:
#  30BF (cylinder on other bank)
#  30E0 (KOER weak cylinder test)
#  30ED (alternate cylinder speed limiter)
#  3137 (!Simultaneous)
#  315E
#
3165: 32,2e,05            jnb   B2,R2e,316d      if (New_ibeta == 1)  {
3168: c7,57,70,02,59      stb   R59,[R56+270]    [R56+Ibeta1] = R59; }
#
316d: 71,db,2e            an2b  R2e,db           New_ibeta = 0;
                                                 Base_fuel = 0;
3170: 3b,2e,0e            jb    B3,R2e,3181      if (Simultaneous == 1) goto 3181;
#
3173: b3,fe,16,50         ldb   R50,[Rfe+16]     R50 = NUMEGO;
3177: 38,50,0f            jb    B0,R50,3189      if (B0_R50 == 1) return;          # if only 1 EGO, we're done
317a: 38,56,0c            jb    B0,R56,3189      if (B0_R56 == 1) return;          # if we've done both banks, we're done
317d: 26,4c               sjmp  2fcb             goto 2fcb;
#
317f: 20,08               sjmp  3189             return;                           # *** is this reachable? ***
#
# Simultaneous logic
#
3181: b3,74,ec,50         ldb   R50,[R74+ec]
3185: c7,74,ed,50         stb   R50,[R74+ed]     Inj_pip_cnt2 = Inj_pip_cnt1;
# Exit
3189: f0                  ret                    return;


  UPd_Inj_pend:
318a: b3,92,07,54         ldb   R54,[R92+7]      R54 = [TPtr+7];                   # 2C5 Table ?
318e: 73,72,12,54         an2b  R54,[R72+12]     R54 &= Inj_pending;
3192: c7,72,12,54         stb   R54,[R72+12]     Inj_pending = R54;
3196: 71,ef,4f            an2b  R4f,ef           Pending = 0;
3199: f0                  ret                    return;


######################################################################
# Bank Injection (unsynced fuel) setup ?
# Takes cylinder number from table entry pointed to by R92 (TPtr)
# Returns injector event time in R52:R50
#
# Called from:
#  Schedule_Injectors
#  Sub7
#
# Clobbers R53, R5a, R5b
######################################################################

  Set_bank_inj:
319a: a3,92,08,50         ldw   R50,[R92+8]      R50 = [TPtr+8];                   # R50 is scyl no ?
319e: 45,da,01,f4,5a      ad3w  R5a,Rf4,1da      R5a = FN1327;                     # Injector Output Port(Inj port vs cyl)
31a3: 64,50,5a            ad2w  R5a,R50          R5a += R50;                       # add cylno
31a6: ae,5a,50            ldzbw R50,[R5a]        R50 = (uns)[R5a];                 # load port (0 or 2) from ROM Table
31a9: 31,50,02            jnb   B1,R50,31ae      if (B1_R50 == 1)  {               # jmp if port == 0 (not 2)
31ac: 15,50               decb  R50              R50--; }                          # change port 2 into 1
31ae: b3,51,70,02,51      ldb   R51,[R50+270]    R51 = [R50+Ibeta1];               # Table indexed by port 0 or 1
31b3: 11,50               clrb  R50              R50 = 0;
31b5: 6c,ba,50            ml2w  R50,Rba          R53:R50 = R51:R50 * DT12S;        # PIP time lo 16 bits
31b8: 0c,0d,50            shrdw R50,d            R53:R50 /= 0x2000;
31bb: 67,74,50,50         ad2w  R50,[R74+50]     R50 += Prev_PIP_time;
31bf: b7,74,52,52         adcb  R52,[R74+52]     R52 += Prev_PIP_timeH + CY;
31c3: f0                  ret                    return;


######################################################################
# Cyl Injection (synced fuel) setup ?
# Called only from Schedule_Injectors
#
# Inputs:
#  R82:R80 = next injector event time??
#  R92 (TPtr) (word): points to injector entry in ROM table @ 22a6
#  Base_fuel flag
#
# Outputs:
#  Inj_mode flag for cylinder
#
# Clobbers:
#  R50, R52, R7e-R7f, R86
######################################################################

  Do_inj?:
31c4: 71,f7,2d            an2b  R2d,f7           No_fuel_save = 0;
31c7: af,92,05,7e         ldzbw R7e,[R92+5]      Rtab = (uns)[TPtr+5];
31cb: 65,c5,02,7e         ad2w  R7e,2c5          Rtab += HSOQ;                     # R7e (word) = pointer to HSO queue entry for injector
31cf: 35,2e,0c            jnb   B5,R2e,31de      if (Base_fuel == 1)  {
31d2: b3,92,06,50         ldb   R50,[R92+6]      R50 = [TPtr+6];
31d6: 93,72,10,50         orb   R50,[R72+10]     R50 |= Inj_base;
31da: c7,72,10,50         stb   R50,[R72+10]     Inj_base = R50; }                 # Turn on base fuel flag for this injector
#
# Jump here from:
#  31cf (!Base_fuel)
#
31de: b3,92,07,50         ldb   R50,[R92+7]      R50 = [TPtr+7];
31e2: 73,72,11,50         an2b  R50,[R72+11]     R50 &= Inj_pip;
31e6: c7,72,11,50         stb   R50,[R72+11]     Inj_pip = R50;                    # Clear injector PIP flag for this injector
31ea: a1,2a,00,50         ldw   R50,2a           R50 = 2a;
31ee: 43,92,0a,44,00      an3w  R0,R44,[R92+a]   if (HSOut_Flags & [TPtr+a] == 0) goto 3237;
31f3: df,42               je    3237
#
# Selected injector is ON
#
# R50 (word) = 2a = 42 ticks = 100.8 us
#
31f5: 67,7e,02,50         ad2w  R50,[R7e+2]      R50 += [Rtab+2];                  # Add next event time for this injector to R52:R50
31f9: b3,7e,04,52         ldb   R52,[R7e+4]      R52 = [Rtab+4];
31fd: b4,00,52            adcb  R52,R0           R52 += CY;
3200: 88,50,80            cmpw  R80,R50          HSO_time - R50;                   # 24-bit compare - HSO_time - R52:R50
3203: b0,82,86            ldb   R86,R82          R86 = HSO_timeH;
3206: b8,52,86            sbbb  R86,R52          R86 -= R52 - CY;                  # carry from CMPW @ 3200!
3209: 37,86,1e            jnb   B7,R86,322a      if (B7_R86 == 1)  {               # i.e. if R52:R50 later than HSO_time
320c: 35,2e,0b            jnb   B5,R2e,321a      if (Base_fuel == 1)  {
320f: 91,08,2d            orb   R2d,8            No_fuel_save = 1;
3212: c3,7e,fe,80         stw   R80,[R7e+fe]     [Rtab-2] = HSO_time;              # Save HSO_time as last event time 
3216: c7,7e,fd,82         stb   R82,[R7e+fd]     [Rtab-3] = HSO_timeH; }
#
# Jump here from:
#  320c (!Base_fuel)
#
321a: a3,7e,02,80         ldw   R80,[R7e+2]      HSO_time = [Rtab+2];
321e: b3,7e,04,82         ldb   R82,[R7e+4]      HSO_timeH = [Rtab+4];
3222: 28,a9               scall 32cd             Sub8();
3224: 71,f7,2d            an2b  R2d,f7           No_fuel_save = 0;
3227: e7,33,f2            jump  245d             goto Sched_HSO; }                 # Add for execution in 2284/2C5 Table
                                                                                   #  and return
#
# Jump here from:
#  3209 (R86 is positive)
#
322a: b3,92,06,50         ldb   R50,[R92+6]      R50 = [TPtr+6];
322e: 93,72,12,50         orb   R50,[R72+12]     R50 |= Inj_pending;
3232: c7,72,12,50         stb   R50,[R72+12]     Inj_pending = R50;                # Mark the selected injector as pending
3236: f0                  ret                    return;
#
# Jump here from:
#  31ee (Selected injector is OFF)
#
# R50 (word) = 2a = 42 ticks = 100.8 us
#
3237: 67,7e,fe,50         ad2w  R50,[R7e+fe]     R50 += [Rtab-2];                  # Add previous event time for this injector to R52:R50
323b: b3,7e,fd,52         ldb   R52,[R7e+fd]     R52 = [Rtab-3];
323f: b4,00,52            adcb  R52,R0           R52 += CY;
3242: 88,50,80            cmpw  R80,R50                                            # 24-bit compare - HSO_time - R52:R50
3245: b0,82,86            ldb   R86,R82          R86 = HSO_timeH;
3248: b8,52,86            sbbb  R86,R52          R86 -= R52 - CY;                  # 
324b: 37,86,06            jnb   B7,R86,3254      if (B7_R86 == 1)  {               # i.e. if R52:R50 later than HSO_time
324e: a0,50,80            ldw   R80,R50          HSO_time = R50;                   # set HSO_time to R52:R50
3251: b0,52,82            ldb   R82,R52          HSO_timeH = R52; }
#
# Jump here from:
#  324b (B7_R86 == 0)
#
3254: 11,4c               clrb  R4c              Flags_4C = 0;
3256: 73,92,07,e0         an2b  Re0,[R92+7]      Inj_mode &= [TPtr+7];             # Clear injector on bit
#
# fall through to Sub6
#

#
# Called from injector ON HSO processing
#
# Inputs:
#  TPtr
#  HSO_time
#
# Outputs:
#
# Calls:
#  Send_HSO_Cmd
#  UPd_Inj_pend
#  Sub8
#
# Clobbers: R50-R52, R54, R84-R86
#
# Jump here from 32c5 (end of Sub7)
#
  Sub6:
325a: ef,60,f1            call  23bd             Send_HSO_Cmd();                   # send HSO cmd and other stuff
325d: 34,4f,02            jnb   B4,R4f,3262      if (Pending == 1)  {
3260: 2f,28               scall 318a             UPd_Inj_pend(); }
#
3262: 36,4c,01            jnb   B6,R4c,3266      if (Queued == 1)  {
3265: f0                  ret                    return; }
#
3266: 28,65               scall 32cd             Sub8();
3268: 67,72,0e,80         ad2w  R80,[R72+e]      HSO_time += PWOFF;
326c: b4,00,82            adcb  R82,R0           HSO_timeH += CY;
326f: 65,0c,00,92         ad2w  R92,c            TPtr += c;                        # bump TPtr to OFF event for this injector
                                                                                   #  and fall through to Sub7
#
# Called from injector OFF HSO processing
#
# Inputs:
#  R82:R80 (HSO_timeH, HSO_time): HSO event time
#  R92 (word) (TPtr): points to injector OFF event in ROM table
#  Inj_pending flags
#
# Outputs:
#
# Calls:
#  Set_bank_inj
#  UPd_Inj_pend
#  Send_HSO_Cmd
#
# Clobbers: R50-R52, R54, R84-R86
#
  Sub7:
3273: b3,92,06,54         ldb   R54,[R92+6]      R54 = [TPtr+6];
3277: 73,72,12,54         an2b  R54,[R72+12]     R54 &= Inj_pending;
327b: df,29               je    32a6             if (R54 != 0)  {
327d: 91,10,4f            orb   R4f,10           Pending = 1;
3280: 2f,18               scall 319a             Set_bank_inj();
3282: 73,72,11,54         an2b  R54,[R72+11]     R54 &= Inj_pip;
3286: df,06               je    328e             if (R54 != 0)  {
3288: 68,ba,50            sb2w  R50,Rba          R50 -= DT12S;                     # Subtract last PIP cycle time from result of Set_bank_inj
328b: b8,00,52            sbbb  R52,R0           R52 -= CY; }
#
328e: 45,2a,00,80,84      ad3w  R84,R80,2a       R84 = HSO_time + 2a;
3293: b0,82,86            ldb   R86,R82          R86 = HSO_timeH;
3296: b4,00,86            adcb  R86,R0           R86 += CY;
3299: 88,50,84            cmpw  R84,R50          
329c: b8,52,86            sbbb  R86,R52          R86 -= R52 - CY;
329f: 3f,86,04            jb    B7,R86,32a6      if (B7_R86 == 0)  {
32a2: 28,29               scall 32cd             Sub8();
32a4: 2e,e4               scall 318a             UPd_Inj_pend(); } }
#
32a6: ef,14,f1            call  23bd             Send_HSO_Cmd();
32a9: 36,4c,04            jnb   B6,R4c,32b0      if (Queued == 1)  {
32ac: 71,ef,4f            an2b  R4f,ef           Pending = 0;
32af: f0                  ret                    return; }
#
32b0: c3,7e,fe,80         stw   R80,[R7e+fe]     [Rtab-2] = HSO_time;
32b4: c7,7e,fd,82         stb   R82,[R7e+fd]     [Rtab-3] = HSO_timeH;
32b8: 34,4f,0c            jnb   B4,R4f,32c7      if (Pending == 1)  {
32bb: a0,50,80            ldw   R80,R50          HSO_time = R50;
32be: b0,52,82            ldb   R82,R52          HSO_timeH = R52;
32c1: 69,0c,00,92         sb2w  R92,c            TPtr -= c;                        # point TPtr at ON event for this injector
32c5: 27,93               sjmp  325a             goto Sub6; }
#
32c7: 07,7e               incw  R7e              Rtab++;
32c9: c6,7e,00            stb   R0,[R7e]         [Rtab] = 0;
32cc: f0                  ret                    return;


######################################################################
# Fuel addition for trip computer ? unsynced
# Called from several places
#
# Inputs:
#  R92 (word) (TPtr): pointer to injector OFF event entry in ROM table
#  HSO_time (R82-80): event time (Injector ON event?)
#  FUELPW1/2: desired injector pulse width per bank
#  LBMF_INJ1/2: fuel mass (used for DOL)
#  No_fuel_save
#
# Outputs:
#  HSO_time adjusted for the desired pulse width
#  FUEL_SUM_l, FUEL_SUM_h (for DOL)
#  No_queue cleared
#
# Clobbers: R54-R57, R5a-R5b
#
#########################################################

  Sub8:
32cd: 01,54               clrw  R54              R54 = 0;
32cf: a3,92,08,56         ldw   R56,[R92+8]      R56 = [TPtr+8];                   # Cyl No
32d3: 45,da,01,f4,5a      ad3w  R5a,Rf4,1da      R5a = FN1327;                     # Injector Output Port Table
32d8: 64,56,5a            ad2w  R5a,R56          R5a += R56;
32db: ae,5a,50            ldzbw R50,[R5a]        R50 = (uns)[R5a];                 # load bank for this cylinder (0 or 2)
32de: b3,92,06,56         ldb   R56,[R92+6]      R56 = [TPtr+6];
32e2: 73,72,10,56         an2b  R56,[R72+10]     R56 &= Inj_base;
32e6: df,18               jz    3300             if (R56 != 0)  {                  #
32e8: 97,72,10,56         xorb  R56,[R72+10]     R56 ^= Inj_base;                  # Clear Inj_base flag for cylinder
32ec: c7,72,10,56         stb   R56,[R72+10]     Inj_base = R56;
32f0: 3b,2d,08            jb    B3,R2d,32fb      if (No_fuel_save == 0)  {
32f3: c3,7e,fe,80         stw   R80,[R7e+fe]     [Rtab-2] = HSO_time;
32f7: c7,7e,fd,82         stb   R82,[R7e+fd]     [Rtab-3] = HSO_timeH; }           # Save previous event time
#
32fb: a3,51,06,02,54      ldw   R54,[R50+206]    R54 = [R50+FUELPW1]; }            # Inj Pulse Width in ticks, R50 - port 0 or 2
#
# Jump here from:
#  32e6 (Inj_base for cylinder was off)
#
# R54 = pulse width for bank (may be 0 if Inj_base for cylinder was off)
#
3300: 01,56               clrw  R56              R56 = 0;
3302: 0d,01,54            shldw R54,1            R57:R54 *= 2;                     # why?
3305: 64,54,80            ad2w  R80,R54          HSO_time += R54;
3308: b4,56,82            adcb  R82,R56          HSO_timeH += R56 + CY;
#
# I believe this section is only for the DOL (Tripminder)
#
# R50 (word): Bank (0 or 2)
#
330b: 65,96,01,50         ad2w  R50,196          R50 += &LBMF_INJ1;
330f: a2,50,50            ldw   R50,[R50]        R50 = [R50];                      # Get fuel mass for bank
3312: a3,92,08,54         ldw   R54,[R92+8]      R54 = [TPtr+8];                   # Get cylinder #
3316: 09,01,54            shlw  R54,1            R54 *= 2;
3319: 65,98,01,54         ad2w  R54,198          R54 += &LBMF_INJ2;
331d: c2,54,50            stw   R50,[R54]        [R54] = R50;                      # Store fuel mass for cylinder
3320: 01,52               clrw  R52              R52 = 0;
3322: 67,74,cc,50         ad2w  R50,[R74+cc]     R50 += FUEL_SUM_l;                # Add mass to FUEL_SUM 
3326: b7,74,ce,52         adcb  R52,[R74+ce]     R52 += FUEL_SUM_h + CY;
332a: d5,06               jnv   3332             if (OVF == 1)  {
332c: bd,ff,50            ldsbw R50,ff           R50 = 0xffff;
332f: b1,7f,52            ldb   R52,7f           R52 = 7f; }
3332: c3,74,cc,50         stw   R50,[R74+cc]     FUEL_SUM_l = R50;
3336: c7,74,ce,52         stb   R52,[R74+ce]     FUEL_SUM_h = R52;
#
# End DOL
#
333a: 71,7f,4c            an2b  R4c,7f           No_queue = 0;
333d: f0                  ret                    return;


######################################################################
# Fuel addition for trip computer ? synced 
# Called from HSO #1 interrupt handler when CHANGE_FUELPW == 1
#####################################################################

  Sub9:
333e: 71,7f,48            an2b  R48,7f           CHANGE_FUELPW = 0;
#
# R56 (byte) = injector #
#
3341: 11,56               clrb  R56              R56 = 0;
3343: a1,9c,22,92         ldw   R92,229c         TPtr = 229c;                      # = 22b2 - 16 (see 3352 below)
3347: b3,fc,32,57         ldb   R57,[Rfc+32]     R57 = NUMOUT;                     # 8 - no of injectors
#
# *** RETURN here from call to Sched_HSO() @ 33dd ***
#
334b: 98,56,57            cmpb  R57,R56          
334e: d9,02               jgtu  3352             if ((uns) R57 > R56 ) goto 3352;  # loop end test
3350: 20,8e               sjmp  33e0             return;
#
3352: 65,16,00,92         ad2w  R92,16           TPtr += 16;                       # Bump to next injector OFF event
3356: 17,56               incb  R56              R56++;
#
# R56 (byte): injector #
# R92 (Tptr) (word): Corresponding injector OFF entry in ROM table
#
3358: 43,92,fe,44,00      an3w  R0,R44,[R92+fe]  if (HSOut_Flags & [TPtr-2] == 0) goto 334b;
335d: df,ec               je    334b             
#
335f: 53,92,06,e0,50      an3b  R50,Re0,[R92+6]  R50 = Inj_mode & [TPtr+6];
3364: 98,50,00            cmpb  R0,R50           
3367: d7,1b               jne   3384             if (0 == R50)  {
#
# Injector is off
#
3369: a3,92,08,54         ldw   R54,[R92+8]      R54 = [TPtr+8];                   # cylinder #
336d: 45,da,01,f4,5a      ad3w  R5a,Rf4,1da      R5a = FN1327;                     # Injector Output Port Table
3372: 64,54,5a            ad2w  R5a,R54          R5a += R54;                       # pointer to the bank for entry R92 cyl
3375: ae,5a,50            ldzbw R50,[R5a]        R50 = (uns)[R5a];                 # bank to fire for this cyl
3378: a0,50,54            ldw   R54,R50          R54 = R50;
337b: 65,06,02,50         ad2w  R50,206          R50 += &FUELPW1;
337f: a2,50,50            ldw   R50,[R50]        R50 = [R50];                      # Get pulse width for bank
3382: 20,02               sjmp  3386             goto 3386; }
#
# Jump here from:
#  3367 (injector is on)
#
3384: 01,50               clrw  R50              R50 = 0;
#
# Jump here from:
#  3382 (injector is off)
#
# R50 (word) = pulse width (0 if injector is on)
# R54 (word) = injector bank if injector off (??? if on)
#
3386: 01,52               clrw  R52              R52 = 0;
3388: 0d,01,50            shldw R50,1            R53:R50 *= 2;
338b: af,92,05,7e         ldzbw R7e,[R92+5]      Rtab = (uns)[TPtr+5];
#
# R7e (word) = offset into HSOQ
#
338f: 67,72,0e,50         ad2w  R50,[R72+e]      R50 += PWOFF;
3393: b4,00,52            adcb  R52,R0           R52 += CY;
#
# R52:R50 = pulse width adjusted for injector offset
#
3396: 47,7f,c3,02,50,80   ad3w  R80,R50,[R7e+2c3] HSO_time = R50 + [Rtab+HSOQ-2];  # Calculate next event time from last event
339c: b3,7f,c2,02,82      ldb   R82,[R7e+2c2]    HSO_timeH = [Rtab+HSOQ-3];        # 
33a1: b4,52,82            adcb  R82,R52          HSO_timeH += R52 + CY;
#
# I believe this section is only for the DOL (Tripminder)
#
33a4: a3,92,08,50         ldw   R50,[R92+8]      R50 = [TPtr+8];                   # cyl #
33a8: 09,01,50            shlw  R50,1            R50 *= 2;
33ab: 65,98,01,50         ad2w  R50,198          R50 += LBMF_INJ2;                 # index into cylinder table
33af: 65,96,01,54         ad2w  R54,196          R54 += LBMF_INJ1;                 
33b3: a2,54,54            ldw   R54,[R54]        R54 = [R54];                      # get fuel for bank
33b6: 11,52               clrb  R52              R52 = 0;
33b8: 4a,50,54,5a         sb3w  R5a,R54,[R50]    R5a = R54 - [R50];                # subtract fuel for cylinder
33bc: c2,50,54            stw   R54,[R50]        [R50] = R54;                      # and save back to cylinder
33bf: b8,00,52            sbbb  R52,R0           R52 -= CY;
33c2: 67,74,cc,5a         ad2w  R5a,[R74+cc]     R5a += FUEL_SUM_l;
33c6: b7,74,ce,52         adcb  R52,[R74+ce]     R52 += FUEL_SUM_h + CY;
33ca: d5,06               jnv   33d2             if (signed overflow)  {
33cc: b1,7f,52            ldb   R52,7f           R52 = 7f;
33cf: bd,ff,5a            ldsbw R5a,ff           R5a = 0xffff; }
#
# Jump here from:
#  33ca (!V flag)
#
33d2: c3,74,cc,5a         stw   R5a,[R74+cc]     FUEL_SUM_l = R5a;
33d6: c7,74,ce,52         stb   R52,[R74+ce]     FUEL_SUM_h = R52;
#
# End DOL
#
33da: c9,4b,33            push  334b             push(334b);                       # *** Return to top of loop ***
33dd: e7,7d,f0            jump  245d             goto Sched_HSO;                   # Add for execution in 2284/2C5 Table
#
# Jump here from:
#  3350 (loop exit)
#
33e0: f0                  ret                    return;


################################################################
# update low speed controls - EGR, MIL/STO output, SCCS, CP, Idle Speed(ISC)
# STATIC JUMP from 25f1 (not called as subr) and jumps back to 25f4, so is really part of
# 'HSO Int1' 1ms timer interrupt handler 
################################################################

  HSO_1_continued:
33e1: b1,06,04            ldb   R4,6             AD_Cmd = 6;                       # initiate AD conversion on chan 6 (MAF)
#
# EGR vacuum regulator pulse width modulation
#
33e4: 71,fb,46            an2b  R46,fb           Evr = 0;                          # EGR vac regulator OFF
33e7: 98,00,d3            cmpb  Rd3,R0           
33ea: df,2b               je    3417             if (EGRDC != 0)  {                # Jump if no EGR desired
33ec: b3,74,a6,52         ldb   R52,[R74+a6]     R52 = Egrprf;
33f0: b3,74,a5,54         ldb   R54,[R74+a5]     R54 = Egrctf;
33f4: 99,10,52            cmpb  R52,10           
33f7: db,08               jgeu  3401             if (Egrprf < 10)  {
33f9: 77,74,a4,52         ad2b  R52,[R74+a4]     R52 += EGRPER;                    # Start a new cycle
33fd: b3,74,a3,54         ldb   R54,[R74+a3]     R54 = EGRCNT; }
#
3401: 98,00,54            cmpb  R54,R0           
3404: df,06               je    340c             if (R54 != 0)  {
3406: 91,04,46            orb   R46,4            Evr = 1;                          # EGR vacuum regulator ON
3409: 79,08,54            sb2b  R54,8            R54 -= 8; }
#
340c: 79,10,52            sb2b  R52,10           R52 -= 10;
340f: c7,74,a6,52         stb   R52,[R74+a6]     Egrprf = R52;
3413: c7,74,a5,54         stb   R54,[R74+a5]     Egrctf = R54; }
#
# Idle speed control pulse width modulation
# N.B. ISCDTY will never be 0 while running
#
3417: 71,f7,46            an2b  R46,f7           Isc = 0;                          # ISC OFF (bypass air)
341a: 44,00,b8,50         ad3w  R50,Rb8,R0       R50 = ISCDTY;                     # ISC Duty Cycle
341e: df,0d               je    342d             if (ISCDTY == 0) goto 342d;
3420: 78,51,b7            sb2b  Rb7,R51          Ifreq -= R51;                     # IFREQ -= ISCDTY (high)
3423: db,0a               jgeu  342f             if (Ifreq < 0)  {
3425: 75,80,b7            ad2b  Rb7,80           Ifreq += 80;                      # -ve, set to min ?
3428: 91,08,46            orb   R46,8            Isc = 1;                          # ISC ON
342b: 20,02               sjmp  342f             goto 342f; }
#
342d: 11,b7               clrb  Rb7              Ifreq = 0;                        # No ISC reqd, clear counter
#
# DOL update
# Only useful if trip meter installed (unlikely)
#
342f: 89,01,00,c6         cmpw  Rc6,1                                                                            1.0 us 1.0 us
3433: d1,07               jleu  343c             if ((uns) DOL_COUNT > 1 )  {                                    0.8    1.6 
3435: 05,c6               decw  Rc6              DOL_COUNT--;                                                    0.8
3437: 95,02,46            xorb  R46,2            Dol ^= 1;                         # Toggle DOL flag state       0.8
343a: 20,04               sjmp  3440             goto 3440; }                                                    1.6
#
343c: a1,01,00,c6         ldw   Rc6,1            DOL_COUNT = 1;                                                         1.0
                                                                                                                ----   ----
                                                                                                                 5.0    3.6
#
# STO update
#
3440: 33,d6,6e            jnb   B3,Rd6,34b1      if (Sto_working == 0) goto 34b1;  # skip entire block
3443: 30,d8,0b            jnb   B0,Rd8,3451      if (Sto_holdoff == 1)  {
3446: 91,10,d8            orb   Rd8,10           Sto_pending = 1;
3449: 71,7f,08            an2b  R8,7f            INT_Mask &= 7f;                   # block PIP interrupts
344c: 71,fe,d8            an2b  Rd8,fe           Sto_holdoff = 0;
344f: 20,dd               sjmp  352e             goto 352e; }                      # jump past STO stuff
# Sto_holdoff was 0
3451: 34,d8,15            jnb   B4,Rd8,3469      if (Sto_pending == 0) goto 3469;
3454: 71,ef,d8            an2b  Rd8,ef           Sto_pending = 0;
3457: 91,80,08            orb   R8,80            INT_Mask |= 80;                   # Allow PIP interrupts
345a: b3,76,10,56         ldb   R56,[R76+10]     R56 = Sto_shift_cnt;              # STO shift count (leftmost 1 bit at start)
345e: e0,56,43            djnz  R56,34a4         R56--;
                                                 if (R56 != 0) goto 34a4;          # loop if bits left to output
3461: 71,f7,d6            an2b  Rd6,f7           Sto_working = 0;
3464: 3a,2b,4d            jb    B2,R2b,34b4      if (Sto_trigger == 1) goto 34b4;  # Self Test Output trigger set - to turn off STO
3467: 20,be               sjmp  3527             goto 3527;
#
# Jump here from 3451
# Update Reftime
# Bump ReftimeH if IO_Timer has wrapped since Reftime last updated
3469: 48,8c,06,84         sb3w  R84,R6,R8c       R84 = IO_Timer - Reftime;         # Time difference
346d: 64,84,8c            ad2w  R8c,R84          Reftime += R84;
3470: b4,00,8e            adcb  R8e,R0           ReftimeH += CY;                   # Update 24 bit master reference time
3473: b0,8e,54            ldb   R54,R8e          R54 = ReftimeH;                   # Hi 8 bits of current time
3476: b3,76,0f,55         ldb   R55,[R76+f]      R55 = Sto_high_time;
347a: b0,55,56            ldb   R56,R55          R56 = R55;
347d: 48,8c,da,50         sb3w  R50,Rda,R8c      R50 = Sto_time - Reftime;         # current master time - RDA(STO time)
3481: b8,54,56            sbbb  R56,R54          R56 -= R54 - CY;                  # R56 = STO time - current time (hi bytes)
3484: d7,1c               jne   34a2             if (R56 == 0)  {
3486: 89,e3,04,50         cmpw  R50,4e3          
348a: d9,16               jgtu  34a2             if ((uns) R50 <= 4e3)  {          # jump if time remaining till STO > 3 mS
#
# very close to STO bit time end
348c: 44,50,8c,0e         ad3w  Re,R8c,R50       HSO_Time = Reftime + R50;         # set HSO time
3490: b1,2a,0d            ldb   Rd,2a            HSO_Cmd = 2a;                     # set HSO chan 10 off + interrupt
3493: 67,76,0a,da         ad2w  Rda,[R76+a]      Sto_time += Sto_delay;            # IO time for each trouble code bit at selected output speed
3497: b7,76,0e,55         adcb  R55,[R76+e]      R55 += Sto_high_delay + CY;       # IO time for each trouble code bit at selected output speed
349b: c7,76,0f,55         stb   R55,[R76+f]      Sto_high_time = R55;              # STO high 8 bits time
349f: 91,01,d8            orb   Rd8,1            Sto_holdoff = 1; } }              # set bit 0 of RD8 flag STO HOLDOFF (time to change to next bit? )
#
# still shifting out error codes
34a2: 20,8a               sjmp  352e             goto 352e;
#
# DJNZ at 345E jumps to here
34a4: c7,76,10,56         stb   R56,[R76+10]     Sto_shift_cnt = R56;              # bits remaining to be output
34a8: a3,76,0c,52         ldw   R52,[R76+c]      R52 = Sto_shift;                  # STO SHIFT - shifted trouble code
34ac: 08,01,52            shrw  R52,1            R52 /= 2;                         # next output bit? RIGHT SHIFT? SB left shift
34af: 20,70               sjmp  3521             goto 3521;                        # set STO hi/lo based on R52 bit 0
#
# handle STO/MIL lamp trouble codes output
#
# jump here from 3440
34b1: 32,2b,7a            jnb   B2,R2b,352e      if (Sto_trigger == 1)  {          # jump over STO if Self Test Output trigger clr
34b4: 3d,d6,11            jb    B5,Rd6,34c8      if (Sto_code == 0)  {             # bit to output is set 

# OFF bit 
34b7: 01,52               clrw  R52              R52 = 0;                          # R52 = 0 - set STO off
34b9: 37,d6,02            jnb   B7,Rd6,34be      if (Sto_on == 1)  {
34bc: 07,52               incw  R52              R52++; }                          # R52 = 1 - set STO on
34be: 36,d6,02            jnb   B6,Rd6,34c3      if (Sto_off == 1)  {
34c1: 01,52               clrw  R52              R52 = 0; }                        # R52 = 0 - set STO off
34c3: 71,3f,d6            an2b  Rd6,3f           Sto_off = 0;
                                                 Sto_on = 0;                       # clear STO on and OFF flags
34c6: 20,56               sjmp  351e             goto 351e; }                      # jmp to set STO line hi/lo

# ON bit 
34c8: 71,df,d6            an2b  Rd6,df           Sto_code = 0;                     # clear RD6 bit 5 STO CODE
34cb: 91,08,d6            orb   Rd6,8            Sto_working = 1;                  # set RD6 bit 3 working
34ce: a0,d4,52            ldw   R52,Rd4          R52 = Vip_code;                   # Self Test Trouble code
34d1: b1,10,56            ldb   R56,10           R56 = 10;                         # 16 bit trouble code?
34d4: 31,d9,0d            jnb   B1,Rd9,34e4      if (Goose == 1)  {
34d7: 71,fd,d9            an2b  Rd9,fd           Goose = 0;

# strip off leading zero bits in trouble code RD4
34da: 09,01,d4            shlw  Rd4,1            Vip_code *= 2;                    # RD4 << 1 next bit of trouble code
34dd: db,03               jc    34e2             if ((uns) Vip_code >= 0) goto 34e2; # leftmost 1 bit just shifted out
34df: e0,56,f8            djnz  R56,34da         R56--;
                                                 if (R56 != 0) goto 34da;          # decr 16 bit count of left most 1 bit
34e2: 17,56               incb  R56              R56++; }                          # 'backup' to leftmost one bit
# jump here from 34dd
34e4: c7,76,10,56         stb   R56,[R76+10]     Sto_shift_cnt = R56;              # trouble code bit position (bit position of first != 0 bit)

# select MIL lamp interval time in R50 and R54
34e8: a1,cd,2d,50         ldw   R50,2dcd         R50 = 2dcd;
34ec: b1,03,54            ldb   R54,3            R54 = 3;                          # STO 'slow', 0x32dcd=0.5 secs
34ef: 34,d6,06            jnb   B4,Rd6,34f8      if (Sto_fast == 1)  {
34f2: a1,23,08,50         ldw   R50,823          R50 = 823;
34f6: 11,54               clrb  R54              R54 = 0; }                        # STO 'fast', 0x823=5 millisecs
#
34f8: 34,2c,06            jnb   B4,R2c,3501      if (Sto_hyper == 1)  {
34fb: a1,41,03,50         ldw   R50,341          R50 = 341;
34ff: 11,54               clrb  R54              R54 = 0; }                        # STO 'hyper', 0x341=2 millisecs
#
# Update Reftime
# Bump ReftimeH if IO_Timer has wrapped since Reftime last updated
3501: 48,8c,06,84         sb3w  R84,R6,R8c       R84 = IO_Timer - Reftime;         # master time diff in R84
3505: 64,84,8c            ad2w  R8c,R84          Reftime += R84;
3508: b4,00,8e            adcb  R8e,R0           ReftimeH += CY;
350b: c3,76,0a,50         stw   R50,[R76+a]      Sto_delay = R50;
350f: c7,76,0e,54         stb   R54,[R76+e]      Sto_high_delay = R54;             # STO timer value 
#
# compute time to change STO
3513: 44,50,8c,da         ad3w  Rda,R8c,R50      Sto_time = Reftime + R50;         # time for this next bit (lo 16)
3517: b4,8e,54            adcb  R54,R8e          R54 += ReftimeH + CY;
351a: c7,76,0f,54         stb   R54,[R76+f]      Sto_high_time = R54;              # hi 8 time for this next bit
351e: 71,fb,2b            an2b  R2b,fb           Sto_trigger = 0;                  # allow next bit to queue up
3521: 91,20,46            orb   R46,20           Sto_state = 1;                    # MIL ON
3524: 38,52,03            jb    B0,R52,352a      if (B0_R52 == 0)  {               # trouble code flg
3527: 71,df,46            an2b  R46,df           Sto_state = 0; }                  # MIL OFF
352a: c3,76,0c,52         stw   R52,[R76+c]      Sto_shift = R52; }                # STO bit set for R52 time
#
# Update MAF
#
# Jump here from 34b1
352e: 71,df,2f            an2b  R2f,df           Maf_pip = 0;                      # indicates 1ms timer interrupt
3531: 3f,a1,0d            jb    B7,Ra1,3541      if (CRKFLG == 0)  {               # MAF ignored during crank
3534: 37,09,03            jnb   B7,R9,353a       if (HSI0_Int_Pend == 0) goto 353a; # jmp if no PIP interrupt in the pipeline
3537: 38,0b,07            jb    B0,Rb,3541       if (B0_HSI_Sample == 0)  {        # Pending PIP interrupt is PIP low
#
353a: a3,74,06,52         ldw   R52,[R74+6]      R52 = Last_HSO;                   # Do the 1ms integration
353e: ef,e8,f7            call  2d29             MAF_rd_calc(); } }
#
# Vehicle Speed Control system (VSC)
# Not present on A9L
#
3541: e0,9b,2b            djnz  R9b,356f         Vsc_count--;
                                                 if (Vsc_count != 0) goto 356f;    # VSC Count
3544: 33,c4,0c            jnb   B3,Rc4,3553      if (Vsc_state == 1)  {
3547: b3,74,3a,9b         ldb   R9b,[R74+3a]     Vsc_count = VSC_OFF_COUNT;
354b: 71,fe,46            an2b  R46,fe           SCVAC = 0;                        # Vehicle Speed Control Vacuum Off
354e: 91,10,46            orb   R46,10           SCVNT = 1;                        # Vehicle Speed Control Vent On
3551: 20,0f               sjmp  3562             goto 3562; }
#
3553: b3,74,3b,9b         ldb   R9b,[R74+3b]     Vsc_count = VSC_ON_COUNT;
3557: 36,c4,05            jnb   B6,Rc4,355f      if (Vsc_vac_active == 1)  {       # VSC vacuum active
355a: 95,01,46            xorb  R46,1            SCVAC ^= 1;                       # Toggle Vacuum
355d: 20,03               sjmp  3562             goto 3562; }
#
355f: 95,10,46            xorb  R46,10           SCVNT ^= 1;                       # Toggle Vent
#
3562: 95,08,c4            xorb  Rc4,8            Vsc_state ^= 1;                   # Toggle Vsc_state
3565: 98,9b,00            cmpb  R0,R9b           
3568: d7,05               jne   356f             if (0 == Vsc_count)  {
356a: b1,0a,9b            ldb   R9b,a            Vsc_count = a;
356d: 27,e8               sjmp  3557             goto 3557; } }                    # Loop back
#
# Canister Purge timing (CP)
#
# Jump here from 3541, 3568
356f: 71,fd,47            an2b  R47,fd           Canp = 0;                         # output line 1 OFF (canister purge)
3572: 5b,72,ab,8d,50      sb3b  R50,R8d,[R72+ab] R50 = R8d - Start_purg_per;       # 12B canister purge start period
3577: 9b,72,ad,50         cmpb  R50,[R72+ad]                                       # 12D canister purge on time
357b: d3,0d               jltu  358a             if ((uns) R50 < Purg_on_time) goto 358a;
357d: 9b,72,ae,50         cmpb  R50,[R72+ae]                                       # 12E canister purge period
3581: d3,0a               jltu  358d             if ((uns) R50 >= Purge_period)  {
3583: c7,72,ab,8d         stb   R8d,[R72+ab]     Start_purg_per = R8d;             # 12B canister purge start period
3587: 36,e9,03            jnb   B6,Re9,358d      if (CanPurgeOK == 1)  {           # canister purge enabled clear
#
358a: 91,02,47            orb   R47,2            Canp = 1; } }                     # output line 1 ON (canister purge)
#
358d: e7,64,f0            jump  25f4             goto 25f4;                        # "return" to HSO_1


########################################################
# handle HSI line 2 - BAP sensor
# *** CALLED IN HSI INTERRUPT HANDLER CONTEXT ***
# GUFB p. 19-25
########################################################

  Bap_inth:
3590: 71,fb,87            an2b  R87,fb           Bap_irq = 0;
3593: 4b,74,02,7a,50      sb3w  R50,R7a,[R74+2]  R50 = Event_time - MINTIM1;      # time of last read
3598: c3,72,8a,50         stw   R50,[R72+8a]     MDELTA = R50;                    # delta time since last BP read
359c: c3,74,02,7a         stw   R7a,[R74+2]      MINTIM1 = Event_time;            # update last time read
35a0: b0,b6,50            ldb   R50,Rb6          R50 = BAPCNT;
35a3: 17,50               incb  R50              R50++;
35a5: c4,b6,50            stb   R50,Rb6          BAPCNT = R50;                    # why not just incb directly ?
35a8: 91,40,4e            orb   R4e,40           NEW_BAP = 1;                     # set flag to zero BAPTMR in bkgnd
35ab: f0                  ret                    return;


########################################################
# Byte function lookup with interpolate 
# handles all 4 combinations of signed and unsigned in/out values
# IN R32 func address (pointer to first X value, X0)
# IN R34 input value
# IN REE bit 4 (Signdy) 1 = signed input
# IN REE bit 5 (Signdslp) 1 = signed output
# OUT R38 = func(R34) as byte
########################################################

# Signed in, unsigned out
  subyteLU:
35ac: 91,20,ee            orb   Ree,20           Signdslp = 1;                     # signed input
35af: 20,06               sjmp  35b7             goto UUbyteLu;

# Signed in, signed out
  SSByteLU:
35b1: 91,20,ee            orb   Ree,20           Signdslp = 1;                     # signed input

# Unsigned in, signed out
  USByteLU:
35b4: 91,10,ee            orb   Ree,10           Signdy = 1;                       # signed output

# Unsigned in, unsigned out
# Base routine
  UUbyteLu:
35b7: 9b,32,02,34         cmpb  R34,[R32+2]                                        
35bb: 3d,ee,04            jb    B5,Ree,35c2      if (Signdslp == 1) goto 35c2;      # Signed input
35be: db,0a               jgeu  35ca             if (R34 > [R32+2])  {
35c0: 20,02               sjmp  35c4             goto 35c4;

35c2: d6,06               jge   35ca             if (R34 < [R32+2])  {
35c4: 65,02,00,32         ad2w  R32,2            R32 += 2;
35c8: 27,ed               sjmp  35b7             goto UUbyteLu; } }

35ca: 71,df,ee            an2b  Ree,df           Signdslp = 0;                     # Use below for result
35cd: b2,33,36            ldb   R36,[R32++]      R36 = [R32++];                    # Get values above and below i/p val
35d0: b2,33,38            ldb   R38,[R32++]      R38 = [R32++];
35d3: 7a,32,36            sb2b  R36,[R32]        R36 -= [R32];
35d6: 7a,33,34            sb2b  R34,[R32++]      R34 -= [R32++];
35d9: 7a,32,38            sb2b  R38,[R32]        R38 -= [R32];
35dc: 3c,ee,04            jb    B4,Ree,35e3      if (Signdy == 1) goto 35e3;
35df: db,09               jgeu  35ea             if (R38 > 0)  {
35e1: 20,02               sjmp  35e5             goto 35e5;

35e3: d6,05               jge   35ea             if (R38 < 0)  {                   # Negative - remember
35e5: 91,20,ee            orb   Ree,20           Signdslp = 1;
35e8: 13,38               negb  R38              R38 = -R38; } }
35ea: 7c,34,38            ml2b  R38,R34          R38 *= R34;
35ed: 9c,36,38            divb  R38,R36          R38 /= R36;
35f0: 35,ee,02            jnb   B5,Ree,35f5      if (Signdslp == 1)  {             # Negative, fix sign
35f3: 13,38               negb  R38              R38 = -R38; }
35f5: 76,32,38            ad2b  R38,[R32]        R38 += [R32];                     # add interpolated delta
35f8: 11,39               clrb  R39              R39 = 0;
35fa: 71,df,ee            an2b  Ree,df           Signdslp = 0;
35fd: 71,ef,ee            an2b  Ree,ef           Signdy = 0;                       # cleanup
3600: f0                  ret                    return;


#############################################################
# Word function lookup - as byte logic (but word instructions)
# IN R32 func address (pointer to first X value, X0)
# IN R34 input value
# OUT R38 = func(R34) as word
#############################################################

# Signed input, unsigned output
  SUWordLU:
3601: 91,20,ee            orb   Ree,20           Signdslp = 1;
3604: 20,06               sjmp  360c             goto UUWordLu;

# Signed input, signed output
  SSWordLU:
3606: 91,20,ee            orb   Ree,20           Signdslp = 1;
3609: 91,10,ee            orb   Ree,10           Signdy = 1;

# Base routine, also entry point for unsigned in -> unsigned out
  UUWordLu:
360c: 8b,32,04,34         cmpw  R34,[R32+4]      
3610: 3d,ee,04            jb    B5,Ree,3617      if (Signdslp == 1) goto 3617;
# See if R34 is in this segment of the table (unsigned)
3613: db,0a               jgeu  361f             if ((unsigned) R34 > X(n+1))  {
3615: 20,02               sjmp  3619             goto 3619;

# See if R34 is in this segment of the table (signed)
3617: d6,06               jge   361f             if ((unsigned) R34 < X(n+1))  {

# Continue to next segment
3619: 65,04,00,32         ad2w  R32,4            R32 += 4;          # n++
361d: 27,ed               sjmp  360c             goto UUWordLu; } }

# Found the segment
# R32 -> low X value of segment (Xn)
# R34 = input X
361f: 71,df,ee            an2b  Ree,df           Signdslp = 0;
3622: a2,33,36            ldw   R36,[R32++]      R36 = [R32++];     # Xn
3625: a2,33,38            ldw   R38,[R32++]      R38 = [R32++];     # Yn
3628: 6a,32,36            sb2w  R36,[R32]        R36 -= [R32];      # Xn - X(n+1)
362b: 6a,33,34            sb2w  R34,[R32++]      R34 -= [R32++];    # In - X(n+1)
362e: 6a,32,38            sb2w  R38,[R32]        R38 -= [R32];      # Yn - Y(n+1)
3631: 3c,ee,04            jb    B4,Ree,3638      if (Signdy == 1) goto 3638;
3634: db,09               jgeu  363f             if ((unsigned) R38 > 0)  {
3636: 20,02               sjmp  363a             goto 363a;

3638: d6,05               jge   363f             if ((signed) R38 < 0)  {
#
363a: 91,20,ee            orb   Ree,20           Signdslp = 1;
363d: 03,38               negw  R38              R38 = -R38; } }
#
363f: 6c,34,38            ml2w  R38,R34          R3b:R38 = R39:R38 * R35:R34;
3642: 8c,36,38            divw  R38,R36          R39:R38 = R3b:R38 / R37:R36;
3645: 35,ee,02            jnb   B5,Ree,364a      if (Signdslp == 1)  {
3648: 03,38               negw  R38              R38 = -R38; }
364a: 66,32,38            ad2w  R38,[R32]        R38 += [R32];
364d: 71,df,ee            an2b  Ree,df           Signdslp = 0;
3650: 71,ef,ee            an2b  Ree,ef           Signdy = 0;
3653: f0                  ret                    return;


###################################################################
# Filter (rolling average) routine - signed and unsigned variants #
# GUFB pp. 19-46, 19-47                                           #
###################################################################

#
# Urolav_3Arg loads 3 params, old average, new value, and time constant,
# from locations pointed to by the words following the call location
# 
  Urolav_3Arg:
3654: 28,3f               scall 3695             Get_par();
3656: a2,3c,32            ldw   R32,[R3c]        R32 = [R3c];                      # OLD average
3659: 28,3a               scall 3695             Get_par();
365b: a2,3c,34            ldw   R34,[R3c]        R34 = [R3c];                      # NEW sensor value

#
# Urolav_1Arg loads 1 parameter, the time constant, into R36
# from location pointed to by word following call location
#
  Urolav_1Arg:
365e: 28,35               scall 3695             Get_par();
3660: a2,3c,36            ldw   R36,[R3c]        R36 = [R3c];                      # time constant
#
# Unsigned rolling average
#
# R32 (word) = old average
# R34 (word) = new value
# R36 (word) = time constant
# If Asp_input (flag) = 1, sample period = R3e (word);
#                     else sample period = Bg_timer (byte)
#
  Urolav:
3663: 28,53               scall 36b8             Calc_FConst();                    # R36 = period / (1 + TC/period)

#
# R36 (word) = filter constant, scaled so 0xffff = 0.999998...
#
# Called only from Chk_HEGO, a KOER self-test routine,
#  after Urolav has calculated the filter factor in a previous call
#
  Urolav_1:
3665: b1,02,42            ldb   R42,2            R42 = 2;                          # flag as unsigned
3668: 20,04               sjmp  366e             goto 366e;

#
# Signed rolling average
#
# R32 (word) = old average
# R34 (word) = new value
# R36 (word) = time constant
# If Asp_input (flag) = 1, sample period = R3e (word);
#                     else sample period = Bg_timer (byte)
# 
  Rolav:
366a: 28,4c               scall 36b8             Calc_FConst();                    # R36 = period / (1 + TC/period)
366c: 11,42               clrb  R42              R42 = 0;                          # flag as signed
#
# Jump here from:
#  3668 (unsigned entry, R42 = 2)
#
# R36 (word) = filter constant, scaled so 0xffff = 0.999998...
# B1_R42 = 0 if signed, 1 if unsigned
#
366e: 48,32,34,3c         sb3w  R3c,R34,R32      R3c = R34 - R32;                  # difference (new - average)
3672: 31,42,04            jnb   B1,R42,3679      if (B1_R42 == 0) goto 3679;       # jump if signed 
3675: db,08               jgeu  367f             else if (R3c >- 0) goto 367f;     # jump if non -ve result (unsigned)
3677: 20,02               sjmp  367b             else goto 367b;                   # effectively -ve result (unsigned)
#
# Jump here from:
#  3672 (signed)
#
3679: d6,04               jge   367f             if (R3c >= 0) goto 367f;          # jmp if difference is non-negative
#
# Jump here from:
#  3675 (unsigned, delta was negative)
#
# R3c (word) = new value - old avg 
# Take absolute value
#
367b: 17,42               incb  R42              R42++;                            # set bit 0 - neg delta flag
367d: 03,3c               negw  R3c              R3c = -R3c;                       # reverse diff, so ABS (diff)
#
# Jump here from:
#  3675 (unsigned, delta was non-negative)
#  3679 (signed,   delta was non-negative)
#  
367f: 6c,36,3c            ml2w  R3c,R36          R3f:R3c = R3d:R3c * R37:R36;      # ABS(diff) * R36(filter factor)
                                                                                   # *** N.B. Unsigned multiply ***
3682: 03,3e               negw  R3e              R3e = -R3e;                       # neg scaled diff Hi 16 bits
3684: d7,06               jne   368c             if (R3e != 0) goto 368c;          # jmp if scaled diff > 0000FFFF
3686: 03,3c               negw  R3c              R3c = -R3c;                       # neg scaled diff LO 16 bits
3688: df,07               je    3691             if (R3c != 0)  {                  # jmp - scaled diff is ZERO
368a: 05,3e               decw  R3e              R3e--;                            # any fraction to next whole num
#
368c: 38,42,02            jb    B0,R42,3691      if (B0_R42 == 0)  {               # If delta was negative, 
368f: 03,3e               negw  R3e              R3e = -R3e; } }                   #  negate scaled delta
#
3691: 64,32,3e            ad2w  R3e,R32          R3e += R32;                       # add filtered diff to old AD value (in R3E)
3694: f0                  ret                    return;


#############################################################
# Get a caller's WORD param and increment return address
# can be called more than once (see above)
# If positive, returned as is.
# If top bit set, map to ROM.  All calls in this bin are D0nn
# which maps to [f8] + nn as word address to look up 
# Range used is D040 (at 5400) to D060 (at 410c) which gives actual 
# ROM addresses of 97E8-9808
# return R3c with lookup ADDRESS
#
# Inputs:
#   R10     Stack pointer        
# Outputs:
#   R3C     Address of desired parameter
#   Return address of caller in stack modified to point past parameter
# Clobbers: R38-R3b
#############################################################

  Get_par:
3695: cc,38               pop   R38              R38 = pop();                      # This subroutine's return addr
3697: cc,3a               pop   R3a              R3a = pop();                      # Caller subroutine's return addr
3699: b2,3b,3c            ldb   R3c,[R3a++]      R3c = [R3a++];
369c: b2,3b,3d            ldb   R3d,[R3a++]      R3d = [R3a++];                    # 3C = Word param from caller
369f: c8,3a               push  R3a              push(R3a);                        # restore caller address (+2)
36a1: c8,38               push  R38              push(R38);                        # restore this return address
36a3: 37,3d,11            jnb   B7,R3d,36b7      if (B7_R3d == 0) return;           # return unchanged if top bit clear
36a6: ac,3d,38            ldzbw R38,R3d          R38 = (uns)R3d;                   # = f0 register offset (R3c top byte)
36a9: 71,0f,3d            an2b  R3d,f            R3d &= f;                         # clear reg offset (top nibble) 
36ac: 18,03,38            shrb  R38,3            R38 /= 8;                         # top nibble down 3 (reg offset * 2) 
36af: 71,fe,38            an2b  R38,fe           R38 &= fe;                        # force even for register offset
36b2: 67,39,e0,00,3c      ad2w  R3c,[R38+e0]     R3c += [R38+e0]; }                # return  (param & fff)+[e0+x*2]
36b7: f0                  ret                    return;


##############################################################
# Calculate filter constant for Rolling Average filters
# GUFB p. 19-46 (top)
# 
# Inputs:
#  R36 (word) = time constant (TC)
#  Asp_input (flag): where to get sample period
#  Asp_input flag is used only for FAM (idle airflow) filtering,
#   0: zero extend Bg_timer (byte) to word
#   1: use R3E (word) 
#   Interval is in msec
#
# Output:
#  R36 (word) = 1 / (1 + Time constant / sample period)
#               as binary fraction (0xffff = .999998...)
#               Result is ALWAYS < 1.0 by definition
#
# Clobbers: R3c-R3f, ZNVC flags
#############################################################

  Calc_FConst:
36b8: 38,ca,04            jb    B0,Rca,36bf      if (Asp_input == 0)  {
36bb: af,74,5e,3e         ldzbw R3e,[R74+5e]     R3e = (uns)Bg_timer; }            # Background Loop Timer (msec)
#
36bf: 71,fe,ca            an2b  Rca,fe           Asp_input = 0;
36c2: 01,3c               clrw  R3c              R3c = 0;
36c4: 64,3e,36            ad2w  R36,R3e          R36 += R3e;                       # TC + timer
36c7: d3,03               jnc   36cc             if (unsigned overflow)  {
36c9: bd,ff,36            ldsbw R36,ff           R36 = 0xffff; }                   # clip to max FF
36cc: 8c,36,3c            divw  R3c,R36          R3d:R3c = R3f:R3c / R37:R36;
36cf: d5,03               jnv   36d4             if (OVF == 1)  {
36d1: bd,ff,3c            ldsbw R3c,ff           R3c = 0xffff; }                   # clip to max on divide overflow
36d4: a0,3c,36            ldw   R36,R3c          R36 = R3c;
36d7: f0                  ret                    return;


#############################################################
# 2 Dimensional Table lookup with 3 way interpolate (2 vars X and Y)
# Signed and unsigned
# Inputs:
#  R30 (byte) = X value. (column)   
#  R32 (byte) = Y value  (row)
#  R34 (byte) is Table width (no of columns)
#  R35 better be 0!!
#  R38 (word) is the Table pointer
# Outputs:
#  R3B (byte) = result of lookup after interpolation
#############################################################

36d8: 91,80,2d            ??                                                       # Signed scaled Table (not used)

  UTabLu16:
36db: 11,31               clrb  R31              R31 = 0;                          # scale up by 16
36dd: 09,04,30            shlw  R30,4            R30 *= 10;                        # R30 (word) = Byte param A * 16
36e0: 11,33               clrb  R33              R33 = 0;
36e2: 09,04,32            shlw  R32,4            R32 *= 10;                        # R32 (word) = Byte param B * 16
36e5: 20,03               sjmp  36ea             goto UTabLookUp;
#
# Signed entry point
#
  STabLookup:
36e7: 91,80,2d            orb   R2d,80           Tblsflg = 1;                      # Set table signed flag
#
# Unsigned entry point
# R30 (word) = X (column) value   'whole' in top byte (R31), fraction in lower (R30)
# R32 (word) = Y (row) value      'whole' in top byte (R33), fraction in lower (R32)
#
  UTabLookUp:
36ea: 5c,33,34,36         ml3b  R36,R34,R33      R36 = R34 * R33;                  # R36 = offset of row in R33
36ee: 74,31,36            ad2b  R36,R31          R36 += R31;                       #     + offset of column in R31
36f1: d3,02               jnc   36f5             if ((uns) R36 >= 0)  {
36f3: 17,37               incb  R37              R37++; }                          # Handle add overflow
#
# R30 (byte) = X interpolation fraction
# R32 (byte) = Y interpolation fraction
# R34 (word?) = # of columns
# R36 (word) = offset to desired table entry
# R38 (word) -> table base
#
36f5: 64,36,38            ad2w  R38,R36          R38 += R36;                       # Get table entry address
# R38 (word) -> entry for floor(x), floor(y)
36f8: b2,39,31            ldb   R31,[R38++]      R31 = [R38++];                    # R31 = T[floor(x),floor(y)]
36fb: b2,38,33            ldb   R33,[R38]        R33 = [R38];                      # R33 = T[ceil(x) ,floor(y)]
36fe: 28,1f               scall 371f             TabInterp();                      # Perform column interpolation for floor(y)
3700: 64,34,38            ad2w  R38,R34          R38 += R34;
3703: b2,38,33            ldb   R33,[R38]        R33 = [R38];                      # R33 = T[ceil(x) ,ceil(y) ]
3706: 05,38               decw  R38              R38--;
3708: b2,38,31            ldb   R31,[R38]        R31 = [R38];                      # R31 = T[floor(x),ceil(y) ]
370b: b0,3b,34            ldb   R34,R3b          R34 = R3b;                        # Stash result of first interpolation
370e: 28,0f               scall 371f             TabInterp();                      # Perform column interpolation for ceil(y)
3710: b0,3b,33            ldb   R33,R3b          R33 = R3b;                        # Perform interpolation between rows for X
3713: b0,34,31            ldb   R31,R34          R31 = R34;
3716: b0,32,30            ldb   R30,R32          R30 = R32;
3719: 28,04               scall 371f             TabInterp();                      # Result is now in R3B
371b: 71,7f,2d            an2b  R2d,7f           Tblsflg = 0;                      # Clear signed table flag
371e: f0                  ret                    return;


#############################################################
# 1 dimension interpolate - signed or unsigned
# Inputs:
#  R30 (byte) - Fraction
#  R31 (byte) - Lower table value
#  R33 (byte) - Upper table value
# Outputs:
#  R3B - Interpolated result (byte?)
#############################################################

  TabInterp:
371f: 37,2d,1a            jnb   B7,R2d,373c      if (Tblsflg == 0) goto 373c;
# SIGNED interpolate calc
3722: bc,33,3a            ldsbw R3a,R33          R3a = (int)R33;
3725: bc,31,3c            ldsbw R3c,R31          R3c = (int)R31;                   
3728: 68,3c,3a            sb2w  R3a,R3c          R3a -= R3c;                       # R3A (word) = R33 - R31 
372b: ac,30,3c            ldzbw R3c,R30          R3c = (uns)R30;
372e: fe,6c,3a,3c         sml2w R3c,R3a          R3f:R3c = R3d:R3c * R3b:R3a;      # R3C (dword) = R30 * (R33 - R31)
3732: c0,3a,3c            stw   R3c,R3a          R3a = R3c;                        # R3A (word) = R3C (word)
3735: 74,31,3b            ad2b  R3b,R31          R3b += R31;                       # R3B (byte) = R30 * (R33 - R31) + R31
3738: 37,3b,0f            jnb   B7,R3b,374a      if (B7_R3b == 1)  {                
373b: f0                  ret                    return;
# UNSIGNED interpolate calc
373c: 5c,33,30,3a         ml3b  R3a,R30,R33      R3a = R30 * R33;                  
3740: 5c,31,30,36         ml3b  R36,R30,R31      R36 = R30 * R31;
3744: 68,36,3a            sb2w  R3a,R36          R3a -= R36;                       # R3A = (R30 * R33) - (R30 * R31)
3747: 74,31,3b            ad2b  R3b,R31          R3b += R31; }                     #                          + R31
#
374a: 65,80,00,3a         ad2w  R3a,80           R3a += 80;                        # Sign adjust
374e: f0                  ret                    return;


#############################################################
#
# Parameters: R30 - pointer to list of 5 time thresholds, sec.:
#              + 0:  ATMR1 time delay for hot start
#              + 1:  ATMR1 time delay for medium start
#              + 2:  ATMR2 time delay for medium start
#              + 3:  ATMR1 time delay for cold start
#              + 4:  ATMR2 time delay for cold start
#             ATMR1 - time since start, sec.
#             ATMR2 - time since ECT > TEMPFB, sec.
#             TCSTRT - temperature at startup
#
# Returns: Carry set if not enough time elapsed, cleared otherwise.
#
# See (e.g) WRMEGO logic on GUFB p. 6-12
#############################################################

  Check_Timers:
374f: 9b,fe,04,ad         cmpb  Rad,[Rfe+4]      
3753: de,07               jlt   375c             if (TCSTRT < CTHIGH) goto 375c;
# TCSTRT >= CTHIGH
3755: 9a,30,c8            cmpb  Rc8,[R30]        
3758: d3,2a               jltu  3784             if ((uns) ATMR1 >= [R30])  {
# ATMR1 > threshold 0
375a: 20,26               sjmp  3782             goto 3782;

# TCSTRT < CTHIGH
375c: 07,30               incw  R30              R30++; # Point to threshold 1
375e: 9b,fe,05,ad         cmpb  Rad,[Rfe+5]      
3762: da,0e               jle   3772             if (TCSTRT <= CTLOW) goto 3772;

# CTLOW < TCSTRT < CTHIGH
3764: 9a,30,c8            cmpb  Rc8,[R30]        
3767: d3,1b               jltu  3784             if ((uns) ATMR1 >= [R30])  {

# ATMR1 >= threshold 1
3769: 07,30               incw  R30              R30++; # Point to threshold 2
376b: 9a,30,c9            cmpb  Rc9,[R30]        
376e: d3,14               jltu  3784             if ((uns) ATMR2 >= [R30])  {

# ATMR2 >= threshold 2
3770: 20,10               sjmp  3782             goto 3782;

# TCSTRT <= CTLOW
# R30 -> threshold 1
3772: 07,30               incw  R30              R30++;
3774: 07,30               incw  R30              R30++;  # Point to threshold 3
3776: 9a,30,c8            cmpb  Rc8,[R30]        
3779: d3,09               jltu  3784             if ((uns) ATMR1 >= [R30])  {

# ATMR1 >= threshold 4
377b: 07,30               incw  R30              R30++;  # Point to threshold 4
377d: 9a,30,c9            cmpb  Rc9,[R30]        
3780: d3,02               jltu  3784             if ((uns) ATMR2 >= [R30])  {

# Timer at or above threshold 
3782: f8                  clc                    CY = 0
3783: f0                  ret                    return; } } } } }

# Timer below threshold
3784: f9                  stc                    CY = 1
3785: f0                  ret                    return;


#################################################################
# Set RPM Flags mode - cranking, underspeed. run etc
# Background task
# GUFB doc pp. 4-4, 4-5
# Inputs:
#  Rae (word) - N
# In/out:
#  R2d bit 1  - Undsp_trans
#  Ra1 bit 2  - UNDSP
#  Ra1 bit 7  - CRKFLG
#  Rb4 (byte) - PIPCNT
#  ECTCNT
# Out:
#  R2f bit 5  - PTSCR
#  Rac (byte) - TCSTRL
#  Rad (byte) - TCSTRT
#  Re9 bit 4  - Crnk_trans
# Clobbers: R14, R30-31
#  
#################################################################

  set_rpm_flgs:
3786: 71,ef,e9            an2b  Re9,ef           Crnk_trans = 0;
3789: 37,a1,21            jnb   B7,Ra1,37ad      if (CRKFLG == 0) goto Not_Cranking;
#
# CRKFLG was set at entry
# Logic at top of GUFB p. 4-5
#
378c: 8b,fa,1a,ae         cmpw  Rae,[Rfa+1a]     if ((uns) N <= NRUN)              # (225 RPM) 
3790: d1,14               jleu  37a6                goto 37a6;
#
# N > NRUN
# Prepare to transition out of CRANK mode
#
3792: b1,08,14            ldb   R14,8            R14 = 8;
3795: 9b,74,e7,14         cmpb  R14,[R74+e7]     
3799: d9,09               jgtu  37a4             if ((uns) 8 <= ECTCNT)  {         # ECTCNT < 8 ?
379b: 9b,fa,14,b4         cmpb  Rb4,[Rfa+14]     
379f: d3,03               jltu  37a4             if ((uns) PIPCNT >= NCNT)  {
#
# N > NRUN && ECTCNT >= 8 && PIPCNT >= NCNT
# Transition out of CRANK
#
37a1: 71,7f,a1            an2b  Ra1,7f           CRKFLG = 0; } }
#
# Jump here from:
#  3799 (ECTCNT < 8)
#  379f (PIPCNT < NCNT)
#
37a4: 20,40               sjmp  37e6             goto Set_UNDSP; }
#
# Jump here from:
#  3790 (CRKFLG && N <= NRUN)
#
# Not eligible to transition out of CRANK until N > NRUN
# Reset PIPCNT (GUFB p. 19-39)
# Reset PTSCR (GUFB p. 5-4)
#
37a6: 11,b4               clrb  Rb4              PIPCNT = 0;                       # RPM <= 225
37a8: 71,ef,2f            an2b  R2f,ef           PTSCR = 0;
37ab: 20,39               sjmp  37e6             goto Set_UNDSP;                   # set underspeed and exit
#
# Jump here from:
#  3789 (!CRKFLG)
#
# Logic at middle of GUFB p. 4-5
#
  Not_Cranking:
37ad: 11,b4               clrb  Rb4              PIPCNT = 0;
37af: 8b,fa,1c,ae         cmpw  Rae,[Rfa+1c]     
37b3: db,11               jgeu  37c6             if (N < NSTALL)  {
37b5: 91,80,a1            orb   Ra1,80           CRKFLG = 1;                       # RPM < 50
37b8: 91,10,e9            orb   Re9,10           Crnk_trans = 1;
37bb: c7,74,e7,00         stb   R0,[R74+e7]      ECTCNT = 0;
37bf: 01,ac               clrw  Rac              TCSTRL = 0, TCSTRT = 0;
37c1: 71,ef,2f            an2b  R2f,ef           PTSCR = 0;                        # set cranking and other flags
37c4: 20,20               sjmp  37e6             goto Set_UNDSP; }
#
# Jump here from:
#  37b3 (!CRKFLG && N >= NSTALL)
#
# Logic at bottom of GUFB p. 4-5
#
37c6: a3,fa,16,30         ldw   R30,[Rfa+16]     R30 = UNRPM;                      # cranking not set, RPM >= 50
37ca: 88,ae,30            cmpw  R30,Rae          
37cd: d1,02               jleu  37d1             if ((uns) UNRPM <= N) goto 37d1;
37cf: 20,15               sjmp  37e6             goto Set_UNDSP;                   # RPM < 200, Underspeed limit low, set underspeed
#
# !CRKFLG && N >= NSTALL && N >= UNRPM
#
37d1: 67,fa,18,30         ad2w  R30,[Rfa+18]     R30 += UNRPMH;                    # R30 = UNRPM + UNRPMH
37d5: 88,ae,30            cmpw  R30,Rae          
37d8: db,0a               jgeu  37e4             if (UNRPM + UNRPM < N)  {         # RPM < 300, Underspeed limit high, exit
#
# N > UNRPM + UNRPMH, i.e. run mode
#
37da: fa                  di                     disable ints;
37db: ff                  nop                    
37dc: 32,a1,05            jnb   B2,Ra1,37e4      if (UNDSP == 1)  {
37df: 71,fb,a1            an2b  Ra1,fb           UNDSP = 0;                        # RPM > 300 clear underspeed if set 
37e2: 20,0a               sjmp  37ee             goto 37ee; } }
#
# Jump here from:
#  37d8 (UNRPM + UNRPMH >= N)
#  37dc (UNRPM + UNRPMH < N && !UNDSP, i.e. run mode)
# 
37e4: fb                  ei                     enable ints;
37e5: f0                  ret                    return;
#
# Jump here from:
#  37a4 (CRKFLG && N > NRUN && (ECTCNT < 8 || PIPCNT < NCNT))
#  37ab (CRKFLG && N <= NRUN)
#  37c4 (!CRKFLG && N < NSTALL, CRKFLG 0 -> 1 transition)
#  37cf (!CRKFLG && N < UNRPM)
#
# Enter underspeed if not already in it
#
  Set_UNDSP:
37e6: fa                  di                     disable ints;
37e7: ff                  nop                    
37e8: 3a,a1,06            jb    B2,Ra1,37f1      if (UNDSP == 0)  {
37eb: 91,04,a1            orb   Ra1,4            UNDSP = 1;                        # set underspeed if necessary
#
# Fall through, UNDSP 0 -> 1 transition
# 
# Jump here from:
#  37e2 (UNRPM + UNRPMH < N && UNDSP 1 -> 0 transition)
#
37ee: 91,02,2d            orb   R2d,2            Undsp_trans = 1; }                # UNDSP changed state
#
37f1: fb                  ei                     enable ints;
37f2: f0                  ret                    return;


#################################################################
# Update Throttle flags (RAA is Throttle position)
# GUFB pp. 5-3, 5-4
#################################################################

  Update_WOT:
37f3: 71,7f,e9            an2b  Re9,7f           CTPTFG = 0;
37f6: a3,72,a6,36         ldw   R36,[R72+a6]     R36 = RATCH;
37fa: 47,fa,02,36,38      ad3w  R38,R36,[Rfa+2]  R38 = RATCH + DELTA;
37ff: db,3a               jc    383b             if (unsigned overflow) goto 383b; # Treat as throttle closed
3801: 88,38,aa            cmpw  Raa,R38          
3804: d1,35               jleu  383b             if ((uns) TP <= RATCH + DELTA) goto 383b;

# Throttle above RATCH + DELTA, is it high enough to enter PT?
3806: 67,fa,06,38         ad2w  R38,[Rfa+6]      R38 += HYSTS;
380a: db,05               jc    3811             if (unsigned overflow) goto 3811;
380c: 88,38,aa            cmpw  Raa,R38          
380f: d9,03               jgtu  3814             if ((uns) TP > R38) goto 3814;    # TP > RATCH + DELTA + HYSTS

# RATCH + DELTA < TP <= RATCH + DELTA + HYSTS (failed to clear hysteresis)
3811: 3f,d0,39            jb    B7,Rd0,384d      if (APT < 0) return;              # No change if was closed last pass
#
# Throttle is open, was it on last pass?
3814: 37,d0,03            jnb   B7,Rd0,381a      if (APT < 0)  {

# Throttle was closed, now is open - set closed-part throttle transition flag
3817: 91,80,e9            orb   Re9,80           CTPTFG = 1; }

# Throttle is open
381a: 67,fa,08,36         ad2w  R36,[Rfa+8]      R36 = RATCH + THBP2;              # WOT breakpoint
381e: db,22               jc    3842             if (unsigned overflow) goto 3842;
3820: 88,36,aa            cmpw  Raa,R36          
3823: d1,1d               jleu  3842             if ((uns) TP > RATCH + THBP2)  {

# Is throttle above WOT + hysteresis?
3825: 67,fa,04,36         ad2w  R36,[Rfa+4]      R36 += HYST2
3829: db,05               jc    3830             if (unsigned overflow) goto 3830;
382b: 88,36,aa            cmpw  Raa,R36          
382e: d9,04               jgtu  3834             if ((uns) TP > R36) goto 3834;    # set WOT

# Throttle open
3830: 3f,d0,0f            jb    B7,Rd0,3842      if (APT >= 0)  {
# No change (APT = 0 or APT == 1)
3833: f0                  ret                    return;

# TP > RATCH + THBP2 + HYST2; set WOT
3834: b1,01,d0            ldb   Rd0,1            APT = 1;
3837: 91,01,24            orb   R24,1            Wot = 1;
383a: f0                  ret                    return;

# Set throttle closed
383b: b1,ff,d0            ldb   Rd0,-1           APT = -1;
383e: 71,fe,24            an2b  R24,fe           Wot = 0;
3841: f0                  ret                    return; } } }

# Jump here from 381e (RATCH + THBP2 overflowed),
# 3823 (TP <= RATCH + THBP2),
# 3830 (RATCH + THBP2 < TP <= RATCH + THBP2 + HYST2 and APT < 0)
# At Part Throttle
# PTSCR logic (Part Throttle Since CRank)
3842: 3f,a1,03            jb    B7,Ra1,3848      if (CRKFLG == 0)  {
3845: 91,10,2f            orb   R2f,10           PTSCR = 1; }
#
3848: 11,d0               clrb  Rd0              APT = 0;
384a: 71,fe,24            an2b  R24,fe           Wot = 0; }
#
# Jump here from 3811 (TP <= RATCH + DELTA + HYSTS and APT < 0)
384d: f0                  ret                    return;


#################################################################
# Background routine
# Clean up raw A/D inputs 
#################################################################

  Update_AD:
384e: 36,e6,19            jnb   B6,Re6,386a      if (Pfehp_flg == 0) goto 386a;     # PFE EGR, skip EVP processing
#
# PFE EGR FMEM
# GUFB p. 21-16
#
3851: 36,c5,05            jnb   B6,Rc5,3859      if (EFMFLG == 1)  {
3854: 91,04,c5            orb   Rc5,4            PEFMFG = 1;
3857: 20,30               sjmp  3889             goto 3889; }                      # skip EVP processing
#
3859: 32,c5,2d            jnb   B2,Rc5,3889      if (PEFMFG == 1)  {               # skip EVP update
385c: a1,80,a2,30         ldw   R30,a280 
3860: c3,01,ee,07,30      stw   R30,[R0+7ee]     EPTZER = a280;                    # filtered EVP saved in KAM
3865: 71,fb,c5            an2b  Rc5,fb           PEFMFG = 0;
3868: 20,1f               sjmp  3889             goto 3889;                        # go to ACT test
#
# Sonic EGR range check
# GUFB p. 21-17
#
386a: 3e,c5,14            jb    B6,Rc5,3881      if (EFMFLG == 1) goto 3881;       # EVP failed, use default value
386d: a3,72,96,30         ldw   R30,[R72+96]     R30 = IEVP;                       # Raw EVP A/D reading
3871: 8b,f3,b2,00,30      cmpw  R30,[Rf2+b2]     
3876: d9,11               jgtu  3889             if ((uns) R30 <= EVPMAX)  {
3878: 8b,f3,b0,00,30      cmpw  R30,[Rf2+b0]     
387d: db,06               jgeu  3885             if ((uns) R30 >= EVPMIN) goto 3885; # OK, use as new value
387f: 20,08               sjmp  3889             goto 3889;                        # go to ACT test
#
3881: a3,72,a8,30         ldw   R30,[R72+a8]     R30 = EOFF;                       # Default EVP ? 128
#
3885: c3,72,f0,30         stw   R30,[R72+f0]     EVP = R30; } }                    # Save
#
# ACT range check
# GUFB p. 21-15
#
3889: 3d,c5,1d            jb    B5,Rc5,38a9      if (AFMFLG == 0)  {               # skip ACT bounds check if it is known failed
388c: a3,72,94,30         ldw   R30,[R72+94]     R30 = IACT;
3890: 8b,f2,6a,30         cmpw  R30,[Rf2+6a]     
3894: d9,13               jgtu  38a9             if ((uns) R30 <= ACTMAX)  {
3896: 8b,f2,68,30         cmpw  R30,[Rf2+68]     
389a: d3,0d               jltu  38a9             if ((uns) R30 >= ACTMIN)  {
# IACT within expected range, use conversion function
389c: 45,b0,01,f0,32      ad3w  R32,Rf0,1b0      R32 = Fn703A;                     # AD to degrees F
38a1: b3,72,95,34         ldb   R34,[R72+95]     R34 = [IACT+1];                   # input for ACT calc (high byte of IACT)
38a5: 2d,0d               scall 35b4             USByteLU();
38a7: 20,0f               sjmp  38b8             goto 38b8; } } }                  # R38 is our new ACT

#### ACT sensor is out of range
38a9: 39,ef,05            jb    B1,Ref,38b1      if (WMEGOL == 0)  {               # Startup, open loop
38ac: b0,b0,38            ldb   R38,Rb0          R38 = ECT;
38af: 20,07               sjmp  38b8             goto 38b8; }                      # use ECT as ACT

38b1: 35,c5,07            jnb   B5,Rc5,38bb      if (AFMFLG == 1)  {               # If ACT failed flag set,
38b4: b3,f6,7f,38         ldb   R38,[Rf6+7f]     R38 = ACTFMM;                     # get default value from ROM
38b8: b0,38,b1            ldb   Rb1,R38          ACT = R38; }

#### update ECT
#### see GUFB p. 21-14

38bb: 3f,c5,1e            jb    B7,Rc5,38dc      if (CFMFLG == 0)  {               # skip ECT bounds check if it is known failed
38be: a3,72,92,30         ldw   R30,[R72+92]     R30 = IECT;
38c2: 8b,f3,80,00,30      cmpw  R30,[Rf2+80]     
38c7: d9,13               jgtu  38dc             if ((uns) R30 <= ECTMAX)  {
38c9: 8b,f2,7e,30         cmpw  R30,[Rf2+7e]     
38cd: d3,0d               jltu  38dc             if ((uns) R30 >= ECTMIN)  {
# IECT in expected range, use conversion function
38cf: 45,b0,01,f0,32      ad3w  R32,Rf0,1b0      R32 = Fn703A;                     # AD to degrees F
38d4: b3,72,93,34         ldb   R34,[R72+93]     R34 = [IECT+1];                   # Input for ECT calc (high byte of IECT)
38d8: 2c,da               scall 35b4             USByteLU();
38da: 20,22               sjmp  38fe             goto 38fe; } } }

###### out of range ECT sensor reading
38dc: b0,b1,38            ldb   R38,Rb1          R38 = ACT;                        # use ACT for ECT if cranking
38df: 3f,a1,1c            jb    B7,Ra1,38fe      if (CRKFLG == 1) goto 38fe;
38e2: 9b,fe,04,ad         cmpb  Rad,[Rfe+4]      
38e6: de,08               jlt   38f0             if (TCSTRT < CTHIGH) goto 38f0;   #
38e8: 9b,fc,0e,c8         cmpb  Rc8,[Rfc+e]      
38ec: d3,10               jltu  38fe             if ((uns) ATMR1 < OPCLT3) goto 38fe; # use ACT for ECT if too soon for hot start closed loop
38ee: 20,06               sjmp  38f6             goto 38f6;
#
38f0: 9b,fc,0f,c8         cmpb  Rc8,[Rfc+f]      
38f4: d3,08               jltu  38fe             if ((uns) ATMR1 < OPCLT2) goto 38fe; # use ACT for ECT if too soon for medium start closed loop
# 
38f6: 37,c5,17            jnb   B7,Rc5,3910      if (CFMFLG == 1)  {
38f9: b3,f7,80,00,38      ldb   R38,[Rf6+80]     R38 = ECTFMM;                     # Known failed, get default ECT value from ROM (75 deg ?)
#
# Compute ECT rolling average from whatever value above logic gave us
#
38fe: bc,b0,32            ldsbw R32,Rb0          R32 = (int)ECT;                   # previous Engine Coolant Temp - degrees F ?
3901: bc,38,34            ldsbw R34,R38          R34 = (int)R38;                   # new ECT value to filter and save
3904: 09,08,38            shlw  R38,8            R38 *= 100;                       # R38 = R38 * 256
3907: a3,fa,44,36         ldw   R36,[Rfa+44]     R36 = TCECT;                      # filter time constant
390b: 2d,5d               scall 366a             Rolav();                        # FILTER (factor times difference added back)
390d: b0,3e,b0            ldb   Rb0,R3e          ECT = R3e; }                      # Filterd Engine Coolant Temperature
#
# Average first 8 stable ECT readings to get TCSTRT
# See GUFB p. 19-30
#
3910: a3,72,b4,14         ldw   R14,[R72+b4]     R14 = PUTMR;                      # Counts up after h/w reset
3914: 8b,f8,52,14         cmpw  R14,[Rf8+52]                                       # 
3918: d1,15               jleu  392f             if ((uns) R14 > TKYON2 )  {       # Skip if too soon to be stable
391a: b3,74,e7,14         ldb   R14,[R74+e7]     R14 = ECTCNT;
391e: 99,08,14            cmpb  R14,8            
3921: db,0c               jgeu  392f             if (R14 > 8)  {                   # Only average the first 8 readings
3923: 0a,03,38            asrw  R38,3            R38 /= 8;                         # div by 8
3926: 64,38,ac            ad2w  Rac,R38          TCSTRL += R38;
3929: 17,14               incb  R14              R14++;                            # incr ECTCNT
392b: c7,74,e7,14         stb   R14,[R74+e7]     ECTCNT = R14; } }

#################
# update TP
# GUFB p. 21-12
#################

392f: 3c,c5,10            jb    B4,Rc5,3942      if (TFMFLG == 1) goto 3942;       # TP sensor known failed
3932: a3,72,a2,30         ldw   R30,[R72+a2]     R30 = ITP;
3936: 8b,f2,70,30         cmpw  R30,[Rf2+70]                                       # Range check
393a: d3,06               jltu  3942             if ((uns) R30 < TAPMIN) goto 3942;  # Out of range low
393c: 8b,f2,6e,30         cmpw  R30,[Rf2+6e]     
3940: d1,23               jleu  3965             if ((uns) R30 <= TAPMAX) goto 3965; # Fall through if out of range high
#
# TP out of range
3942: a3,72,a6,30         ldw   R30,[R72+a6]     R30 = RATCH;                      # Substitute RATCH if cranking
3946: 3f,a1,1c            jb    B7,Ra1,3965      if (CRKFLG == 1) goto 3965;       #  in case out of range is due to low battery
#
3949: 8b,f7,84,00,a2      cmpw  Ra2,[Rf6+84]     
394e: d3,15               jltu  3965             if ((uns) AM < IDLMAF) goto 3965; # Also use RATCH if airmass below idle
#
3950: 34,c5,15            jnb   B4,Rc5,3968      if (TFMFLG == 1)  {               # Skip updating if out of range but not known failed
3953: a3,f0,02,30         ldw   R30,[Rf0+2]
3957: c3,72,a6,30         stw   R30,[R72+a6]     RATCH = RATIV;                    # Set initial value
395b: 67,f7,82,00,30      ad2w  R30,[Rf6+82]     R30 += FMCTTP;                    # Change in TP if not at idle (as indicated by AM) To permit Part Throttle operation
3960: d3,03               jnc   3965             if (unsigned overflow)  {
3962: bd,c0,30            ldsbw R30,c0           R30 = (int)c0; }                  # default value
#
3965: a0,30,aa            ldw   Raa,R30          TP = R30; }                       # store result of above logic

#################
# update TAR - Throttle position sensor angular rate
# GUFB p. 19-42
#################

3968: a1,ae,a3,38         ldw   R38,a3ae         R38 = a3ae;                       # min rate?
396c: 6b,72,a0,38         sb2w  R38,[R72+a0]     R38 -= ITAR;                      # read raw TAR sensor 120
3970: db,02               jgeu  3974             if (R38 < 0)  {
3972: 01,38               clrw  R38              R38 = 0; }                        # clamp to zero
3974: 6d,ae,bc,38         ml2w  R38,bcae         R3b:R38 = R39:R38 * 0xbcae;
3978: 0d,01,38            shldw R38,1            R3b:R38 *= 2;
397b: 65,80,00,3a         ad2w  R3a,80           R3a += 80;                        # round up
397f: c7,74,20,3b         stb   R3b,[R74+20]     TAR = R3b;                        # TAR scaled and translated? 29E

##############################
# update BP
# GUFB pp. 19-25, 21-11
##############################

#
# GUFB p. 21-11
3983: 9b,f8,4b,00         cmpb  R0,[Rf8+4b]      
3987: d7,0a               jne   3993             if (0 == BPSSW)  {
3989: b3,f8,4c,14         ldb   R14,[Rf8+4c]                                       # No BAP sensor - use default value
398d: c7,74,80,14         stb   R14,[R74+80]     BP = KONBP;
3991: 20,94               sjmp  3a27             goto 3a27; }                      #  and continue with MAF logic
#
3993: 31,c5,09            jnb   B1,Rc5,399f      if (BFMFLG == 0) goto 399f;
3996: b3,f7,86,00,35      ldb   R35,[Rf6+86]     R35 = BAPFMM;                     # BAP known failed - use default
399b: 20,6c               sjmp  3a09             goto 3a09;                        #  as new IBAP

399d: 20,66               sjmp  3a05                                               # Never gets here?
#
# Jump here from 3993 (BFMFLG == 0)
399f: b3,72,b6,3a         ldb   R3a,[R72+b6]     R3a = BAPTMR;                     # time since last bkgnd cycle after
                                                                                   #  BP low-high transition
39a3: 9b,f3,16,01,3a      cmpb  R3a,[Rf2+116]    
39a8: d9,77               jgtu  3a21             if ((uns) BAPTMR <= VBPMAX)  {    # skip updating BAP et al if time too long
39aa: a3,72,8a,1c         ldw   R1c,[R72+8a]     R1c = MDELTA;                     # most recent BP period
39ae: 8b,f3,02,01,1c      cmpw  R1c,[Rf2+102]                                      
39b3: d3,6c               jltu  3a21             if ((uns) MDELTA >= VBPDL1)  {
#
39b5: 3f,a1,03            jb    B7,Ra1,39bb      if (CRKFLG == 1) goto 39bb;
39b8: 32,4e,4a            jnb   B2,R4e,3a05      if (New_Bpv == 1)  {              # BP update requested - every PIP High
#
# GUFB p. 19-25, bottom
39bb: fa                  di                     disable ints;
39bc: ff                  nop                    
39bd: ac,b6,1e            ldzbw R1e,Rb6          R1e = (uns)BAPCNT;                # BP counts
39c0: a3,74,02,16         ldw   R16,[R74+2]      R16 = MINTIM1;                    # time of last BP read
39c4: 11,b6               clrb  Rb6              BAPCNT = 0;                       # reset count to zero
39c6: 30,1e,07            jnb   B0,R1e,39d0      if (B0_R1e == 1)  {               # disallow odd BP counts
39c9: 15,1e               decb  R1e              R1e--;
39cb: 17,b6               incb  Rb6              BAPCNT++;
39cd: 68,1c,16            sb2w  R16,R1c          R16 -= R1c; }
39d0: fb                  ei                     enable ints;
39d1: 98,1e,00            cmpb  R0,R1e
39d4: d6,2f               jge   3a05             if (0 < R1e <= 128)  {            # Sanity check of BAPCNT
39d6: 4b,72,bc,16,18      sb3w  R18,R16,[R72+bc] R18 = R16 - MINTIM2;              # 13C - time of last BP read - R18 is delta time?
39db: 01,1a               clrw  R1a              R1a = 0;
39dd: 0d,01,18            shldw R18,1            R1b:R18 *= 2;
39e0: 8c,1e,18            divw  R18,R1e          R19:R18 = R1b:R18 / R1f:R1e;      # convert counts to freq by dividing by time
39e3: a1,ab,9a,34         ldw   R34,9aab         R34 = 9aab;
39e7: a1,5b,06,36         ldw   R36,65b          R36 = 65b;
39eb: 8c,18,34            divw  R34,R18          R35:R34 = R37:R34 / R19:R18;      # = 106666667/freq
39ee: 45,78,00,f0,32      ad3w  R32,Rf0,78       R32 = FN000;                      # Conversion to BP units
39f3: ef,16,fc            call  360c             UUWordLu();
39f6: 65,80,00,38         ad2w  R38,80           R38 += 80;                        # round up to save byte vs word
39fa: c7,72,af,39         stb   R39,[R72+af]     IBAP = R39;                       # save BP 12F
39fe: c3,72,bc,16         stw   R16,[R72+bc]     MINTIM2 = R16;                    # time of last BP calc
3a02: 71,fb,4e            an2b  R4e,fb           New_Bpv = 0; } }
#
3a05: b3,72,af,35         ldb   R35,[R72+af]     R35 = IBAP;
#
3a09: 11,34               clrb  R34              R34 = 0;                          # new AD sensor value 
3a0b: a3,72,b0,32         ldw   R32,[R72+b0]     R32 = BAPBAR;                     # Old AD sensor value, filtered BP
3a0f: ef,4c,fc            call  365e             Urolav_1Arg(97fe);                   # filter new/old AD input
3a12: 56,d0               #args  
3a14: c3,72,b0,3e         stw   R3e,[R72+b0]     BAPBAR = R3e;                     # filtered BP (as word)
3a18: c7,74,80,3f         stb   R3f,[R74+80]     BP = R3f;                         # BP - barometric pressure as byte
3a1c: 39,c5,02            jb    B1,Rc5,3a21      if (BFMFLG == 1) goto 3a21;
3a1f: 20,06               sjmp  3a27             goto 3a27; } }
#
3a21: 11,b6               clrb  Rb6              BAPCNT = 0;
3a23: c3,72,bc,06         stw   R6,[R72+bc]      MINTIM2 = IO_Timer;               # time of last BP read/calc


######################
# update MAF
#
# See MASS AIR FLOW SENSOR FMEM, GUFB p. 21-9
##################################################

3a27: 3b,c5,19            jb    B3,Rc5,3a43      if (MFMFLG == 1) goto 3a43;        # skip if MAF known to be bad
#
3a2a: a3,72,a4,34         ldw   R34,[R72+a4]     R34 = IMAF;
3a2e: 8b,f3,12,01,ae      cmpw  Rae,[Rf2+112]    
3a33: db,07               jgeu  3a3c             if ((uns) N >= VMARPM) goto 3a3c; # ignore VMAMAX at high RPM
3a35: 8b,f3,0e,01,34      cmpw  R34,[Rf2+10e]                                      # max MAF voltage
3a3a: d9,07               jgtu  3a43             if ((uns) R34 > VMAMAX ) goto 3a43;
#
3a3c: 8b,f3,10,01,34      cmpw  R34,[Rf2+110]                                      # min MAF voltage
3a41: db,0b               jgeu  3a4e             if (R34 < VMAMIN)  {              # jmp if range OK
3a43: 91,01,26            orb   R26,1            IMFMFLG = 1;                      # MAF count out of range error
3a46: b3,f2,4c,34         ldb   R34,[Rf2+4c]     R34 = MFMHYS;                     # bad MAF sensor retry interval (3)
3a4a: c7,72,cb,34         stb   R34,[R72+cb]     IMFMCTR = R34; }                  # set bad MAF retry interval
# valid MAF sensor reading
3a4e: 37,a1,06            jnb   B7,Ra1,3a57      if (CRKFLG == 1)  {
3a51: c7,72,cb,00         stb   R0,[R72+cb]      IMFMCTR = 0;                      # counts since last bad MAF read
3a55: 20,11               sjmp  3a68             goto 3a68; }
#
3a57: b3,72,cb,34         ldb   R34,[R72+cb]     R34 = IMFMCTR;                    # decr bad MAF read count but clamp to zero
3a5b: 98,34,00            cmpb  R0,R34           
3a5e: df,08               je    3a68             if (0 != R34)  {
3a60: 15,34               decb  R34              R34--;
3a62: c7,72,cb,34         stb   R34,[R72+cb]     IMFMCTR = R34;
3a66: 20,03               sjmp  3a6b             goto 3a6b; }
#
3a68: 71,fe,26            an2b  R26,fe           IMFMFLG = 0;                      # clr MAF input range error?
#
3a6b: 38,26,1e            jb    B0,R26,3a8c      if (IMFMFLG == 0)  {              # jmp if MAF out of range error
#
# Background air charge logic
# GUFB p. 19-21 (bottom)
#
3a6e: cb,74,da            push  [R74+da]         push(ARCHFG);
3a71: cf,74,d4            pop   [R74+d4]         ARCHG = pop();
3a74: a3,74,d8,30         ldw   R30,[R74+d8]     R30 = ARCHI;
3a78: 01,32               clrw  R32              R32 = 0;
3a7a: 0d,08,30            shldw R30,8            R33:R30 *= 100;
3a7d: 8f,74,da,30         divw  R30,[R74+da]     R31:R30 = R33:R30 / ARCHFG;
3a81: d5,03               jnv   3a86             if (OVF == 1)  {
3a83: bd,ff,30            ldsbw R30,ff           R30 = 0xffff; }
#
3a86: c3,74,dc,30         stw   R30,[R74+dc]     FILRC1 = R30;
3a8a: 20,7d               sjmp  3b09             goto 3b09; }
#
# MAF sensor out of limits failure mode logic
# GUFB p. 21-9 (bottom)
#
3a8c: a0,ae,34            ldw   R34,Rae          R34 = N;
3a8f: 3c,c5,67            jb    B4,Rc5,3af9      if (TFMFLG == 0)  {               # jmp if TP failed too
3a92: 45,de,00,f0,32      ad3w  R32,Rf0,de       R32 = FN070;                      # spark RPM scaling
3a97: ef,72,fb            call  360c             UUWordLu();
3a9a: a0,38,30            ldw   R30,R38          R30 = R38;
3a9d: a3,72,a2,34         ldw   R34,[R72+a2]     R34 = ITP;
3aa1: 6b,72,a6,34         sb2w  R34,[R72+a6]     R34 -= RATCH;
3aa5: db,02               jgeu  3aa9             if (R34 > 0)  {
3aa7: 01,34               clrw  R34              R34 = 0; }                        # clamp to zero (throttle closing? )
#
3aa9: 45,f0,00,f4,32      ad3w  R32,Rf4,f0       R32 = FN098;                      # Normalized delta TP, used for MAF sensor failure Table lookup.
3aae: ef,5b,fb            call  360c             UUWordLu();
3ab1: a0,38,32            ldw   R32,R38          R32 = R38;
3ab4: 45,2c,01,f4,38      ad3w  R38,Rf4,12c      R38 = FN1358;                     # Table: estimated charge vs N and TP 
3ab9: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
3abc: ef,2b,fc            call  36ea             UTabLookUp();
3abf: ac,3b,38            ldzbw R38,R3b          R38 = (uns)R3b;                   # Move byte result to R38 (word) 
#
# Calculate air leakage per PIP
#
3ac2: a3,74,e4,34         ldw   R34,[R74+e4]     R34 = DEBYMA_FM;                  # Calculate air leakage per PIP
3ac6: 01,36               clrw  R36              R36 = 0;
3ac8: 0d,08,34            shldw R34,8            R37:R34 *= 100;
3acb: 8c,ae,34            divw  R34,Rae          R35:R34 = R37:R34 / N;
3ace: 9f,fe,07,34         divb  R34,[Rfe+7]      R34 /= ENGCYL;                    # PIPs/rev * 2
3ad2: d5,03               jnv   3ad7             if (OVF == 1)  {
3ad4: b1,ff,34            ldb   R34,ff           R34 = ff; }                       # clip if overflow
#
3ad7: 11,35               clrb  R35              R35 = 0;
3ad9: 64,38,34            ad2w  R34,R38          R34 += R38;                       # Sum leakage and table result
3adc: af,74,80,36         ldzbw R36,[R74+80]     R36 = (uns)BP;                    # and compensate for BP
3ae0: 09,07,36            shlw  R36,7            R36 *= 80;
3ae3: 6c,36,34            ml2w  R34,R36          R37:R34 = R35:R34 * R37:R36;
3ae6: 8d,ef,00,34         divw  R34,ef           R35:R34 = R37:R34 / 0xef;
3aea: d5,03               jnv   3aef             if (OVF == 1)  {
3aec: bd,ff,34            ldsbw R34,ff           R34 = 0xffff; }                  # clip if overflow
#
3aef: c3,74,d4,34         stw   R34,[R74+d4]     ARCHG = R34;
3af3: c3,74,da,34         stw   R34,[R74+da]     ARCHFG = R34;
3af7: 20,10               sjmp  3b09             goto 3b09; }
#
# TP failed too, take a SWAG at airflow based on RPM
#
3af9: 45,0c,01,f4,32      ad3w  R32,Rf4,10c      R32 = FN040;
3afe: ef,0b,fb            call  360c             UUWordLu();
3b01: c3,74,d4,38         stw   R38,[R74+d4]     ARCHG = R38;
3b05: c3,74,da,38         stw   R38,[R74+da]     ARCHFG = R38;
#
# Update NDS and A3C (multiplexed inputs)
# GUFB p. 19-11
#
3b09: a3,72,9a,14         ldw   R14,[R72+9a]     R14 = INDS;
3b0d: 4b,74,0c,14,16      sb3w  R16,R14,[R74+c]  R16 = R14 - LST_IACC;             # last raw AD NDS/A3C
3b12: db,02               jgeu  3b16             if (R16 > 0)  {                   # take absolute value of difference
3b14: 03,16               negw  R16              R16 = -R16; }
#
3b16: 89,80,02,16         cmpw  R16,280                                            # 0x280 = .05V
3b1a: d9,28               jgtu  3b44             if ((uns) R16 <= 280)  {          
3b1c: 71,7f,ee            an2b  Ree,7f           A3C = 0;                          # A/C cycling control switch is open
3b1f: 91,40,ee            orb   Ree,40           INDFLG = 1;
3b22: 89,00,ee,14         cmpw  R14,ee00                                           # 0xEE00 = 4.648V
3b26: db,1c               jgeu  3b44             if (R14 < ee00)  {
3b28: 89,00,8b,14         cmpw  R14,8b00                                           # 0x8B00 = 2.715V
3b2c: d3,05               jltu  3b33             if ((uns) R14 >= 8b00)  {
3b2e: 71,bf,ee            an2b  Ree,bf           INDFLG = 0;
3b31: 20,11               sjmp  3b44             goto 3b44; }
#
3b33: 89,00,67,14         cmpw  R14,6700                                           # 0x6700 = 2.012V
3b37: d3,05               jltu  3b3e             if ((uns) R14 >= 6700)  {
3b39: 91,80,ee            orb   Ree,80           A3C = 1;
3b3c: 20,06               sjmp  3b44             goto 3b44; }
#
3b3e: 91,80,ee            orb   Ree,80           A3C = 1;                          # A/C cycling control switch is closed
3b41: 71,bf,ee            an2b  Ree,bf           INDFLG = 0; } }
#
3b44: c3,74,0c,14         stw   R14,[R74+c]      LST_IACC = R14;                   # save last NDS/A3C
#
# NDSFLG logic
# GUFB p. 19-37
#
3b48: b3,fe,02,18         ldb   R18,[Rfe+2]      R18 = TRLOAD;                     # Transmission Load switch
3b4c: b0,e7,30            ldb   R30,Re7          R30 = Flags_e7;
3b4f: 71,7f,e7            an2b  Re7,7f           NDSFLG = 0;                       # 1 = Drive.
3b52: 99,00,18            cmpb  R18,0                                              # Manual Trans, no clutch or gear switches, forced neutral state (NDSFLG == 0).
3b55: df,06               je    3b5d             if (TRLOAD != 0)  {
3b57: 36,ee,03            jnb   B6,Ree,3b5d      if (INDFLG == 1)  {
3b5a: 91,80,e7            orb   Re7,80           NDSFLG = 1; } }                   # 1 = Drive.
#
3b5d: 94,e7,30            xorb  R30,Re7          R30 ^= Flags_e7;
3b60: 37,30,02            jnb   B7,R30,3b65      if (B7_R30 == 1)  {               # i.e. NDSFLG changed state
3b63: 11,cc               clrb  Rcc              NDDTIM = 0; }                     # time since Neutral/Drive Switch State change, sec.
#
# DNDSUP logic
# GUFB p. 19-38
#
3b65: 99,03,18            cmpb  R18,3                                              # Manual Transmission, both clutch and gear switches.
3b68: d9,0b               jgtu  3b75             if ((uns) TRLOAD > 3 ) goto 3b75;
3b6a: 71,bf,26            an2b  R26,bf           DNDSUP = 0;
3b6d: 37,e7,2a            jnb   B7,Re7,3b9a      if (NDSFLG == 1)  {               # 1 = Drive.
3b70: 91,40,26            orb   R26,40           DNDSUP = 1;                       # Drive Neutral select.
3b73: 20,25               sjmp  3b9a             goto 3b9a;
#
3b75: 3f,e7,0f            jb    B7,Re7,3b87      if (NDSFLG == 1) goto 3b87;       # 1 = Drive.
3b78: b3,f5,92,00,38      ldb   R38,[Rf4+92]     R38 = NDDELT;
3b7d: 98,cc,38            cmpb  R38,Rcc                                            # time since Neutral/Drive Switch State change, sec.
3b80: d9,18               jgtu  3b9a             if ((uns) R38 <= NDDTIM)  {
3b82: 71,bf,26            an2b  R26,bf           DNDSUP = 0;                       # clr  Drive Neutral select.
3b85: 20,13               sjmp  3b9a             goto 3b9a;
#
3b87: b0,b0,34            ldb   R34,Rb0          R34 = ECT;
3b8a: 45,26,00,f0,32      ad3w  R32,Rf0,26       R32 = FN394F;                     # FN394F(ECT) OUTPUT = Seconds.
3b8f: ef,1a,fa            call  35ac             subyteLU();
3b92: 98,cc,38            cmpb  R38,Rcc                                            # time since Neutral/Drive Switch State change, sec.
3b95: d9,03               jgtu  3b9a             if ((uns) R38 <= NDDTIM)  {
3b97: 91,40,26            orb   R26,40           DNDSUP = 1; } } }                 # set Drive/Neutral Select.
#
# Power Steering Switch logic (not present on A9L)
# GUFB p. 19-41
#
3b9a: 71,ef,27            an2b  R27,ef           POWSFG = 0;                       # clear Power Steering Flag.
3b9d: 30,df,03            jnb   B0,Rdf,3ba3      if (Psps_lvl == 1)  {
3ba0: 91,10,27            orb   R27,10           POWSFG = 1; }

 ###### CHECK EGOs - handle cross, rich to lean, or lean to rich
 ## check EGO 1

3ba3: 71,f7,27            an2b  R27,f7           SWTFL1 = 0;                       # Mixture cross flag EGO1
3ba6: a3,72,9c,14         ldw   R14,[R72+9c]     R14 = IEGO1;
3baa: 89,c0,d5,14         cmpw  R14,d5c0                                           # Trip Voltage
                                                                                   # *** Constant patched by Z_HGSW1 in GUFB.xls ***
3bae: db,08               jgeu  3bb8             if ((uns) R14 >= d5c0) goto 3bb8; # 4.17v = Rich
3bb0: 3f,ea,13            jb    B7,Rea,3bc6      if (EGOFL1 == 0)  {               # jump if already rich (No Cross)
3bb3: 91,80,ea            orb   Rea,80           EGOFL1 = 1;                       # Set Mixture Rich
3bb6: 20,06               sjmp  3bbe             goto 3bbe;

3bb8: 37,ea,0b            jnb   B7,Rea,3bc6      if (EGOFL1 == 1)  {               # jump if already lean
3bbb: 71,7f,ea            an2b  Rea,7f           EGOFL1 = 0;                       # mixture is lean
3bbe: 91,08,27            orb   R27,8            SWTFL1 = 1;                       # Set CROSS flag
3bc1: ad,01,42            ldzbw R42,1            R42 = (uns)1;                     # sensor 1
3bc4: 29,09               scall 3ccf             EGO_CrosscntB(); } }

 ## check EGO 2  (same but different flags)

3bc6: 71,fe,27            an2b  R27,fe           SWTFL2 = 0;
3bc9: a3,72,9e,14         ldw   R14,[R72+9e]     R14 = IEGO2;
3bcd: 89,c0,d5,14         cmpw  R14,d5c0                                           # *** Constant patched by Z_HGSW2 in GUFB.xls ***
3bd1: db,08               jgeu  3bdb             if ((uns) R14 >= d5c0) goto 3bdb;
3bd3: 3e,ea,13            jb    B6,Rea,3be9      if (EGOFL2 == 0)  {
3bd6: 91,40,ea            orb   Rea,40           EGOFL2 = 1;
3bd9: 20,06               sjmp  3be1             goto 3be1;
#
3bdb: 36,ea,0b            jnb   B6,Rea,3be9      if (EGOFL2 == 1)  {
3bde: 71,bf,ea            an2b  Rea,bf           EGOFL2 = 0;
3be1: 91,01,27            orb   R27,1            SWTFL2 = 1;                       # CROSS FLAG
3be4: ad,02,42            ldzbw R42,2            R42 = (uns)2;                     # sensor 2
3be7: 28,e6               scall 3ccf             EGO_CrosscntB(); } }
#
# Brake On / Off Logic (not present on A9L)
# GUFB p. 19-26 (bottom)
3be9: 71,fd,ea            an2b  Rea,fd           BIFLG = 0;
3bec: 9b,f6,13,00         cmpb  R0,[Rf6+13]                                        # BIHP Brake Input H/w Present (not on A9L)
3bf0: df,06               je    3bf8             if (0 != BIHP)  {                 # jmp if not A/C or BOO sensor input
3bf2: 34,90,03            jnb   B4,R90,3bf8      if (B4_Last_HSI == 1)  {          # jmp if not BOO HIGH
3bf5: 91,02,ea            orb   Rea,2            BIFLG = 1; } }                    # Brake is on.
#
# Jump here from:
#  3bf0 BIHP == 0
#  3bf2 !BOO
#
# Sample Self-Test In
#
3bf8: 91,20,2b            orb   R2b,20           STIFLG = 1;
3bfb: 33,0b,03            jnb   B3,Rb,3c01       if (B3_HSI_Sample == 1)  {        # HSI bit 3 is STI - Self Test Input - on the fly test
3bfe: 71,df,2b            an2b  R2b,df           STIFLG = 0; }

###############################################################################
# KeyPower may be read thru a 20k and 4.35K voltage divider yielding 17.86% of battery voltage to AD input
# Update IVCAL/KEYPWR
# IVCAL is nominally 2.5 Volts giving an AD reading of 0x8000
# a 14V battery thru the divider gives a 2.5V AD input
# resulting battery voltage level is times 16
############################################################################### 
3c01: a3,fc,0c,36         ldw   R36,[Rfc+c]      R36 = VCAL;
3c05: 01,34               clrw  R34              R34 = 0;                          # R34L = 2800 0000
3c07: a3,72,90,32         ldw   R32,[R72+90]     R32 = IVCAL;
3c0b: 88,32,00            cmpw  R0,R32                                             # chk for div by zero (VCAL regulator is bad)
3c0e: df,05               je    3c15             if (0 == R32) goto 3c15;
3c10: 8c,32,34            divw  R34,R32          R35:R34 = R37:R34 / R33:R32;      # 2800 0000/IVCAL = 5000 nominally
3c13: d5,06               jnv   3c1b             if (OVF == 1)  {
#
# Failed high exit
#
3c15: a1,fd,8d,34         ldw   R34,8dfd         R34 = 8dfd;                       # clamp overflow to IVCAL failure default 
3c19: 20,10               sjmp  3c2b             goto 3c2b; }
#
# validate IVCAL range
#
3c1b: 89,fd,8d,34         cmpw  R34,8dfd         
3c1f: d9,f4               jgtu  3c15             if ((uns) R34 > 8dfd ) goto 3c15;
3c21: 89,89,41,34         cmpw  R34,4189         
3c25: d9,04               jgtu  3c2b             if ((uns) R34 <= 4189)  {
3c27: a1,89,41,34         ldw   R34,4189         R34 = 4189; }                     # failed low
#
# Normalize KEYPWR voltage
# GUFB p. 19-26 (top)
# R34 = VCAL/IVCAL = 0x5000 typical
#
3c2b: 6f,fe,18,34         ml2w  R34,[Rfe+18]     R37:R34 = R35:R34 * KSF;          # = B32C (gives 380BBF70 w/o voltage err)
3c2f: a0,36,34            ldw   R34,R36          R34 = R36;                        # hi 16 bits of 32 bit result (0x37FD nom.)
3c32: 6f,72,8c,34         ml2w  R34,[R72+8c]     R37:R34 = R35:R34 * IIVPWR;       # raw KEYPWR (17.86% of bat voltage)(result is VBat * 2)(result Hi SB 1BFE w/o errs)
3c36: 89,e1,1f,36         cmpw  R36,1fe1                                           # check max voltage in top 16 of 32 bit result (~15.94V)
3c3a: d9,05               jgtu  3c41             if ((uns) R36 <= 1fe1)  {         # clamp voltage
3c3c: 0d,03,34            shldw R34,3            R37:R34 *= 8;                     # now volts * 16
3c3f: 20,03               sjmp  3c44             goto 3c44; }
#
3c41: b1,ff,37            ldb   R37,ff           R37 = ff;                         # max voltage
#
# Filter battery voltage
#
3c44: af,74,93,32         ldzbw R32,[R74+93]     R32 = (uns)VBAT;                  # OLD AD sensor value Lo = 211 - Battery Voltage Level
3c48: ac,37,34            ldzbw R34,R37          R34 = (uns)R37;                   # NEW AD sensor value Lo
3c4b: ef,10,fa            call  365e             Urolav_1Arg(TCVBAT);                 # filter new AD input - battery voltage
3c4e: 50,d0               #args                                                    # filter factors (lookup in ROM)
3c50: c7,74,93,3e         stb   R3e,[R74+93]     VBAT = R3e;                       # updated AD value = 211 - Battery Voltage Level * 16
#
# Calculate injector offset based on battery voltage
# GUFB p. 6-82 (bottom)
#
3c54: b0,3e,34            ldb   R34,R3e          R34 = R3e;
3c57: 45,b2,00,fc,32      ad3w  R32,Rfc,b2       R32 = FN367;                      # Table injector offset vs battery volts
3c5c: ef,58,f9            call  35b7             UUbyteLu();
3c5f: c7,72,13,38         stb   R38,[R72+13]     PWOFS = R38;                      # Injector offset in 1/32 msec (CONFIRMED)
3c63: 01,30               clrw  R30              R30 = 0;
3c65: b0,38,31            ldb   R31,R38          R31 = R38;                        # R30 <- PWOFS * 0x100
3c68: 6d,06,0d,30         ml2w  R30,d06          R33:R30 = R31:R30 * 0xd06;        # d06 = ticks/ms conversion factor
3c6c: c3,72,0e,32         stw   R32,[R72+e]      PWOFF = R32;                      # High 16 bits = Injector offset in IO ticks
#
# Part of Throttle Angle Rate logic
# GUFB p. 19-42
#
3c70: a3,74,9c,32         ldw   R32,[R74+9c]     R32 = OLDTP;
3c74: 68,aa,32            sb2w  R32,Raa          R32 -= TP;
3c77: d3,0a               jltu  3c83             if ((uns) R32 >= 0)  {
3c79: 8b,f4,30,32         cmpw  R32,[Rf4+30]     
3c7d: d1,04               jleu  3c83             if ((uns) R32 > TPDLTA)  {
3c7f: c7,74,20,00         stb   R0,[R74+20]      TAR = 0; } }                      # scale and translated TAR
#
# AEOFLG logic
# GUFB p. 6-58
#
3c83: b3,74,20,30         ldb   R30,[R74+20]     R30 = TAR;
3c87: 9b,f4,34,30         cmpb  R30,[Rf4+34]     
3c8b: d1,15               jleu  3ca2             if ((uns) R30 > AETAR)  {
3c8d: a3,74,de,32         ldw   R32,[R74+de]     R32 = LOAD;                       # engine load (VE)
3c91: 6b,74,9e,32         sb2w  R32,[R74+9e]     R32 -= AELOAD;
3c95: d3,0b               jltu  3ca2             if ((uns) R32 >= 0)  {
3c97: 8b,f4,32,32         cmpw  R32,[Rf4+32]     
3c9b: d1,05               jleu  3ca2             if ((uns) R32 > AEACLD)  {
3c9d: 91,20,29            orb   R29,20           AEOFLG = 1;
3ca0: 20,08               sjmp  3caa             goto 3caa; } } }
#
3ca2: 98,00,30            cmpb  R30,R0           
3ca5: d7,03               jne   3caa             if (R30 == 0)  {
3ca7: 71,df,29            an2b  R29,df           AEOFLG = 0; }
#
3caa: c3,74,9c,aa         stw   Raa,[R74+9c]     OLDTP = TP;
#
# Calculate FN311, FN212A from BP and cache the results
#
3cae: 45,e3,00,f4,32      ad3w  R32,Rf4,e3       R32 = FN311;                      # MFA open loop fuel multiplier vs BP (altitude)
3cb3: b3,74,80,34         ldb   R34,[R74+80]     R34 = BP;
3cb7: ef,fd,f8            call  35b7             UUbyteLu();
3cba: c7,74,82,38         stb   R38,[R74+82]     Mult_bp311 = R38;              
3cbe: 45,46,01,fa,32      ad3w  R32,Rfa,146      R32 = FN212A;                     # Open loop fuel multiplier vs BP
3cc3: b3,74,80,34         ldb   R34,[R74+80]     R34 = BP;
3cc7: ef,ed,f8            call  35b7             UUbyteLu();
3cca: c7,74,83,38         stb   R38,[R74+83]     Mult_bp212A = R38;
3cce: f0                  ret                    return;

###################################################################
# EGOSSS logic
# GUFB p. 6-12
# Count the no of times switched between rich and lean (of stiochoimetric)
# Inputs:
#  R42 - EGO # - either 1 or 2
# Outputs:
#  2A4 - total crosses
#  2A5 - EGO1 crosses
#  2A6 - EGO2 crosses
###################################################################

  EGO_CrosscntB:
3ccf: 28,02               scall 3cd3             EGO_crosscnt();                   # Increment CROSS COUNT by BANK
3cd1: 11,42               clrb  R42              R42 = 0;                          # Then total

  EGO_crosscnt:
3cd3: b3,43,a4,02,34      ldb   R34,[R42+2a4]    R34 = [R42+EGOSSS];               # INCREMENT CROSS COUNTER
3cd8: 17,34               incb  R34              R34++;
3cda: d3,02               jnc   3cde             if (overflow)  {
3cdc: 15,34               decb  R34              R34--; }                          # clamp max to FF
#
3cde: c7,43,a4,02,34      stb   R34,[R42+2a4]    [R42+EGOSSS] = R34;
3ce3: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 12
# Update (MPH) vehicle speed values
# GUFB p. 19-44, bottom half
# get sample interval time end and click count
# see routine 2A15 (Vss_inth) for click count
# Inputs:
#  MPHCNT
#  MPHTIM1L/H
#  MPHTIM2L/H
#  TSLMPH
# Outputs:
#  MPHCNT = 0
#  MPHTIM2L/H
#  02AC = filtered MPH
#  02B2 = unfiltered MPH
#  02BC = filtered MPH
#################################################################

  Update_MPH:
3ce4: fa                  di                     disable ints;                     # Lock out VSS interrupt handler
3ce5: ff                  nop                    
3ce6: ac,b2,42            ldzbw R42,Rb2          R42 = (uns)MPHCNT;                # VSS speed ring clicks since last pass
3ce9: a3,74,40,30         ldw   R30,[R74+40]     R30 = MPHTIM1L;                   # Time of most recent VSS click
3ced: b3,74,42,32         ldb   R32,[R74+42]     R32 = MPHTIM1H;
3cf1: 11,b2               clrb  Rb2              MPHCNT = 0;                       # Clear VSS click counter
3cf3: fb                  ei                     enable ints;                      # Interrupts OK again
# start new sample interval
3cf4: 01,34               clrw  R34              R34 = 0;
3cf6: b3,74,3d,36         ldb   R36,[R74+3d]     R36 = TSLMPH;                     # time since last click
3cfa: 99,ff,36            cmpb  R36,ff           
3cfd: d3,05               jltu  3d04             if (TSLMPH >= ff)  {              # effectively == 0xff
3cff: 71,fb,c4            an2b  Rc4,fb           First_mph = 0;                    # timed out, clear and reset
# check for any click count
3d02: 20,2f               sjmp  3d33             goto 3d33; }

3d04: 98,00,42            cmpb  R42,R0                                             # no clicks?
3d07: d7,06               jne   3d0f             if (R42 == 0)  {                  # jmp if valid sample
#
# No clicks seen since last pass
#
3d09: a3,74,34,34         ldw   R34,[R74+34]     R34 = VS;                         # NEW MPH = last MPH
# calc time per speed ring click
3d0d: 20,28               sjmp  3d37             goto 3d37; }
#
# R30 (word) = MPHTIM1L
# R32 (byte) = MPHTIM1H
# R42 (word) = MPHCNT at entry
# 
3d0f: ac,32,16            ldzbw R16,R32          R16 = (uns)R32;                   # old MPHCNT
3d12: 4b,74,44,30,14      sb3w  R14,R30,[R74+44] R14 = R30 - MPHTIM2L;             # R14 = MPHTIM1L - MPHTIM2L
3d17: bb,74,46,16         sbbb  R16,[R74+46]     R16 -= MPHTIM2H - CY;             # R16 = MPHTIM1H - MPHTIM2H - carry
3d1b: 8c,42,14            divw  R14,R42          R15:R14 = R17:R14 / R43:R42;      # = time per VSS click
3d1e: d5,03               jnv   3d23             if (OVF == 1)  {
3d20: bd,ff,14            ldsbw R14,ff           R14 = 0xffff; }                   # Clip to 0xffff on overflow
#
# calc MPH - 96000000/2.4 = 40000000.  4000 clicks per mile ?
# R30 (word) = MPHTIM1L
# R32 (byte) = MPHTIM1H
#
3d23: a1,b8,05,36         ldw   R36,5b8          R36 = 5b8;                        # = 96000000 
3d27: a1,00,d8,34         ldw   R34,d800         R34 = d800;
3d2b: 8c,14,34            divw  R34,R14          R35:R34 = R37:R34 / R15:R14;      # 96M / R14(time per click) = distance per time (MPH?)
3d2e: d5,03               jnv   3d33             if (OVF == 1)  {
3d30: bd,ff,34            ldsbw R34,ff           R34 = ffff; }
#
# Jump here from:
#  3d02 (TSLMPH was 0xff; R34 = 0)
#  3d2e (division overflowed, R34 = 0xffff)
#
3d33: c3,74,34,34         stw   R34,[R74+34]     VS = R34;                         # NEW (unfiltered) vehicle speed
#
# Jump here from 3d37 (MPHCNT was 0 at entry; R34 = old VS)
#
3d37: c3,74,44,30         stw   R30,[R74+44]     MPHTIM2L = R30;                   # MPHTIM2 = MPHTIM1
3d3b: c7,74,46,32         stb   R32,[R74+46]     MPHTIM2H = R32;
#
# Update filtered speed variables VSBAR, MPH from VS
# GUFB p. 19-45
#
3d3f: a3,74,3e,32         ldw   R32,[R74+3e]     R32 = VSBAR;
3d43: ef,18,f9            call  365e             Urolav_1Arg(TCVS);
3d46: 52,d0               #args  
3d48: c3,74,3e,3e         stw   R3e,[R74+3e]     VSBAR = R3e;                      # Filtered vehicle speed (1)
3d4c: a3,74,2e,32         ldw   R32,[R74+2e]     R32 = MPH;
3d50: ef,0b,f9            call  365e             Urolav_1Arg(TCMPH);
3d53: 5a,d0               #args  
3d55: c3,74,2e,3e         stw   R3e,[R74+2e]     MPH = R3e;                        # Filtered vehicle speed (2)
3d59: f0                  ret                    return;


#################################################################
# Update heated windshield flag - check for some frequency input
# Tasklist Routine at 2151, routine offset 10
# GUFB p. 10-8
#
# Inputs:
#  A3C (flag) - Air conditioning cycling switch; shared with heated windshield signal
#
# Input/output:
#  A3CTMR - Time in ms since last A3C transition; zeroed on transition
#  HWFLAG - Heated Windshield is on
#  HWFLGL - Latch; set to 1 when HWFLAG first set
#  HWTMR - Time in ms since A3CTMR > A3CTT
#  LSTA3C - Last state of A3C flag; updated on transition
#
# Clobbers: R30-R32, R34-R35
#
#################################################################

  Update_HWND:
3d5a: 51,80,ee,30         an3b  R30,Ree,80       R30 = Flags_ee & 80;              # A3C flag
3d5e: 5b,76,38,30,32      sb3b  R32,R30,[R76+38] R32 = R30 - LSTA3C;               # subtract from last state
3d63: df,08               je    3d6d             if (R32 != 0)  {                  # jump if no state change
3d65: c7,76,38,30         stb   R30,[R76+38]     LSTA3C = R30;                     # state changed - save current state
3d69: c3,76,2e,00         stw   R0,[R76+2e]      A3CTMR = 0; }                     #  and clear A3CTMR
#
3d6d: a3,76,2e,30         ldw   R30,[R76+2e]     R30 = A3CTMR;
3d71: 8b,f0,06,30         cmpw  R30,[Rf0+6]      
3d75: d1,04               jleu  3d7b             if ((uns) A3CTMR > A3CTT)  {      # 250mS
3d77: c3,76,30,00         stw   R0,[R76+30]      HWTMR = 0; }                      # clear HWTMR
#
3d7b: a3,76,30,34         ldw   R34,[R76+30]     R34 = HWTMR;
3d7f: 8b,f0,08,34         cmpw  R34,[Rf0+8]      
3d83: d1,0e               jleu  3d93             if ((uns) R34 > HWRT)  {          # 300mS
3d85: 39,e6,0b            jb    B1,Re6,3d93      if (HWFLAG == 0)  {               # defrost already on ?
3d88: 38,e6,08            jb    B0,Re6,3d93      if (HWFLGL == 0)  {               # jmp if HWFLGL - first time
3d8b: 91,02,e6            orb   Re6,2            HWFLAG = 1;
3d8e: 91,01,e6            orb   Re6,1            HWFLGL = 1;                       # set first time defrost on
3d91: 20,0c               sjmp  3d9f             return; } } }
#
3d93: 8b,f6,0a,30         cmpw  R30,[Rf6+a]      
3d97: d1,06               jleu  3d9f             if (A3CTMR <= ACRT) return;
3d99: 3f,ee,03            jb    B7,Ree,3d9f      if (A3C == 1) return;             # jmp if A3C - is AC on?
3d9c: 71,fd,e6            an2b  Re6,fd           HWFLAG = 0;                       # USED AS BASE ADDR FOR RPM TABLE BELOW
#
3d9f: f0                  ret                    return;


############## RPM calc tables ###################################
# first list is top word, second is bottom word of 32 bit variable
# used below, where  rpm*4 = value/PIP interval  (in IOtimer ticks)
##################################################################

3da0: fa,02               word    2fa                                              
3da2: fc,01               word    1fc
3da4: 7d,01               word    17d
3da6: 80,f0               word   f080                                              # = 2faf080 = 50,000,000 4 cyl
3da8: 55,a0               word   a055                                              # = 1fca055 = 33,333,333 6 cyl
3daa: 40,78               word   7840                                              # = 17d7840 = 25,000,000 8 cyl


#################################################################
# Update RPM variables - filtering as required and other stuff
# 0x108 (NBAR) RPM with filter 1
# 0x27C (NDBAR) RPM with filter 2
# Tasklist Routine at 2151, routine offset 14
# Rae (N) is raw RPM * 4
#
# Inputs:
#  DT12S, DT12S_H - ticks between most recent PIP rising edges
#  TSLPIP - ms since last PIP rising edge
#
# Input/output:
#  NBAR - rolling average RPM
#  NDBAR - rolling average RPM
#
# Outputs:
#  FIRST_PIP (flag) - cleared on stall
#  FUEL_IN_SYNC (flag) - cleared on stall
#  MNPIP
#  Mhpfd_neg (flag)
#  N - RPM x 4
#  N_BYTE - RPM/16
#  Piplim
#  SYNC_UP_FUEL (flag) - cleared on stall
#  SYNFLG (flag) - cleared on stall
#  TPtr (R92) - set to SPOUT On/Off events
#
# Clobbers: R14-R15, R32-R33, R36-R37, R3e-R3f
#
#################################################################

  Update_rpm:
#
# Engine Running Reinit Strategy
# GUFB p. 4-6
#
3dac: a1,33,03,14         ldw   R14,333          R14 = TSTALL;                     # = 800 ms (i.e. < 20 RPM)
3db0: 8b,72,be,14         cmpw  R14,[R72+be]                                       # time since last PIP rising edge, ms
3db4: d9,3b               jgtu  3df1             if ((uns) TSTALL <= TSLPIP)  {
#
# Stalled - Reinit
3db6: 01,36               clrw  R36              R36 = 0;                          # Set RPM = 0 (see below at 3e16)
3db8: 71,ef,2d            an2b  R2d,ef           FIRST_PIP = 0;
3dbb: b1,01,32            ldb   R32,1            R32 = 1;
#
3dbe: c7,74,ec,32         stb   R32,[R74+ec]     Inj_pip_cnt1 = R32;
3dc2: c7,74,ed,32         stb   R32,[R74+ed]     Inj_pip_cnt2 = R32;
3dc6: 71,2f,2e            an2b  R2e,2f           SYNC_UP_FUEL = 0;
                                                 SYNFLG = 0;
                                                 FUEL_IN_SYNC = 0;
3dc9: 9b,f8,1a,00         cmpb  R0,[Rf8+1a]      
3dcd: df,0d               je    3ddc             if (0 != CCDSW)  {                # Computer Controlled Dwell (not present on A9L)
#
# CCD logic
# Not present on A9L
#
3dcf: fa                  di                     disable ints;
3dd0: ff                  nop                    
3dd1: a1,96,22,92         ldw   R92,2296         TPtr = 2296;                      # short entry 2284 - SPOUT on 
3dd5: 91,08,4c            orb   R4c,8            Immediate = 1;
3dd8: ef,e2,e5            call  23bd             Send_HSO_Cmd();                   # send HSO command 55 ands lots of other stuff - spout?
3ddb: fb                  ei                     enable ints; }
#
3ddc: 9b,f8,19,00         cmpb  R0,[Rf8+19]      
3de0: df,0d               je    3def             if (0 != HP_HIDRES)  {            # HDRES not present on A9L
#
# HIDRES logic
# Not present on A9L
#
3de2: fa                  di                     disable ints;
3de3: ff                  nop                    
3de4: a1,9e,22,92         ldw   R92,229e         TPtr = 229e;                      # 2nd short entry 2284 - SPOUT off
3de8: 91,08,4c            orb   R4c,8            Immediate = 1;
3deb: ef,cf,e5            call  23bd             Send_HSO_Cmd();                   # send HSO command C5 ands lots of other stuff - spout?
3dee: fb                  ei                     enable ints; }
#
3def: 20,25               sjmp  3e16             goto 3e16; }
#
# Not stalled
#
# jump here from 0x3db4 (TSTALL > TSLPIP)
#
3df1: 33,4e,4e            jnb   B3,R4e,3e42      if (New_rpm == 1)  {              # Flag set by PIP rising edge handler
#
# Engine speed calculation
# GUFB p. 19-33
#
3df4: 71,f7,4e            an2b  R4e,f7           New_rpm = 0;
3df7: af,fe,07,30         ldzbw R30,[Rfe+7]      R30 = (uns)ENGCYL;                # PIPs/rev * 2 = 8
3dfb: a3,31,9c,3d,36      ldw   R36,[R30+3d9c]   R36 = [R30+3d9c];                 # Hi word from table
3e00: a3,31,a2,3d,34      ldw   R34,[R30+3da2]   R34 = [R30+3da2];                 # Lo word from table
3e05: a0,ba,38            ldw   R38,Rba          R38 = DT12S;                      # PIP-PIP interval low 16 bits 
3e08: ac,bc,3a            ldzbw R3a,Rbc          R3a = (uns)DT12SH;                # PIP-PIP interval high 8 bits
3e0b: 0f,30,38            norm  R38,R30          R30 = nrml(0);                    # Shift R38..R3b left until MSB is a 1
                                                                                   # R30 = number of bits shifted
                                                                                   # R3A-B = most significant 16 bits
3e0e: 8c,3a,34            divw  R34,R3a          R35:R34 = R37:R34 / R3B:R3a;      # divide. (val/pip time = RPM)
3e11: 01,36               clrw  R36              R36 = 0;                          # engine RPM is in bottom bits of LONG shift
3e13: 0d,30,34            shldw R34,R30          R37:R34 <<= R30;                  # shift result of divide left by number of bits we shifted divisor
#
# jump here from 3def (stalled && !HP_HIDRES)
#
# R36 = new RPM * 4
#
3e16: a0,36,ae            ldw   Rae,R36          N = R36;                          # N = RPM * 4
3e19: 08,06,36            shrw  R36,6            R36 /= 40;                        # divide by 64 to get N_BYTE (RPM / 16)
3e1c: 98,00,37            cmpb  R37,R0           
3e1f: df,03               je    3e24             if (R37 != 0)  {                  # if N > 4080
3e21: b1,ff,36            ldb   R36,ff           R36 = ff; }                       # clip to 4080 RPM max
#
3e24: c7,74,21,36         stb   R36,[R74+21]     N_BYTE = R36;                     # and store in N_BYTE
#
# Engine Speed Filters (NBAR, NDBAR)
# GUFB p. 19-34
#
3e28: ef,29,f8            call  3654             Urolav_3Arg(NBAR,N,97f4);
3e2b: 08,01,ae,00,4c,d0   #args  
3e31: c3,72,88,3e         stw   R3e,[R72+88]     NBAR = R3e;
3e35: ef,1c,f8            call  3654             Urolav_3Arg(NDBAR,N,9804);
3e38: 7c,02,ae,00,5c,d0   #args  
3e3e: c3,74,fe,3e         stw   R3e,[R74+fe]     NDBAR = R3e; }
#
# jump here from 0x3df1 (!New_rpm)
#
# Calculations from here to exit are all constants, should only have to be done once
#
3e42: a3,fc,2e,32         ldw   R32,[Rfc+2e]     R32 = PIPOUT;                     # = 0x100
3e46: 08,04,32            shrw  R32,4            R32 /= 10;                        # = 0x10
3e49: 7f,fc,33,32         ml2b  R32,[Rfc+33]     R32 *= OUTINJ;                    # OUTINJ = 1 if sequential, 2 if bank fire (1 in A9L)
3e4d: 9f,fc,32,32         divb  R32,[Rfc+32]     R32 /= NUMOUT;                    # NUMOUT = no of injector ports (8 in A9L)
3e51: c7,76,44,32         stb   R32,[R76+44]     Piplim = R32;                     # piplim = (0x100 >> 4) * 1 / 8 = 2

3e55: af,fe,07,14         ldzbw R14,[Rfe+7]      R14 = (uns)ENGCYL;                # PIPs/rev * 2
3e59: 69,04,00,14         sb2w  R14,4            R14 -= 4;                         # R14 is index (0,2,4)=(4,6,8 cyls)
3e5d: cb,15,c4,27         push  [R14+27c4]       push([R14+27c4]);                 # 27C4 [4] = 3200
3e61: cf,76,48            pop   [R76+48]         Seq_max = pop();
3e64: 64,f0,14            ad2w  R14,Rf0          R14 += Rf0;
3e67: cb,14,12            push  [R14+12]         push([R14+12]);                   # Min PIP Period = [RF0 + NUMCYL + 12] or *(&MNPIP4 + NUMCYL - 4)
3e6a: cf,76,46            pop   [R76+46]         MNPIP = pop();                    # Min PIP dly = 961

3e6d: 8b,fe,0e,00         cmpw  R0,[Rfe+e]                                         # MHPFD = 13107 in A9L = 20% of 65536
3e71: d6,05               jge   3e78             if (MHPFD < 0x8000)  {            #
3e73: 71,fb,25            an2b  R25,fb           Mhpfd_neg = 0;
3e76: 20,03               sjmp  3e7b             return; }
#
3e78: 91,04,25            orb   R25,4            Mhpfd_neg = 1;
#
3e7b: f0                  ret                    return;


#################################################################
# Tasklist Routine at 2151, routine offset 20
#################################################################

  Load_Calc:
3e7c: a3,f4,42,36         ldw   R36,[Rf4+42]     R36 = ARCHLK;
3e80: 9f,fe,07,36         divb  R36,[Rfe+7]      R36 /= ENGCYL;                    # PIPs/rev * 2
3e84: d5,03               jnv   3e89             if (OVF == 1)  {
3e86: b1,ff,36            ldb   R36,ff           R36 = ff; }
#
3e89: 11,37               clrb  R37              R37 = 0;
3e8b: 01,34               clrw  R34              R34 = 0;
3e8d: 8c,ae,34            divw  R34,Rae          R35:R34 = R37:R34 / N;
3e90: d5,03               jnv   3e95             if (OVF == 1)  {
3e92: bd,ff,34            ldsbw R34,ff           R34 = 0xffff; }
#
3e95: c3,74,d6,34         stw   R34,[R74+d6]     ARCHLI = R34;
3e99: 9b,f6,08,00         cmpb  R0,[Rf6+8]       
3e9d: df,05               je    3ea4             if (0 != ARCHSW)  {
3e9f: 91,02,26            orb   R26,2            Archflg = 1;
3ea2: 20,03               sjmp  3ea7             goto 3ea7; }
#
3ea4: 71,fd,26            an2b  R26,fd           Archflg = 0;
#
# Calculate ARCHCOR (airflow correction for low speed pulsation)
#  and AIR37 (max air charge vs RPM)
# GUFB p. 19-19
#
3ea7: 45,de,00,f0,32      ad3w  R32,Rf0,de       R32 = FN070;                      # spark RPM scaling
3eac: a0,ae,34            ldw   R34,Rae          R34 = N;
3eaf: ef,5a,f7            call  360c             UUWordLu();
3eb2: a0,38,a6            ldw   Ra6,R38          NRMCES = R38;
3eb5: 45,b2,00,f0,32      ad3w  R32,Rf0,b2       R32 = FN021;                      # load scaling
3eba: a3,74,de,34         ldw   R34,[R74+de]     R34 = LOAD;                       # raw engine load (VE)
3ebe: ef,4b,f7            call  360c             UUWordLu();
3ec1: a0,38,a8            ldw   Ra8,R38          NRMRLD = R38;
3ec4: a0,a6,30            ldw   R30,Ra6          R30 = NRMCES;
3ec7: a0,a8,32            ldw   R32,Ra8          R32 = NRMRLD;
3eca: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
3ecd: 45,22,01,fc,38      ad3w  R38,Rfc,122      R38 = FN1035;                     # Air Meter Backflow Correction Table(N, LOAD)
3ed2: ef,15,f8            call  36ea             UTabLookUp();
3ed5: c7,76,39,3b         stb   R3b,[R76+39]     ARCHCOR = R3b;
3ed9: 45,2e,02,f4,32      ad3w  R32,Rf4,22e      R32 = FN037;                      # Max airmass clip vs RPM
3ede: a0,ae,34            ldw   R34,Rae          R34 = N;
3ee1: ef,28,f7            call  360c             UUWordLu();
3ee4: c3,76,2c,38         stw   R38,[R76+2c]     AIR37 = R38;
#
# Filtered Air Mass Logic (idle)
# GUFB p. 9-45
#
# Calculate AM
#
3ee8: a3,74,d4,30         ldw   R30,[R74+d4]     R30 = ARCHG;                     # units = g x 27.1e-6
3eec: af,fe,07,32         ldzbw R32,[Rfe+7]      R32 = (uns)ENGCYL;               # PIPs/rev * 2
3ef0: 6c,32,30            ml2w  R30,R32          R33:R30 = R31:R30 * R33:R32;     # = ARCHG x 8 (2 revs), g x 27.1e-6
3ef3: 0c,03,30            shrdw R30,3            R33:R30 /= 8;                    # account for scale factors of 2 in ENGCYL, 4 in RPM
3ef6: 6c,ae,30            ml2w  R30,Rae          R33:R30 = R31:R30 * N;           # g * RPM, units g/min x 27.1e-6
3ef9: 0c,0e,30            shrdw R30,e            R33:R30 /= 4000;                 # / 16384
3efc: 88,00,32            cmpw  R32,R0           
3eff: df,03               je    3f04             if (R32 != 0)  {
3f01: bd,ff,30            ldsbw R30,ff           R30 = 0xffff; }                  # clip if overflow
#
3f04: c0,a2,30            stw   R30,Ra2          AM = R30;                        # units = .444 g/min = .0266 kg/hr
# 
3f07: a3,72,de,3e         ldw   R3e,[R72+de]     R3e = FAM;
3f0b: 08,01,3e            shrw  R3e,1            R3e /= 2;
#
# Check for tip-in from FAM to part throttle
#
3f0e: a3,72,a6,3c         ldw   R3c,[R72+a6]     R3c = RATCH;
3f12: 67,f4,6a,3c         ad2w  R3c,[Rf4+6a]     R3c += DELRAT;
3f16: 47,fe,24,3c,38      ad3w  R38,R3c,[Rfe+24] R38 = R3c + DLHYST;
3f1b: 88,aa,38            cmpw  R38,Raa          
3f1e: d3,22               jltu  3f42             if ((uns) R38 < TP) goto 3f42;    # possible tip-in
3f20: b3,72,e6,38         ldb   R38,[R72+e6]     R38 = DSDRPM;
3f24: 9b,fe,1e,38         cmpb  R38,[Rfe+1e]     
3f28: d9,18               jgtu  3f42             if ((uns) DSDRPM > AMDESN) goto 3f42; # desired idle RPM above FAM limit
3f2a: 77,fe,1f,38         ad2b  R38,[Rfe+1f]     R38 += AMRPM;
3f2e: db,2a               jc    3f5a             if (unsigned overflow) goto 3f5a;
3f30: 9b,74,21,38         cmpb  R38,[R74+21]     
3f34: db,24               jgeu  3f5a             if ((uns) DSDRPM + AMRPM >= N_BYTE) goto 3f5a; # actual RPM in FAM range
3f36: 77,fe,20,38         ad2b  R38,[Rfe+20]     R38 += AMRPMH;
3f3a: db,75               jc    3fb1             if (unsigned overflow) goto 3fb1;
3f3c: 9b,74,21,38         cmpb  R38,[R74+21]     
3f40: db,6f               jgeu  3fb1             if ((uns) DSDRPM + AMRPM + AMRPMH >= N_BYTE) goto 3fb1; # RPM alone not enough to leave FAM
#
# Exit FAM on tip-in, or DSDRPM > AMDESN, or actual RPM above FAM range
#
# R3E = FAM/2
#
3f42: 71,f7,ec            an2b  Rec,f7           REFFLG = 0;
3f45: a3,fe,26,3c         ldw   R3c,[Rfe+26]     R3c = IFAM;
3f49: 08,01,3c            shrw  R3c,1            R3c /= 2;
3f4c: 88,3c,3e            cmpw  R3e,R3c          
3f4f: d1,07               jleu  3f58             if ((uns) FAM > IFAM)  {
3f51: 09,01,3c            shlw  R3c,1            R3c *= 2;                         # Clip FAM to IFAM
3f54: c3,72,de,3c         stw   R3c,[R72+de]     FAM = R3c; }
#
3f58: 20,a2               sjmp  3ffc             goto 3ffc;
#
# Check tip-out to closed throttle and into FAM
# RPM is in the desired range
#
# R3C = RATCH + DELRAT
# R3E = FAM/2 ?
# 
3f5a: 88,aa,3c            cmpw  R3c,Raa          
3f5d: d3,52               jltu  3fb1             if ((uns) RATCH + DELRAT >= TP) { # Continue if throttle is closed
3f5f: 3b,ec,4f            jb    B3,Rec,3fb1      if (REFFLG == 0)  {
#
# Enter FAM region
#
3f62: 91,08,ec            orb   Rec,8            REFFLG = 1;
3f65: c3,72,b2,00         stw   R0,[R72+b2]      FFMTMR = 0;
3f69: af,fe,22,30         ldzbw R30,[Rfe+22]     R30 = (uns)EFAMPL;                # 0x80 = 1.00
3f6d: 6c,3e,30            ml2w  R30,R3e          R33:R30 = R31:R30 * R3f:R3e;
3f70: 0c,07,30            shrdw R30,7            R33:R30 /= 80;
3f73: 88,30,a2            cmpw  Ra2,R30          
3f76: db,05               jgeu  3f7d             if ((uns) AM < R30)  {            # Clip AM to low limit
3f78: a0,30,a2            ldw   Ra2,R30          AM = R30;
3f7b: 20,12               sjmp  3f8f             goto 3f8f; }
#
3f7d: af,fe,21,30         ldzbw R30,[Rfe+21]     R30 = (uns)EFAMPH;                # 0x80 = 1.00
3f81: 6c,3e,30            ml2w  R30,R3e          R33:R30 = R31:R30 * R3f:R3e;
3f84: 0c,07,30            shrdw R30,7            R33:R30 /= 80;
3f87: 88,30,a2            cmpw  Ra2,R30          
3f8a: d1,03               jleu  3f8f             if ((uns) AM > R30)  {            # Clip AM to high limit
3f8c: a0,30,a2            ldw   Ra2,R30          AM = R30; }
#
# Jump here from 3f7b, 3f8a
3f8f: a3,f4,4a,32         ldw   R32,[Rf4+4a]     R32 = FAMINC;
3f93: 0a,01,32            asrw  R32,1            R32 /= 2;
3f96: 44,a2,32,3e         ad3w  R3e,R32,Ra2      R3e = FAMINC / 2 + AM;
3f9a: 3f,33,07            jb    B7,R33,3fa4      if (FAMINC / 2 < 0) goto 3fa4;
3f9d: d3,09               jnc   3fa8             if ((uns) R3e >= 0)  {
3f9f: bd,ff,3e            ldsbw R3e,ff           R3e = 0xffff;                    # Add overflowed, clip result
3fa2: 20,04               sjmp  3fa8             goto 3fa8;
#
# FAMINC is negative, clip FAM to 0 on underflow
3fa4: db,02               jc    3fa8             if (R3e > 0)  {
3fa6: 01,3e               clrw  R3e              R3e = 0; } }
#
# Jump here from 3f9d, 3fa2
3fa8: 09,01,3e            shlw  R3e,1            R3e *= 2;
3fab: c3,72,de,3e         stw   R3e,[R72+de]     FAM = R3e;
3faf: 20,45               sjmp  3ff6             goto 3ff6; } }
#
# FAM update delay
#
# R3E = FAM/2
#
3fb1: 33,ec,42            jnb   B3,Rec,3ff6      if (REFFLG == 0) goto 3ff6;
3fb4: 48,3e,a2,40         sb3w  R40,Ra2,R3e      R40 = AM - R3e;
3fb8: d6,02               jge   3fbc             if (R40 < 0)  {
3fba: 03,40               negw  R40              R40 = -R40; }                     # R40 = |AM - FAM/2|
#
3fbc: a3,f4,7e,34         ldw   R34,[Rf4+7e]     R34 = FAMLIM;
3fc0: 6c,a2,34            ml2w  R34,Ra2          R37:R34 = AM * FAMLIM;
3fc3: 88,36,40            cmpw  R40,R36          
3fc6: d1,2e               jleu  3ff6             if ((uns) R40 <= R36) goto 3ff6;  # jmp if outside limit
3fc8: b3,72,ea,34         ldb   R34,[R72+ea]     R34 = BGCNT;
3fcc: 17,34               incb  R34              R34++;
3fce: 9b,f4,6c,34         cmpb  R34,[Rf4+6c]     
3fd2: d3,24               jltu  3ff8             if ((uns) R34 >= SAMRAT)  {       # Time to update
3fd4: a0,3e,32            ldw   R32,R3e          R32 = R3e;                        # old FAM
3fd7: a0,a2,34            ldw   R34,Ra2          R34 = AM;                         # current AM
3fda: a3,fa,4a,36         ldw   R36,[Rfa+4a]     R36 = TCFAM;                      # time constant
3fde: a3,72,b2,3e         ldw   R3e,[R72+b2]     R3e = FFMTMR;                     # Timer
3fe2: c3,72,b2,00         stw   R0,[R72+b2]      FFMTMR = 0;                       # Reset FFMTMR
3fe6: 91,01,ca            orb   Rca,1            Asp_input = 1;
3fe9: ef,77,f6            call  3663             Urolav();
3fec: 09,01,3e            shlw  R3e,1            R3e *= 2;
3fef: c3,72,de,3e         stw   R3e,[R72+de]     FAM = R3e;                        # Store new FAM
3ff3: 08,01,3e            shrw  R3e,1            R3e /= 2;
#
# Jump here from 3fb1, 3fc6
3ff6: 11,34               clrb  R34              R34 = 0; }                        # Reset BGCNT
#
# Jump here from 3fd2
3ff8: c7,72,ea,34         stb   R34,[R72+ea]     BGCNT = R34;                      # Save new BGCNT
#
# Jump here from 3f58
3ffc: 3b,ec,0f            jb    B3,Rec,400e      if (REFFLG == 0)  {
3fff: 11,32               clrb  R32              R32 = 0;
4001: 20,03               sjmp  4006             goto 4006;
#
# Jump here from 4020
4003: b1,80,32            ldb   R32,80           R32 = 80;
#
# Jump here from 4001
4006: 71,f7,25            an2b  R25,f7           FAM_FLG = 0;
4009: a0,a2,3e            ldw   R3e,Ra2          R3e = AM;
400c: 20,2c               sjmp  403a             goto 403a; }
#
# Jump here from 3ffc
# R3E (word) = FAM/2
400e: b1,ff,32            ldb   R32,ff           R32 = ff;
4011: a3,fe,1c,34         ldw   R34,[Rfe+1c]     R34 = DELTAM;                     # = 0
4015: 6c,3e,34            ml2w  R34,R3e          R37:R34 = R35:R34 * R3f:R3e;
4018: 0d,01,34            shldw R34,1            R37:R34 *= 2;
401b: db,08               jc    4025             if (unsigned overflow) goto 4025;
401d: 88,36,a2            cmpw  Ra2,R36          
4020: d9,e1               jgtu  4003             if ((uns) AM > R36) goto 4003;
4022: 91,08,25            orb   R25,8            FAM_FLG = 1;
#
4025: a3,f5,80,00,34      ldw   R34,[Rf4+80]     R34 = MAXFAM;                     # = A0
402a: 6c,a2,34            ml2w  R34,Ra2          R37:R34 = R35:R34 * AM;
402d: 0d,01,34            shldw R34,1            R37:R34 *= 2;
4030: db,08               jc    403a             if (!unsigned overflow)  {
4032: 88,36,3e            cmpw  R3e,R36          
4035: d1,03               jleu  403a             if ((uns) (FAM/2) > R36 )  {
4037: a0,36,3e            ldw   R3e,R36          R3e = R36; } }
#
# Jump here from 400c, 4030, 4035
# R3E (word) = AM or FAM/2
403a: 8b,fe,1a,3e         cmpw  R3e,[Rfe+1a]     
403e: db,04               jgeu  4044             if (R3e < MINAM)  {
4040: a3,fe,1a,3e         ldw   R3e,[Rfe+1a]     R3e = MINAM; }
#
4044: c0,a2,3e            stw   R3e,Ra2          AM = R3e;
4047: c7,72,e7,32         stb   R32,[R72+e7]     Famreg = R32;
404b: af,74,0a,38         ldzbw R38,[R74+a]      R38 = (uns)EM;                    # EGR Mass Flow
404f: 09,03,38            shlw  R38,3            R38 *= 8;
4052: 64,a2,38            ad2w  R38,Ra2          R38 += AM;
4055: d3,03               jnc   405a             if ((uns) R38 >= 0)  {
4057: bd,ff,38            ldsbw R38,ff           R38 = 0xffff; }                  # clamp max to FFFF
#
405a: a0,38,a4            ldw   Ra4,R38          AMPEM = R38;
#
# Compute LOAD from ARCHG and SARCHG
# GUFB p. 19-13
#
405d: a3,74,d4,3e         ldw   R3e,[R74+d4]     R3e = ARCHG;
4061: 01,3c               clrw  R3c              R3c = 0;
4063: 0c,03,3c            shrdw R3c,3            R3f:R3c /= 8;

# SARCHG - "engine displacement" = 1B4A = 6986 dec. (unit = 0.0430981 Cubic Inches)
# Actually the mass of a single cylinder's swept volume at specified temp & BP

4066: 8f,f4,44,3c         divw  R3c,[Rf4+44]     R3d:R3c = R3f:R3c / SARCHG;
406a: d5,03               jnv   406f             if (OVF == 1)  {
406c: bd,ff,3c            ldsbw R3c,ff           R3c = 0xffff; }                   # clamp max to FFFF
#
406f: c3,74,de,3c         stw   R3c,[R74+de]     LOAD = R3c;                       # Set engine load (100% = 0x8000)
#
# Calculate PEAK_LOAD, PERLOAD
# GUFB p. 19-14
#
4073: 45,12,02,fc,32      ad3w  R32,Rfc,212      R32 = FN035;                      # Peak load vs RPM at sea level
4078: a0,ae,34            ldw   R34,Rae          R34 = N;
407b: ef,8e,f5            call  360c             UUWordLu();
407e: af,74,80,30         ldzbw R30,[R74+80]     R30 = (uns)BP;
4082: 6c,38,30            ml2w  R30,R38          R33:R30 = R31:R30 * R39:R38;      # BP * FN035(N)
4085: 8d,ef,00,30         divw  R30,ef           R31:R30 = R33:R30 / 0xef;         # scaled to sea level (29.875" Hg)
4089: d5,03               jnv   408e             if (OVF == 1)  {
408b: bd,ff,30            ldsbw R30,ff           R30 = 0xffff; }                   # clamp max to 0xffff
#
408e: c3,74,e0,30         stw   R30,[R74+e0]     PEAK_LOAD = R30;
4092: 9b,fc,02,00         cmpb  R0,[Rfc+2]       
4096: d7,10               jne   40a8             if (0 == PRLDSW)  {               # Use LOAD/PEAK_LOAD for PERLOAD
4098: a0,3c,3e            ldw   R3e,R3c          R3e = R3c;
409b: 01,3c               clrw  R3c              R3c = 0;
409d: 0c,01,3c            shrdw R3c,1            R3f:R3c /= 2;                     # div by 2
40a0: 8c,30,3c            divw  R3c,R30          R3d:R3c = R3f:R3c / R31:R30;      # air flow / (RPM * CID) = VE (=LOAD)
40a3: d5,03               jnv   40a8             if (OVF == 1)  {
40a5: bd,ff,3c            ldsbw R3c,ff           R3c = 0xffff; } }                 # clamp max to FFFF
#
40a8: c3,74,e2,3c         stw   R3c,[R74+e2]     PERLOAD = R3c;                    # Relative Volumetric Efficiency
40ac: ef,a5,f5            call  3654             Urolav_3Arg(AELOAD,LOAD,ldffact);
40af: 1c,02,5c,02,54,d0   #args  
40b5: c3,74,9e,3e         stw   R3e,[R74+9e]     AELOAD = R3e;                     # Save filtered Load
40b9: f0                  ret                    return;


#################################################################
# Filter EGR, TP sensor data, 
# Tasklist Routine at 2151, routine offset 24
#################################################################

  Update_Egr:
40ba: 36,e6,4a            jnb   B6,Re6,4107      if (Pfehp_flg == 0) goto 4107;    # Jump if PFE EGR not present
                                                                                   # (Sonic EGR in A9L)
#
# PFE EGR Filtering
# GUFB p. 19-29
#
40bd: 3f,a1,3c            jb    B7,Ra1,40fc      if (CRKFLG == 0)  {
40c0: ef,91,f5            call  3654             Urolav_3Arg(EPTBAR,IEVP,TCEPT);
40c3: 04,01,16,01,48,d0   #args  
40c9: c3,72,84,3e         stw   R3e,[R72+84]     EPTBAR = R3e;                     # save result
40cd: 37,d0,2a            jnb   B7,Rd0,40fa      if (APT == -1)  {
40d0: 77,fa,30,00         ad2b  R0,[Rfa+30]      R0 += EPTSW;
40d4: df,24               je    40fa             if (R0 != 0)  {
40d6: af,72,e6,30         ldzbw R30,[R72+e6]     R30 = (uns)DSDRPM;                # 166
40da: 09,06,30            shlw  R30,6            R30 *= 40;
40dd: 67,fa,32,30         ad2w  R30,[Rfa+32]     R30 += IERPMH;
40e1: 88,30,ae            cmpw  Rae,R30          
40e4: d9,14               jgtu  40fa             if ((uns) N <= R30)  {
40e6: 9b,fa,34,b0         cmpb  Rb0,[Rfa+34]     
40ea: de,0e               jlt   40fa             if (ECT >= CTEHI)  {
40ec: ef,65,f5            call  3654             Urolav_3Arg(EPTZER,IEVP,TCEPT);
40ef: ee,07,16,01,48,d0   #args  
40f5: c3,01,ee,07,3e      stw   R3e,[R0+7ee]     EPTZER = R3e; } } } }            # Save result
40fa: 20,27               sjmp  4123             goto 4123; }
#
40fc: a3,01,ee,07,30      ldw   R30,[R0+7ee]     R30 = EPTZER;                    # filtered result EVP 2
4101: c3,72,84,30         stw   R30,[R72+84]     EPTBAR = R30;                    # filtered result EVP 1
4105: 20,39               sjmp  4140             goto 4140;
#
# Sonic EGR filtering
# GUFB p. 19-28
#
4107: 37,a1,02            jnb   B7,Ra1,410c      if (CRKFLG == 1)  {
410a: 20,34               sjmp  4140             return; }
410c: ef,45,f5            call  3654             Urolav_3Arg(EGRBAR,EVP,TCEGR);
410f: 02,01,70,01,60,d0   #args  
4115: c3,72,82,3e         stw   R3e,[R72+82]     EGRBAR = R3e;                   # Update rolling average
4119: 8b,72,a8,3e         cmpw  R3e,[R72+a8]     
411d: db,04               jgeu  4123             if ((uns) R3e < EOFF)  {
411f: c3,72,a8,3e         stw   R3e,[R72+a8]     EOFF = R3e; }
#
# TP filtering (TPBAR, RATCH)
# GUFB pp 19-42, 19-43
#
4123: ef,2e,f5            call  3654             Urolav_3Arg(TPBAR,TP,TCTP);
4126: 00,01,aa,00,4e,d0   #args  
412c: c3,72,80,3e         stw   R3e,[R72+80]     TPBAR = R3e;                      # Save result
4130: 89,08,07,ae         cmpw  Rae,708                                            # RPM <= 450 RPM ?
4134: d1,0a               jleu  4140             if ((uns) N <= 450 RPM) return;
4136: 8b,72,a6,3e         cmpw  R3e,[R72+a6]     
413a: db,04               jgeu  4140             if ((uns) TPBAR >= RATCH) return;
413c: c3,72,a6,3e         stw   R3e,[R72+a6]     RATCH = R3e;                      # update to smaller Min TP Closed position
#
4140: f0                  ret                    return;


#################################################################
# Check for RPM and Speed limiters
# Tasklist Routine at 2151, routine offset 26
# RPM values here are RPM * 4
# Overspeed RPM, sets fuel cutoff rev limiter
# GUFB p. 6-92
#################################################################

  Check_spd_lim:
#
# RPM limit check
# Activates fuel cutoff if N > NLM_SH
#
4141: 45,04,00,fc,42      ad3w  R42,Rfc,4        R42 = NLM_SH;
4146: 8a,43,ae            cmpw  Rae,[R42++]      
4149: d1,03               jleu  414e             if ((uns) N > [R42++] )  {
414b: 91,08,2f            orb   R2f,8            NLMT_FLG = 1; }                   # Activate fuel cutoff
#
# Check if under fuel re-enable RPM (NLM_CL)
#
414e: 8a,43,ae            cmpw  Rae,[R42++]                                        # = NLM_CL
4151: db,03               jgeu  4156             if (N < [R42++])  {               #
4153: 71,f7,2f            an2b  R2f,f7           NLMT_FLG = 0; }                   # Deactivate fuel cutoff
#
# Vehicle speed limit check
#
# Note that all these limits are set to FF in the A9L calibration,
# and the limiter activation comparisons are strictly greater-than,
# therefore they are effectively disabled.
#
4156: 9b,f2,47,00         cmpb  R0,[Rf2+47]      
415a: d7,07               jne   4163             if (0 == VSTYPE)  {               # VSTYPE = 1 on A9L
415c: 71,fb,e7            an2b  Re7,fb           HSPFLG = 0;                       # No speed sensor, so return
415f: 71,fe,e7            an2b  Re7,fe           FOFFLG = 0;
4162: f0                  ret                    return; }
#
4163: b3,74,3f,30         ldb   R30,[R74+3f]     R30 = VSBAR_H;                    # vehicle speed filtered(1)
4167: 9a,43,30            cmpb  R30,[R42++]                                        # = VVS_SH (stage 2 speed limiter on threshold)
416a: d1,03               jleu  416f             if ((uns) VSBAR_H > [R42++] )  {
416c: 91,20,25            orb   R25,20           Slq1 = 1; }                       # Turn on speed limiter
#
416f: 9a,43,30            cmpb  R30,[R42++]                                        # = VVS_CL (stage 2 speed limiter off threshold)
4172: db,03               jgeu  4177             if ((uns) VSBAR_H < [R42++])  {
4174: 71,df,25            an2b  R25,df           Slq1 = 0; }                       # Turn off speed limiter
#
4177: 9a,43,30            cmpb  R30,[R42++]                                        # = HVS_SH
417a: d9,0d               jgtu  4189             if ((uns) R30 > [R42++] ) goto 4189; # jump if speed > HVS_SH
417c: 38,e7,0a            jb    B0,Re7,4189      if (FOFFLG == 1) goto 4189;       # or half fuel speed limiter on
417f: 9a,42,30            cmpb  R30,[R42]                                          # = HVS_CL
4182: db,08               jgeu  418c             if (R30 < [R42])  {               # jmp if speed >= ROM limit
4184: 71,ef,25            an2b  R25,ef           Slq2 = 0;                         # Turn off high speed enrich & retard
4187: 20,03               sjmp  418c             goto 418c;
#
# Jump here from:
#  417a (VSBAR_H >= HVS_SH)
#  417c (FOFFLG set)
#
4189: 91,10,25            orb   R25,10           Slq2 = 1; }
#
# Jump here from:
#  4182 (VSBAR_H >= HVS_CL)
#
418c: 35,25,04            jnb   B5,R25,4193      if (Slq1 == 1)  {
418f: 91,01,e7            orb   Re7,1            FOFFLG = 1;                       # Activate half fuel speed limiter
4192: f0                  ret                    return; }
#
4193: 34,25,07            jnb   B4,R25,419d      if (Slq2 == 1)  {
4196: 91,04,e7            orb   Re7,4            HSPFLG = 1;                       # Activate high speed fuel enrichment & spark retard
4199: 71,fe,e7            an2b  Re7,fe           FOFFLG = 0;                       # Deactivate half fuel speed limiter
419c: f0                  ret                    return; }
#
419d: 71,fb,e7            an2b  Re7,fb           HSPFLG = 0;                       # Deactivate high speed fuel enrichment & spark retard
41a0: f0                  ret                    return;


#################################################################
# Tasklist Routine at 2151, routine offset 28
# Update lugging open loop mode
# GUFB p. 6-20
# Update warm EGO flags
#################################################################

  Update_clolp:
41a1: a3,fa,0e,30         ldw   R30,[Rfa+e]      R30 = LDMH;
41a5: 47,fa,10,30,32      ad3w  R32,R30,[Rfa+10] R32 = R30 + LDMHH;
41aa: 8b,74,e2,32         cmpw  R32,[R74+e2]                                       # 260 Volumetric Efficiency
41ae: d9,05               jgtu  41b5             if ((uns) R32 <= PERLOAD)  {
41b0: 91,01,e9            orb   Re9,1            Prld_ff = 1;                      # PERLOAD above lug threshold
41b3: 20,09               sjmp  41be             goto 41be; }
#
41b5: 8b,74,e2,30         cmpw  R30,[R74+e2]                                       # 260 Volumetric Efficiency
41b9: d1,03               jleu  41be             if ((uns) R30 > PERLOAD )  {
41bb: 71,fe,e9            an2b  Re9,fe           Prld_ff = 0; }                    # PERLOAD below lug threshold
#
41be: 30,e9,21            jnb   B0,Re9,41e2      if (Prld_ff == 1)  {
41c1: 38,d0,1e            jb    B0,Rd0,41e2      if (APT == 0)  {
#
# Load above threshold, at part throttle; check ECT
41c4: 9b,fa,0a,b0         cmpb  Rb0,[Rfa+a]
41c8: da,18               jle   41e2             if ((uns) ECT < LDEL)  {
41ca: 9b,fa,0b,b0         cmpb  Rb0,[Rfa+b]
41ce: d6,12               jge   41e2             if (ECT < LDEH)  {
#
# Now check timer
41d0: b3,72,c5,42         ldb   R42,[R72+c5]     R42 = LUGTMR;
41d4: 9b,fa,0d,42         cmpb  R42,[Rfa+d]      
41d8: d3,08               jltu  41e2             if ((uns) R42 >= LDLTM)  {
41da: 31,ef,05            jnb   B1,Ref,41e2      if (WMEGOL == 1)  {                # jmp if not WMEGOL
#
# All conditions met, set LDFLG
41dd: 91,02,e9            orb   Re9,2            LDFLG = 1;
41e0: 20,03               sjmp  41e5             goto 41e5; } } } } } }
#
# Conditions not met for lugging open loop
#
41e2: 71,fd,e9            an2b  Re9,fd           LDFLG = 0;

#################################################################
# WRMEGO logic
# GUFB p. 6-12
#################################################################

41e5: 45,0e,00,fc,30      ad3w  R30,Rfc,e        R30 = &OPCLT3;
41ea: ef,62,f5            call  374f             Check_Timers();
41ed: db,10               jc    41ff             if (timers pass)  {
41ef: b3,74,26,30         ldb   R30,[R74+26]     R30 = EGOSSS;
41f3: 9b,fc,1a,30         cmpb  R30,[Rfc+1a]                                       # EGOCL1
41f7: d3,06               jltu  41ff             if (EGOSSS >= EGOCL1)  {
41f9: 91,04,ef            orb   Ref,4            WRMEGO = 1;
41fc: 91,02,ef            orb   Ref,2            WMEGOL = 1; } }


#################################################################
# Open/closed loop determination
# GUFB p. 6-11
# Local state: (value persists to next iteration if not modified,
#   i.e. if value falls between threshold & threshold w/ hysteresis)
#  Qclol - set if LOAD > LOLOD, cleared if LOAD < LOLOD - LOLODH
#  Qtpclol - set if TP <= RATCH + THBP5, cleared if TP > RATCH + THBP5 + HYST2
#  HLTMR_Off - set if PERLOAD < FN320A(ECT), cleared if PERLOAD > FN320A(ECT) + HLODH
#################################################################

41ff: a3,fc,1c,32         ldw   R32,[Rfc+1c]     R32 = LOLOD;                      # open loop min load(min load for OL control)
4203: 8b,74,de,32         cmpw  R32,[R74+de]                                       # engine load (VE)
4207: db,05               jgeu  420e             if (LOLOD < LOAD)  {
# 
4209: 91,08,ee            orb   Ree,8            Qclol = 1;
420c: 20,0f               sjmp  421d             goto 421d; }
# LOAD <= LOLOD - check hysteresis
420e: 6b,fc,1e,32         sb2w  R32,[Rfc+1e]     R32 -= LOLODH;                    # min load for closed loop
4212: d3,09               jltu  421d             if ((uns) R32 >= 0)  {
4214: 8b,74,de,32         cmpw  R32,[R74+de]                                       # engine load (VE)
4218: d1,03               jleu  421d             if (LOLOD - LOLODH > LOAD)  {
421a: 71,f7,ee            an2b  Ree,f7           Qclol = 0; } }
#
# HLTMR logic
# GUFB p. 20-18
#
421d: 45,2e,02,fc,32      ad3w  R32,Rfc,22e      R32 = FN320A;                     # Upper PERLOAD limit for Closed Loop fuel vs ECT
4222: bc,b0,34            ldsbw R34,Rb0          R34 = (int)ECT;
4225: ef,d9,f3            call  3601             SUWordLU();
#
4228: 8b,74,e2,38         cmpw  R38,[R74+e2]     
422c: d1,05               jleu  4233             if ((uns) R38 > PERLOAD)  {
422e: 91,01,29            orb   R29,1            HLTMR_Off = 1;
4231: 20,12               sjmp  4245             goto 4245; }
#
# Jump here from:
#  422c
#
4233: 67,fc,20,38         ad2w  R38,[Rfc+20]     R38 += HLODH;                     # Hysteresis term for FN320A(ECT)
4237: d3,03               jnc   423c             if ((uns) R38 >= 0)  {
4239: bd,ff,38            ldsbw R38,ff           R38 = 0xffff; }
#
# Jump here from:
#  4237
#
423c: 8b,74,e2,38         cmpw  R38,[R74+e2]     
4240: db,03               jgeu  4245             if (R38 > PERLOAD)  {
4242: 71,fe,29            an2b  R29,fe           HLTMR_Off = 0; }
#
# Jump here from:
#  4231
#  4240
#
4245: a3,fc,14,38         ldw   R38,[Rfc+14]     
4249: 67,72,a6,38         ad2w  R38,[R72+a6]     R38 = THBP5 + RATCH;              # open loop TP threshold
424d: db,05               jc    4254             if (unsigned overflow) goto 4254;
424f: 88,aa,38            cmpw  R38,Raa          
4252: d3,05               jltu  4259             if ((uns) R38 >= TP)  {
#
# Jump here from:
#  424d (THBP5 + RATCH overflowed, threshold unreachable)
#
# TP below open loop threshold - set closed loop
#
4254: 91,04,29            orb   R29,4            Qtpclol = 1;
4257: 20,0e               sjmp  4267             goto 4267; }
#
# Jump here from:
#  4252 (THBP5 + RATCH < TP)
#
# Check open loop threshold hysteresis
#
4259: 67,fa,04,38         ad2w  R38,[Rfa+4]      R38 += TP_hysts2;                 # Hysteresis term to enter WOT mode
425d: db,08               jc    4267             if (unsigned overflow) goto 4267;
425f: 88,aa,38            cmpw  R38,Raa          
4262: db,03               jgeu  4267             if (R38 > TP)  {
#
# Above threshold + hyst - Set open loop
4264: 71,fb,29            an2b  R29,fb           Qtpclol = 0; } }
#
# Jump here from:
#  4257 (THBP5 + RATCH >= TP)
#  425d ((THBP5 + RATCH) + TP_hysts2 overflowed, threshold unreachable)
#  4262 (THBP5 + RATCH + TP_hysts2 > TP)
#
4267: 33,ee,49            jnb   B3,Ree,42b3      if (Qclol == 1)  {
426a: 32,29,46            jnb   B2,R29,42b3      if (Qtpclol == 1)  {
426d: 32,ef,43            jnb   B2,Ref,42b3      if (WRMEGO == 1)  {
4270: 9b,fc,53,b3         cmpb  Rb3,[Rfc+53]     
4274: d7,3d               jne   42b3             if (PPCTR = PIPNUM)  {            # JNE patched to SJMP by Z_OLSW in GUFB.xls
4276: 36,25,3a            jnb   B6,R25,42b3      if (CHKAIR == 1)  {
4279: 3a,e7,37            jb    B2,Re7,42b3      if (HSPFLG == 0)  {
427c: 39,e9,34            jb    B1,Re9,42b3      if (LDFLG == 0)  {
427f: 30,d0,0a            jnb   B0,Rd0,428c      if (APT == 0) goto 428c;
#
# Not at part throttle
#
4282: b3,72,c4,32         ldb   R32,[R72+c4]     R32 = CTNTMR;
4286: 9b,f4,72,32         cmpb  R32,[Rf4+72]     
428a: d9,27               jgtu  42b3             if ((uns) CTNTMR <= NIOLD)  {
#
# Jump here from:
#  427f (at part throttle)
#
428c: 30,ec,06            jnb   B0,Rec,4295      if (MFAFLG == 0) goto 4295;
428f: 9b,f4,07,00         cmpb  R0,[Rf4+7]       
4293: d7,1e               jne   42b3             if (0 == MFASW)  {
#
# Jump here from:
#  428c (!MFAFLG)
#
4295: 38,29,0a            jb    B0,R29,42a2      if (HLTMR_Off == 1) goto 42a2;
4298: b3,72,cc,32         ldb   R32,[R72+cc]     R32 = HLTMR;                      # High load timer - 1/8 seconds under high load so far
429c: 9b,fc,22,32         cmpb  R32,[Rfc+22]                                       # time at high load to force Open loop
42a0: d9,11               jgtu  42b3             if ((uns) HLTMR <= HLCTM)  {
#
# Jump here from:
#  4295 (HLTMR_Off)
#
42a2: 32,ee,03            jnb   B2,Ree,42a8      if (OLFLG == 1)  {
42a5: 91,01,eb            orb   Reb,1            Ol_cl_transition = 1; }
#
# Jump here from:
#  42a2 (!OLFLG, i.e. was already in closed loop)
#
# Closed Loop return
#
42a8: 71,fb,ee            an2b  Ree,fb           OLFLG = 0;
42ab: b1,01,34            ldb   R34,1            R34 = 1;                          # 1 = closed loop control mode
42ae: c7,74,92,34         stb   R34,[R74+92]     CLFLG = R34;
42b2: f0                  ret                    return; } } } } } } } } } }
#
# Jump here from:
#  4267
#  426a
#  426d
#  4274
#  4276
#  4279
#  427c
#  428a
#  4293
#  42a0
#
# Open Loop return
42b3: 91,04,ee            orb   Ree,4            OLFLG = 1;
42b6: c7,74,92,00         stb   R0,[R74+92]      CLFLG = 0;                        # set open loop
42ba: b1,01,34            ldb   R34,1            R34 = 1;
42bd: c7,74,ea,34         stb   R34,[R74+ea]     ENPIP1 = 1;                       # Expected # of PIPs between EGO #1 switches
42c1: c7,74,eb,34         stb   R34,[R74+eb]     ENPIP2 = 1;                       # ""       # "" ""   ""      ""  #2 ""
42c5: f0                  ret                    return;

#
# Subroutine of Calc_BG_Fuel
# 

  Calc_CL_Fuel:
42c6: 01,14               clrw  R14              R14 = 0;
42c8: 01,16               clrw  R16              R16 = 0;
#
# Closed Loop LAMBSE1 and LAMBSE2 logic
# GUFB p. 6-33
#
42ca: 39,ed,21            jb    B1,Red,42ee      if (LEGOFG1 == 1) goto 42ee;      # jump if EGO #1 not switching
#
# EGO #1 is apparently working
42cd: 71,fd,ee            an2b  Ree,fd           EGOFL = 0;
42d0: 37,ea,03            jnb   B7,Rea,42d6      if (EGOFL1 == 1)  {               # EGO #1 rich
42d3: 91,02,ee            orb   Ree,2            EGOFL = 1; }                      
#
42d6: 71,fe,ee            an2b  Ree,fe           SWTFL = 0; 
42d9: 33,27,03            jnb   B3,R27,42df      if (SWTFL1 == 1)  {               # EGO #1 switched
42dc: 91,01,ee            orb   Ree,1            SWTFL = 1; }
#
42df: 28,85               scall 4366             Sub11();                          # Update LAMBSE1
42e1: 38,ed,23            jb    B0,Red,4307      if (LEGOFG2 == 0)  {              # jump if EGO #2 not switching
42e4: af,fe,16,16         ldzbw R16,[Rfe+16]     R16 = (uns)NUMEGO;                # no of HEGOs
42e8: 31,16,1c            jnb   B1,R16,4307      if (B1_R16 == 1)  {
42eb: ad,01,14            ldzbw R14,1            R14 = (uns)1;
#
# EGO #2 is apparently working
# Jump here from 42ca (EGO #1 not switching)
42ee: 71,fd,ee            an2b  Ree,fd           EGOFL = 0;
42f1: 36,ea,03            jnb   B6,Rea,42f7      if (EGOFL2 == 1)  {               # EGO #2 rich
42f4: 91,02,ee            orb   Ree,2            EGOFL = 1; }
42f7: 71,fe,ee            an2b  Ree,fe           SWTFL = 0;
42fa: 30,27,03            jnb   B0,R27,4300      if (SWTFL2 == 1)  {               # EGO #2 switched
42fd: 91,01,ee            orb   Ree,1            SWTFL = 1; }
4300: 28,64               scall 4366             Sub11();                          # Update LAMBSE2
4302: 39,ed,02            jb    B1,Red,4307      if (LEGOFG1 == 1) goto 4307;      # jump if EGO #1 not switching
4305: 20,08               sjmp  430f             goto 430f; } }
#
# Jump here from 42e1 (EGO1 OK, EGO #2 not switching), 42e8 (Mono EGO), 4302 (EGO2 OK, EGO #1 not switching)
4307: a3,74,8c,42         ldw   R42,[R74+8c]     R42 = LAMBSE1;                    # Desired air/fuel ratio for the right side bank
430b: c3,74,8e,42         stw   R42,[R74+8e]     LAMBSE2 = R42;                    # Desired air/fuel ratio for the left side bank
#
# Lambda Reset Logic
# GUFB pp. 6-34, 6-35
#
# Jump here from 4305 (both EGOs working)
#
430f: 3b,ec,16            jb    B3,Rec,4328      if (REFFLG == 1) goto 4328;       # Jump if idling (conditions met for Filtered Air Mass mode)
4312: 33,26,1b            jnb   B3,R26,4330      if (JMPFLG == 1)  {
#
# Exiting Filtered Air Mass region
4315: 71,f7,26            an2b  R26,f7           JMPFLG = 0;
4318: 01,16               clrw  R16              R16 = 0;
431a: a3,fc,26,34         ldw   R34,[Rfc+26]     R34 = LAMMIN;
431e: 29,f3               scall 4513             Sub12();
4320: 07,16               incw  R16              R16++;
4322: 07,16               incw  R16              R16++;
4324: 29,ed               scall 4513             Sub12();
4326: 20,08               sjmp  4330             goto 4330;
#
# Idling (conditions met for FAM mode)
4328: 3b,26,05            jb    B3,R26,4330      if (JMPFLG == 0)  {
# Entering Filtered Air Mass region
432b: 91,08,26            orb   R26,8            JMPFLG = 1;
432e: 28,1b               scall 434b             Clip_LAMBSE(); } }
#
4330: 37,d0,0c            jnb   B7,Rd0,433f      if (APT < 0)  {
4333: b3,72,eb,38         ldb   R38,[R72+eb]     R38 = ISFLAG;
4337: 9b,72,ec,38         cmpb  R38,[R72+ec]     
433b: df,02               je    433f             if (ISFLAG != ISLAST)  {
# Load state change at idle
433d: 28,0c               scall 434b             Clip_LAMBSE(); } }
# Transition from open loop to closed loop
433f: 30,eb,23            jnb   B0,Reb,4365      if (Ol_cl_transition == 0) return;
4342: 9b,fe,0a,00         cmpb  R0,[Rfe+a]       
4346: df,1d               je    4365             if (0 == LAMSW) return;
4348: 71,fe,eb            an2b  Reb,fe           Ol_cl_transition = 0;

#
# Clip both LAMBSEn values to a maximum of 1.0.
# GUFB pp. 6-34, 6-35
# Inputs/output:
#  LAMBSE1 - Target lambda for bank 1
#  LAMBSE2 - Target lambda for bank 2
#
  Clip_LAMBSE:
434b: a1,00,80,42         ldw   R42,8000         R42 = 8000;
434f: b3,74,8d,30         ldb   R30,[R74+8d]     R30 = LAMBSE1+1;                  # High byte of LAMBSE1
4353: 37,30,04            jnb   B7,R30,435a      if (B7_R30 == 1)  {
4356: c3,74,8c,42         stw   R42,[R74+8c]     LAMBSE1 = R42; }                  # Clip to 1.0 max
435a: b3,74,8f,30         ldb   R30,[R74+8f]     R30 = LAMBSE2+1;                  # High byte of LAMBSE1
435e: 37,30,04            jnb   B7,R30,4365      if (B7_R30 == 0) return;
4361: c3,74,8e,42         stw   R42,[R74+8e]     LAMBSE2 = R42; }                  # Clip to 1.0 max
#
# Jump here from 433f, 4365
4365: f0                  ret                    return;

########
# HEGO Bias, Amplitude, Delay
# Closed Loop Fuel Strategy
# GUFB pp. 6-21 - 
# Inputs:
#  R14 = 0 if EGO 0, 1 if EGO 1
#  R16 = 0 if EGO 0, 2 if EGO 1
#  EGOFL - copy of EGOFLn
#  SWTFL - copy of SWTFLn (1 = cross detected)
#
  Sub11:
4366: 45,92,00,fc,32      ad3w  R32,Rfc,92       R32 = FN039;                      # EGO table RPM column scaling
436b: a0,ae,34            ldw   R34,Rae          R34 = N;
436e: ef,9b,f2            call  360c             UUWordLu();
4371: a0,38,a6            ldw   Ra6,R38          NRMCES = R38;                     # cache column
4374: 45,fa,00,f0,32      ad3w  R32,Rf0,fa       R32 = FN021;                      # load row scaling
4379: a3,74,de,34         ldw   R34,[R74+de]     R34 = LOAD;                       # engine load (VE)
437d: ef,8c,f2            call  360c             UUWordLu();
4380: a0,38,a8            ldw   Ra8,R38          NRMRLD = R38;                     # cache row
4383: a0,a6,30            ldw   R30,Ra6          R30 = NRMCES;
4386: a0,a8,32            ldw   R32,Ra8          R32 = NRMRLD;
4389: ad,04,34            ldzbw R34,4            R34 = (uns)4;                     # 4 columns
438c: 45,4a,03,fc,38      ad3w  R38,Rfc,34a      R38 = FN1353;                     # HEGO BIAS(N,LOAD)
4391: ef,53,f3            call  36e7             STabLookup();
4394: c7,72,14,3b         stb   R3b,[R72+14]     BIAS = R3b;                       # computed HEGO bias
4398: bc,3b,1e            ldsbw R1e,R3b          R1e = (int)R3b;
439b: 01,18               clrw  R18              R18 = 0;
439d: 37,1f,04            jnb   B7,R1f,43a4      if (BIAS < 0)  {
43a0: 17,18               incb  R18              R18++;
43a2: 03,1e               negw  R1e              R1e = -R1e; }                     # R1E (word) = |BIAS|
#
43a4: a0,a8,32            ldw   R32,Ra8          R32 = NRMRLD;
43a7: a0,a6,30            ldw   R30,Ra6          R30 = NRMCES;
43aa: ad,04,34            ldzbw R34,4            R34 = (uns)4;                     # 4 columns
43ad: 45,2a,03,fc,38      ad3w  R38,Rfc,32a      R38 = FN1352;                     # Closed Loop Peak-to-Peak amplitude, lambdas.
43b2: ef,35,f3            call  36ea             UTabLookUp();
43b5: ac,3b,1a            ldzbw R1a,R3b          R1a = (uns)R3b;                   # R1A (word) <- PTPAMP
43b8: a0,a8,32            ldw   R32,Ra8          R32 = NRMRLD;
43bb: a0,a6,30            ldw   R30,Ra6          R30 = NRMCES;
43be: ad,04,34            ldzbw R34,4            R34 = (uns)4;                     # 4 columns
43c1: 45,0a,03,fc,38      ad3w  R38,Rfc,30a      R38 = FN1351;                     # time delay in revs from when fuel change made until the EGO sensor sees it
43c6: ef,21,f3            call  36ea             UTabLookUp();
43c9: b0,3b,1d            ldb   R1d,R3b          R1d = R3b;
43cc: b0,1a,3b            ldb   R3b,R1a          R3b = R1a;
43cf: a0,1e,38            ldw   R38,R1e          R38 = R1e;                     
43d2: 09,07,38            shlw  R38,7            R38 *= 80;
43d5: 9c,3b,38            divb  R38,R3b          R38 /= R3b;                       # R38 <- |BIAS| / PTPAMP
43d8: dd,05               jv    43df             if (OVF == 1) goto 43df;
43da: 99,e6,38            cmpb  R38,e6           
43dd: d1,03               jleu  43e2             if ((uns) R38 > e6 )  {
#
43df: b1,e6,38            ldb   R38,e6           R38 = e6; }                       # clip to 0.45 (GUFB p. 6-28)
#
43e2: b0,38,1c            ldb   R1c,R38          R1c = R38;
43e5: 30,ee,02            jnb   B0,Ree,43ea      if (SWTFL == 0) goto 43ea;
43e8: 20,71               sjmp  445b             goto 445b;
#
# No EGO switches detected yet
# R14 (word) = 0 for EGO 1, 1 for EGO 2
# R16 (word) = 0 for EGO 1, 2 for EGO 2
# r18 (byte) = 0 if BIAS positive, 1 if negative
# r19 (byte) = 0
# R1A (word) = FN1352(N,LOAD) (PTPAMP)
# r1c (byte) = |BIAS/PTPAMP|
# r1d (byte) = FN1351(N,LOAD) (delay in revs * 4)
# R1E (word) = |BIAS|
#
43ea: a0,1e,3c            ldw   R3c,R1e          R3c = R1e;                        
43ed: a0,1a,30            ldw   R30,R1a          R30 = R1a;
43f0: 09,02,30            shlw  R30,2            R30 *= 4;
43f3: 68,30,3c            sb2w  R3c,R30          R3c -= R30;                       # R3C = |BIAS| - PTPAMP * 4
43f6: db,61               jgeu  4459             if (R3c < 0)  {
43f8: 03,3c               negw  R3c              R3c = -R3c;                       # Change sign of difference (make positive)
43fa: 45,6e,01,f0,32      ad3w  R32,Rf0,16e      R32 = FN339;                      # Closed Loop ramp rate vs |BIAS/PTPAMP|
43ff: b0,1c,34            ldb   R34,R1c          R34 = R1c;
4402: ef,b2,f1            call  35b7             UUbyteLu();                       # r38 (byte) <- ramp rate
4405: 38,18,05            jb    B0,R18,440d      if (B0_R18 == 1) goto 440d;       # Jump if bias was negative
#
# BIAS >= 0
#
4408: 39,ee,07            jb    B1,Ree,4412      if (EGOFL == 0)  {
440b: 20,03               sjmp  4410             goto 4410;                        # Is lean, need to ramp rich
#
# Jump here from:
#  4405 (BIAS < 0)
#
440d: 31,ee,02            jnb   B1,Ree,4412      if (EGOFL == 1)  {
#
# Jump here from:
#  4408 (BIAS >= 0 && EGOFL == 1)
#
4410: 13,38               negb  R38              R38 = -R38; } }                   # Invert ramp rate if going lean->rich or rich->lean
#
# Jump here from:
#  440d (BIAS < 0 && EGOFL == 0)
#
4412: 6c,38,3c            ml2w  R3c,R38          R3f:R3c = R3d:R3c * R39:R38;      #
4415: ac,1d,38            ldzbw R38,R1d          R38 = (uns)R1d;
4418: 6d,c0,03,38         ml2w  R38,3c0          R3b:R38 = R39:R38 * MNPIP;
441c: 8c,ae,38            divw  R38,Rae          R39:R38 = R3b:R38 / N;
441f: d5,03               jnv   4424             if (OVF == 1)  {
4421: bd,ff,38            ldsbw R38,ff           R38 = 0xffff; }
#
4424: 8c,38,3c            divw  R3c,R38          R3d:R3c = R3f:R3c / R39:R38;
4427: d5,03               jnv   442c             if (OVF == 1)  {
4429: bd,ff,3c            ldsbw R3c,ff           R3c = 0xffff; }                   # Clip to 0xffff on overflow
#
442c: 4b,17,74,02,06,34   sb3w  R34,R6,[R16+274] R34 = IO_Timer - [R16+TSLAMU1];   # R34 <- time since last lambda update this bank, IO ticks
4432: 6d,44,28,34         ml2w  R34,2844         R37:R34 = R35:R34 * 0x2844;
4436: 6c,36,3c            ml2w  R3c,R36          R3f:R3c = R3d:R3c * R37:R36;
4439: a3,17,0a,02,34      ldw   R34,[R16+20a]    R34 = [R16+LAMBSE1];              # LAMBSEn
443e: 39,ee,09            jb    B1,Ree,444a      if (EGOFL == 1) goto 444a;
4441: 68,3e,34            sb2w  R34,R3e          R34 -= R3e;
4444: db,0c               jgeu  4452             if (R34 > 0)  {
4446: 01,34               clrw  R34              R34 = 0;
4448: 20,08               sjmp  4452             goto 4452;
#
444a: 64,3e,34            ad2w  R34,R3e          R34 += R3e;
444d: d3,03               jnc   4452             if ((uns) R34 >= 0)  {
444f: bd,ff,34            ldsbw R34,ff           R34 = 0xffff; } }                 # clamp overflow
#
4452: 28,aa               scall 44fe             Clamp_Lambda();                   # clamp R34 Lambda to calibration limits
4454: c3,17,0a,02,34      stw   R34,[R16+20a]    [R16+LAMBSE1] = R34; }            # update LAMBSEn
#
# Jump here from:
#  43f5 (|BIAS| - PTPAMP * 4 was >= 0)
#
4459: 20,9d               sjmp  44f8             goto 44f8;
#
# r18 (byte) = 0 if BIAS positive, 1 if negative
# r19 (byte) = 0
# R1A (word) = FN1352(N,LOAD) (PTPAMP)
# r1c (byte) = |BIAS/PTPAMP|
#
445b: a0,1a,3c            ldw   R3c,R1a          R3c = R1a;                        # PTPAMP
445e: 09,02,3c            shlw  R3c,2            R3c *= 4;
4461: 45,78,01,f0,32      ad3w  R32,Rf0,178      R32 = FN342;                      # jump-to bias function 
4466: b0,1c,34            ldb   R34,R1c          R34 = R1c;                        # |BIAS/PTPAMP|
4469: 30,18,05            jnb   B0,R18,4471      if (B0_R18 == 0) goto 4471;       # jmp if bias is non-negative
446c: 39,ee,0f            jb    B1,Ree,447e      if (EGOFL == 0)  {
446f: 20,03               sjmp  4474             goto 4474;                        # bias is neg and just went lean
#
4471: 31,ee,0a            jnb   B1,Ree,447e      if (EGOFL == 1)  {                # bias non-negative ; jump if went lean
# come here if bias negative and went lean
4474: 64,1e,3c            ad2w  R3c,R1e          R3c += R1e;                       # PTPAMP * 4 + |BIAS|
4477: 45,86,01,f0,32      ad3w  R32,Rf0,186      R32 = FN344;                      # jump-back function
447c: 17,19               incb  R19              R19++; } }
#
447e: ef,36,f1            call  35b7             UUbyteLu();                       # Calculate jump
4481: 6c,3c,38            ml2w  R38,R3c          R3b:R38 = R39:R38 * R3d:R3c;      # Jump from FN342/FN344 * (PTPAMP * 4 + |BIAS|)
4484: 0c,04,38            shrdw R38,4            R3b:R38 /= 10;
#
# R14 = 0 for EGO 1, 1 for EGO 2
# R16 = 0 for EGO 1, 2 for EGO 2
#
4487: b3,15,68,02,3c      ldb   R3c,[R14+268]    R3c = [R14+ENPIP1];
448c: 9b,15,9c,00,3c      cmpb  R3c,[R14+9c]     
4491: db,05               jgeu  4498             if ([R14+ENPIP1] < [R14+ANPIP1])  {
4493: c7,15,9c,00,3c      stb   R3c,[R14+9c]     [R14+ANPIP1] = [R14+ENPIP1]; }    # force PIPRAT to 1
#
4498: af,15,9c,00,3c      ldzbw R3c,[R14+9c]     R3c = (uns)[R14+ANPIP1];
449d: 6c,38,3c            ml2w  R3c,R38          R3f:R3c = R3d:R3c * R39:R38;
44a0: af,15,68,02,38      ldzbw R38,[R14+268]    R38 = (uns)[R14+ENPIP1];
44a5: 8c,38,3c            divw  R3c,R38          R3d:R3c = R3f:R3c / R39:R38;      # R3C <- PIPRAT * FN342/FN344 * (PTPAMP * 4 + |BIAS|)
44a8: a3,17,0a,02,34      ldw   R34,[R16+20a]    R34 = [R16+LAMBSE1];              # (Previous) LAMBSEn
44ad: 39,ee,09            jb    B1,Ree,44b9      if (EGOFL == 1) goto 44b9;
44b0: 68,3c,34            sb2w  R34,R3c          R34 -= R3c;                       # Went lean so subtract from last LAMBSE
44b3: db,0c               jgeu  44c1             if (R34 < 0)  {
44b5: 01,34               clrw  R34              R34 = 0;                          # clip underflow
44b7: 20,08               sjmp  44c1             goto 44c1;
#
44b9: 64,3c,34            ad2w  R34,R3c          R34 += R3c;                       # Went rich so add to last LAMBSE
44bc: d3,03               jnc   44c1             if ((uns) R34 >= 0)  {
44be: bd,ff,34            ldsbw R34,ff           R34 = 0xffff; } }                 # clip overflow
#
44c1: 28,3b               scall 44fe             Clamp_Lambda();                   # clamp Lambda to calibration limits
44c3: c3,17,0a,02,34      stw   R34,[R16+20a]    [R16+LAMBSE1] = R34;              # update LAMBSEn
44c8: c7,15,9c,00,00      stb   R0,[R14+9c]      [R14+ANPIP1] = 0;                 # reset ANPIPn
#
# r19 (byte) = ???
# r1d (byte) = FN1351(N,LOAD) (delay in revs * 4)
#
44cd: ac,1d,3c            ldzbw R3c,R1d          R3c = (uns)R1d;                   
44d0: 09,01,3c            shlw  R3c,1            R3c *= 2;                         # R3C <- FN1351 * 2 (revs * 8)
44d3: b1,10,38            ldb   R38,10           R38 = 10;                         
44d6: 38,19,0b            jb    B0,R19,44e4      if (B0_R19 == 0)  {               
44d9: 45,90,01,f0,32      ad3w  R32,Rf0,190      R32 = FN346;                      # Use FN346 to scale TDPIP
44de: b0,1c,34            ldb   R34,R1c          R34 = R1c;
44e1: ef,d3,f0            call  35b7             UUbyteLu(); }
#
44e4: 7f,fe,07,38         ml2b  R38,[Rfe+7]      R38 *= ENGCYL;                    # R38 = ENGCYL * 0x10 (or FN346)
44e8: 6c,38,3c            ml2w  R3c,R38          R3f:R3c = R3d:R3c * R39:R38;      # R3C (doubleword) = FN1351 * 2 * ENGCYL * (0x10 or FN346)
                                                                                   #  = (revs * 8) * (pip/rev * 2) * (0x10 or FN346)
44eb: 88,00,3e            cmpw  R3e,R0                                             
44ee: df,03               je    44f3             if (R3e != 0)  {
44f0: b1,ff,3d            ldb   R3d,ff           R3d = ff; }                       # Clip result to 255 if too big
#
44f3: c7,15,68,02,3d      stb   R3d,[R14+268]    [R14+ENPIP1] = R3d;               # ENPIPn = R3C (word) / 0x100
44f8: c3,17,74,02,06      stw   R6,[R16+274]     [R16+TSLAMU1] = IO_Timer;         # Save current time as last LAMBSEn update 
44fd: f0                  ret                    return;

#######
# Enforce lambda clip limits in closed loop
# GUFB p. 6-6
# Input/Output:
#  R34 (word) - target lambda
#
  Clamp_Lambda:
44fe: 8b,fc,24,34         cmpw  R34,[Rfc+24]                                       # LAMMAX, lean limit
4502: d1,04               jleu  4508             if ((uns) R34 > LAMMAX )  {
4504: a3,fc,24,34         ldw   R34,[Rfc+24]     R34 = LAMMAX; }
#
4508: 8b,fc,26,34         cmpw  R34,[Rfc+26]                                       # LAMMIN, rich limit
450c: db,04               jgeu  4512             if ((uns) R34 >= LAMMIN) return;
450e: a3,fc,26,34         ldw   R34,[Rfc+26]     R34 = LAMMIN; }
#
4512: f0                  ret                    return;

######

#
# Called from Lambda Reset Logic @ 431e, 4324
# Inputs:
#  R16 (word) - Bank # x 2 (0 or 2)
#  R34 (word) - LAMMIN
#  LAMBSEn
#  LMBJMP
# Outputs:
#  R34 (word) - unchanged
#  LAMBSEn
#
  Sub12:
4513: a3,17,0a,02,36      ldw   R36,[R16+20a]    R36 = [R16+LAMBSE1];              # LAMBSEn( )[divide by 32768]
4518: 6b,fc,74,36         sb2w  R36,[Rfc+74]     R36 -= LMBJMP;
451c: d3,05               jltu  4523             if ((uns) R36 < 0) goto 4523;
451e: 88,34,36            cmpw  R36,R34          
4521: db,03               jgeu  4526             if (R36 > R34)  {
#
4523: c0,36,34            stw   R34,R36          R36 = R34; }                      # Clip result to LAMMIN
#
4526: c3,17,0a,02,36      stw   R36,[R16+20a]    [R16+LAMBSE1] = R36;              # LAMBSEn( )[divide by 32768]
452b: f0                  ret                    return;

######


########################################################################
# OPEN LOOP FUEL CONTROL
# GUFB, top of p. 6-17
# Part of Calc_BG_Fuel background task
########################################################################

  Calc_OL_Fuel:
452c: 45,d2,00,f0,32      ad3w  R32,Rf0,d2       R32 = FN022B;                     # Temp -> column fn for fuel table lookup
4531: b3,fc,35,36         ldb   R36,[Rfc+35]     R36 = FRCBFT;
4535: 29,b1               scall 46e8             Sub14();
4537: 0a,07,34            asrw  R34,7            R34 /= 80;
453a: ef,6f,f0            call  35ac             subyteLU();
453d: b0,38,30            ldb   R30,R38          R30 = R38;                        # R30 <- column index
4540: 45,16,01,f0,32      ad3w  R32,Rf0,116      R32 = FN072A;
4545: a3,74,e2,34         ldw   R34,[R74+e2]     R34 = PERLOAD;                    # 260 Relative Volumetric Efficiency
4549: ef,c0,f0            call  360c             UUWordLu();
454c: b0,38,32            ldb   R32,R38          R32 = R38;                        # R32 <- row index
454f: ad,0a,34            ldzbw R34,a            R34 = (uns)a;                     # R34 <- 10 columns R35 <- 0
4552: 45,72,01,fc,38      ad3w  R38,Rfc,172      R38 = FN1307;                     # Base Fuel Table (A/F ratio)
4557: ef,81,f1            call  36db             UTabLu16();                       # R3B <- FN1307(ECT,PERLOAD)
455a: 45,ca,00,fc,32      ad3w  R32,Rfc,ca       R32 = FN300;                      # Open Loop Fuel Multiplier vs ACT
455f: b0,b1,34            ldb   R34,Rb1          R34 = ACT;
4562: ef,47,f0            call  35ac             subyteLU();                       # R38 <- FN300(ACT)
4565: 5c,3b,38,3c         ml3b  R3c,R38,R3b      R3c = R38 * R3b;                  # R3C (word) = FN300(ACT) + FN1307(ECT,PERLOAD)
4569: 45,d2,00,f0,32      ad3w  R32,Rf0,d2       R32 = FN022B;
456e: b3,fc,36,36         ldb   R36,[Rfc+36]     R36 = FRCSFT;
4572: 29,74               scall 46e8             Sub14();
4574: 0a,07,34            asrw  R34,7            R34 /= 80;
4577: ef,32,f0            call  35ac             subyteLU();
457a: b0,38,30            ldb   R30,R38          R30 = R38;                        # R30 <- column index
457d: 45,90,00,f0,32      ad3w  R32,Rf0,90       R32 = FN018;
4582: b0,c8,34            ldb   R34,Rc8          R34 = ATMR1;
4585: ef,2f,f0            call  35b7             UUbyteLu(); 
4588: b0,38,32            ldb   R32,R38          R32 = R38;                        # R32 <- row index
458b: ad,0a,34            ldzbw R34,a            R34 = (uns)a;                     # R34 <- 10 columns R35 <- 0
458e: 45,c2,01,fc,38      ad3w  R38,Rfc,1c2      R38 = FN1306;                     # Startup Fuel Subtractor (A/F ratio)(ECT vs Time)
4593: ef,45,f1            call  36db             UTabLu16();                       # R3B <- FN1306(ECT,ATMR1)
4596: 69,80,00,3a         sb2w  R3a,80           R3a -= 80;                        # offset from unsigned to signed
459a: 08,02,3a            shrw  R3a,2            R3a /= 4;                         # and divide by 4
459d: 68,3a,3c            sb2w  R3c,R3a          R3c -= R3a;                       # and subtract from R3C
45a0: db,02               jgeu  45a4             if (R3c < 0)  {                   
45a2: 01,3c               clrw  R3c              R3c = 0; }                        # clip to 0 if negative
#
# Calculate "C"
# GUFB p. 6-19
# R3C = (FN300(ACT) * FN1307(ECT,PERLOAD) - FN1306(ECT,ATMR1))
#
45a4: ad,80,38            ldzbw R38,80           R38 = (uns)80;                    # lambda = 1
45a7: 31,e9,3f            jnb   B1,Re9,45e9      if (LDFLG == 1)  {
# Lug mode
45aa: b3,74,83,42         ldb   R42,[R74+83]     R42 = Mult_bp212A;
45ae: 45,82,00,fa,32      ad3w  R32,Rfa,82       R32 = FN308;                      # Sea Level Lugging O/L Fuel Multiplier vs RPM
45b3: a0,ae,34            ldw   R34,Rae          R34 = N;
45b6: ef,53,f0            call  360c             UUWordLu();
45b9: 7c,38,42            ml2b  R42,R38          R42 *= R38;                       # R42 <- FN212(BP) * FN308(N)
45bc: 45,c8,00,f8,32      ad3w  R32,Rf8,c8       R32 = FN129A;                     # LOMALT 
45c1: b3,74,80,34         ldb   R34,[R74+80]     R34 = BP;                         # barometric pressure
45c5: ef,ef,ef            call  35b7             UUbyteLu();
45c8: b0,38,30            ldb   R30,R38          R30 = R38;                        # R30 <- FN129A(BP)
45cb: 45,9e,00,fa,32      ad3w  R32,Rfa,9e       R32 = FN309;                      # Altitude Lugging O/L Fuel Multiplier vs RPM
45d0: a0,ae,34            ldw   R34,Rae          R34 = N;
45d3: ef,36,f0            call  360c             UUWordLu();
45d6: 7c,30,38            ml2b  R38,R30          R38 *= R30;                       # R38 = FN309(N) * FN129A(BP)
45d9: 64,42,38            ad2w  R38,R42          R38 += R42;                       #      + FN212(BP) * FN308(N)
45dc: db,06               jc    45e4             if ((uns) R38 >= 0) goto 45e4;
45de: 08,07,38            shrw  R38,7            R38 /= 80;    
45e1: 30,39,03            jnb   B0,R39,45e7      if (B0_R39 == 1)  {
#
45e4: ad,ff,38            ldzbw R38,ff           R38 = (uns)ff; }                  # Overflow, clip to 1.99
#
45e7: 20,a7               sjmp  4690             goto 4690; }                      # and continue
#
45e9: 36,26,0d            jnb   B6,R26,45f9      if (DNDSUP == 1)  {               # in drive
45ec: 37,d0,0a            jnb   B7,Rd0,45f9      if (APT < 0)  {                   # closed throttle
45ef: 3a,ef,07            jb    B2,Ref,45f9      if (WRMEGO == 0)  {               # and EGO is cold
45f2: 45,d6,00,fc,32      ad3w  R32,Rfc,d6       R32 = FN301;                      # table - fuel closed throttle open loop multiply vs RPM
45f7: 20,91               sjmp  468a             goto 468a; } } }

45f9: 32,26,2c            jnb   B2,R26,4628      if (NFLG == 1)  {                 # Idling in neutral
45fc: 9b,fe,05,ad         cmpb  Rad,[Rfe+5]      
4600: da,26               jle   4628             if ((uns) TCSTRT < CTLOW)  {
4602: 9b,f4,0a,ad         cmpb  Rad,[Rf4+a]      
4606: d6,20               jge   4628             if (TCSTRT < CTHIN)  {
4608: 9b,f4,0c,c8         cmpb  Rc8,[Rf4+c]                                        # In temp range to use NUMPR (OL idle fuel multiplier)
460c: db,1a               jgeu  4628             if (ATMR1 > OLMTD1)  {            # and early enough to use NUMPR 
460e: 45,ee,00,fc,32      ad3w  R32,Rfc,ee       R32 = FN301N;                     # Neutral idle fuel multiplier vs RPM
4613: a0,ae,34            ldw   R34,Rae          R34 = N;
4616: ef,f3,ef            call  360c             UUWordLu();
4619: 7f,f4,0b,38         ml2b  R38,[Rf4+b]      R38 *= NUMPR;                     # Open loop neutral idle cold engine multiplier
461d: 08,07,38            shrw  R38,7            R38 /= 80;
4620: 30,39,03            jnb   B0,R39,4626      if (B0_R39 == 1)  {
4623: ad,ff,38            ldzbw R38,ff           R38 = (uns)ff; }                  # Clip to 1.99
4626: 20,68               sjmp  4690             goto 4690; } } } }
#
4628: 30,ec,4d            jnb   B0,Rec,4678      if (MFAFLG == 1)  {               # Managed Fuel Air mode - lean cruise (will never be 1 in A9L)
462b: 9b,f4,07,00         cmpb  R0,[Rf4+7]       
462f: df,47               je    4678             if (0 != MFASW)  {                # enabled in calibration (flag = 1 in A9L, disabled through RPM thresholds)
4631: 45,de,00,f0,32      ad3w  R32,Rf0,de       R32 = FN070;                      # RPM scaling for table index
4636: a0,ae,34            ldw   R34,Rae          R34 = N;
4639: ef,d0,ef            call  360c             UUWordLu();
463c: a0,38,30            ldw   R30,R38          R30 = R38;                        # R30 <- column index
463f: 45,16,01,f0,32      ad3w  R32,Rf0,116      R32 = FN072A;                     # PERLOAD scaling for table index
4644: a3,74,e2,34         ldw   R34,[R74+e2]     R34 = PERLOAD;                    # 260 Relative Volumetric Efficiency
4648: ef,c1,ef            call  360c             UUWordLu();
464b: 09,04,38            shlw  R38,4            R38 *= 10;
464e: a0,38,32            ldw   R32,R38          R32 = R38;                        # R32 <- row index
4651: ad,0a,34            ldzbw R34,a            R34 = (uns)a;                     # R34 <- 10 rows R35 <- 0
4654: 45,93,00,f4,38      ad3w  R38,Rf4,93       R38 = FN1328;                     # Managed Fuel Air Fuel Table, lambda multiplier vs N and PERLOAD
4659: ef,8e,f0            call  36ea             UTabLookUp();
465c: b3,74,82,38         ldb   R38,[R74+82]     R38 = Mult_bp311;
4660: 7c,3b,38            ml2b  R38,R3b          R38 *= R3b;                       # R38 = FN1328(N,PERLOAD) * FN311(PB)
4663: 5f,74,f4,39,38      ml3b  R38,R39,[R74+f4] R38 = R39 * MFAMUL;               #      * MFAMUL
4668: 09,02,38            shlw  R38,2            R38 *= 4;
466b: 55,80,39,38         ad3b  R38,R39,80       R38 = R39 + 80;                   #      + 1
466f: d3,03               jnc   4674             if ((uns) R38 >= 0)  {
4671: b1,ff,38            ldb   R38,ff           R38 = ff; }                       # Clip to 1.99
4674: 11,39               clrb  R39              R39 = 0;
4676: 20,18               sjmp  4690             goto 4690; } }
#
4678: 32,26,07            jnb   B2,R26,4682      if (NFLG == 1)  {                 # Neutral Idle
467b: 45,ee,00,fc,32      ad3w  R32,Rfc,ee       R32 = FN301N;                     # Use FN301N(N), neutral idle multiplier
4680: 20,08               sjmp  468a             goto 468a; }
#
4682: 30,24,0b            jnb   B0,R24,4690      if (Wot == 1)  {
4685: 45,02,01,fc,32      ad3w  R32,Rfc,102      R32 = FN303;                      # Use FN303(N), WOT Fuel Multiplier vs RPM
#
468a: a0,ae,34            ldw   R34,Rae          R34 = N;
468d: ef,7c,ef            call  360c             UUWordLu(); }
#
# Come here after calculating "C"
# Open Loop Fuel Logic
# GUFB p. 6-17 (top)
# R38 (word) = "C" (0 - 1.99)
# R3C (word) = result of open loop table lookups above
#
4690: 6c,38,3c            ml2w  R3c,R38          R3f:R3c = R3d:R3c * R39:R38;                       
4693: 0c,05,3c            shrdw R3c,5            R3f:R3c /= 20;
4696: 88,00,3e            cmpw  R3e,R0           
4699: df,03               je    469e             if (R3e != 0)  {                 
469b: bd,ff,3c            ldsbw R3c,ff           R3c = 0xffff; }                   # Overflow - clip result to 1.99
#
469e: 6f,72,e8,3c         ml2w  R3c,[R72+e8]     R3f:R3c = R3d:R3c * LAMMUL;       # Neutral/drive transition fuel multiplier
46a2: 98,3f,00            cmpb  R0,R3f           
46a5: df,05               je    46ac             if (0 != R3f)  {
46a7: bd,ff,3c            ldsbw R3c,ff           R3c = 0xffff;                     # Clip if overlflow
46aa: 20,03               sjmp  46af             goto 46af; }
#
46ac: 0c,08,3c            shrdw R3c,8            R3f:R3c /= 100;                   # Otherwise scale
#
46af: 6f,fa,12,3c         ml2w  R3c,[Rfa+12]     R3f:R3c = R3d:R3c * OLMCL;        # Open Loop Fuel Calibration Multiplier
46b3: 98,3f,00            cmpb  R0,R3f           
46b6: df,05               je    46bd             if (0 != R3f)  {
46b8: bd,ff,3e            ldsbw R3e,ff           R3e = 0xffff;                     # Clip if overflow
46bb: 20,03               sjmp  46c0             goto 46c0; }
#
46bd: 0d,08,3c            shldw R3c,8            R3f:R3c *= 100;                   # Otherwise scale
#
46c0: 32,e7,15            jnb   B2,Re7,46d8      if (HSPFLG == 1)  {               # High speed flag
46c3: 45,73,00,fa,32      ad3w  R32,Rfa,73       R32 = 981b;                       # Table (vehicle speed - LAMBSE)
46c8: b3,74,3f,34         ldb   R34,[R74+3f]     R34 = VSBAR_H;                    # vehicle speed filtered(1) (MPH) 2BC is 8.8 format VSS
46cc: ef,e8,ee            call  35b7             UUbyteLu();
46cf: a0,3e,3c            ldw   R3c,R3e          R3c = R3e;
46d2: 09,08,38            shlw  R38,8            R38 *= 100;
46d5: 6c,38,3c            ml2w  R3c,R38          R3f:R3c = R3d:R3c * R39:R38; }
#
46d8: 88,00,3e            cmpw  R3e,R0           
46db: d7,02               jne   46df             if (R3e == 0)  {
46dd: 07,3e               incw  R3e              R3e++; }                          # Clip if undeflow
#
46df: c3,74,8c,3e         stw   R3e,[R74+8c]     LAMBSE1 = R3e;                    # Desired air/fuel ratio for the left side bank of injectors
46e3: c3,74,8e,3e         stw   R3e,[R74+8e]     LAMBSE2 = R3e;                    # Desired air/fuel ratio for the right side bank of injectors
46e7: f0                  ret                    return;

#################################################################
# Calculate temp based on ratio of ACT and ECT
#
# Inputs:
#  RB0 - ECT
#  RB1 - ACT
#  R36 (byte) - blending ratio (0 = ECT, 0x7F = ACT)
# Outputs:
#  R34 (word) - result * 0x80
#################################################################
  Sub14:
46e8: fe,5c,b1,36,34      sml3b R34,R36,Rb1      R34 = R36 * ACT;
46ed: 13,36               negb  R36              
46ef: 75,7f,36            ad2b  R36,7f           R36 = 7E - R36;
46f2: fe,7c,b0,36         sml2b R36,Rb0          R36 *= ECT;    
46f6: bc,b0,38            ldsbw R38,Rb0          R38 = (int)ECT;
46f9: 64,38,36            ad2w  R36,R38          R36 += R38;    
46fc: 64,36,34            ad2w  R34,R36          R34 += R36;
46ff: f0                  ret                    return;

#################################################################
# Adaptive something
# Tasklist Routine at 2151, routine offset 2A
#################################################################


  Adapt?:
4700: 3f,a1,14            jb    B7,Ra1,4717      if (CRKFLG == 0)  {
4703: 3a,a1,11            jb    B2,Ra1,4717      if (UNDSP == 0)  {                 # Run/Underspeed Flag. (1 = Underspeed or CRANK, 0 = Run)
4706: 9b,fc,64,b0         cmpb  Rb0,[Rfc+64]                                       # ? ROM 9AE2=55
470a: de,0b               jlt   4717             if (ECT >= MinECT_adp)  {         # jump if ECT < 170 degrees Farenheit
470c: 9b,fc,65,b0         cmpb  Rb0,[Rfc+65]                                       #  ROM 9AE3=71
4710: d2,05               jgt   4717             if (ECT <= MaxECT_adp)  {         # jump if ECT > 226 degrees Farenheit
4712: 91,01,a1            orb   Ra1,1            ADPTMR_On = 1;                    # set Adaptive Fuel Time Flag
4715: 20,07               sjmp  471e             goto 471e; } } } }

############## not at operating temp(too hot or cold)
4717: c3,72,ba,00         stw   R0,[R72+ba]      ADPTMR = 0;
471b: 71,fe,a1            an2b  Ra1,fe           ADPTMR_On = 0;                    # Adaptive Fuel Time Flag
471e: 51,f8,c5,38         an3b  R38,Rc5,f8       R38 = Fmem_flags & f8;
4722: df,02               je    4726             if (R38 == 0) goto 4726;
4724: 20,e9               sjmp  480f             goto 480f;

4726: 3a,ee,0a            jb    B2,Ree,4733      if (OLFLG == 1) goto 4733;
4729: a3,72,ba,38         ldw   R38,[R72+ba]     R38 = ADPTMR;
472d: 8b,fc,68,38         cmpw  R38,[Rfc+68]     
4731: db,02               jgeu  4735             if ((uns) R38 >= ADAPTIM) goto 4735;
4733: 20,da               sjmp  480f             goto 480f;

4735: 33,ec,25            jnb   B3,Rec,475d      if (REFFLG == 0) goto 475d;
4738: b3,72,d7,30         ldb   R30,[R72+d7]     R30 = ISCFLG;
473c: 99,01,30            cmpb  R30,1            
473f: d7,f2               jne   4733             if (R30 != 1) goto 4733;
4741: b3,72,eb,30         ldb   R30,[R72+eb]     R30 = ISFLAG;
4745: c7,74,12,30         stb   R30,[R74+12]     COLTBU = R30;                     # the column no of the Adaptive Learning Cell to be updated
4749: 11,a6               clrb  Ra6              NRMCES = 0;
474b: c4,a7,30            stb   R30,Ra7          Ra7 = R30;
474e: a1,08,00,30         ldw   R30,8            R30 = 8;
4752: c7,74,13,30         stb   R30,[R74+13]     Rowtbu = R30;
4756: c4,a9,30            stb   R30,Ra9          Ra9 = R30;
4759: 11,a8               clrb  Ra8              NRMRLD = 0;
475b: 20,4f               sjmp  47ac             goto 47ac;

475d: a3,72,d2,38         ldw   R38,[R72+d2]     R38 = RANNUM;
4761: 6d,03,01,38         ml2w  R38,103          R3b:R38 = RANNUM * Ranmul;
4765: c3,72,d2,38         stw   R38,[R72+d2]     RANNUM = R38;
4769: 45,b2,00,f0,32      ad3w  R32,Rf0,b2       R32 = FN021;                      # Load Scaling - emission load scaling
476e: a3,74,de,34         ldw   R34,[R74+de]     R34 = LOAD;                       # engine load (VE)
4772: ef,97,ee            call  360c             UUWordLu();
4775: a0,38,a8            ldw   Ra8,R38          NRMRLD = R38;
4778: 65,80,00,38         ad2w  R38,80           R38 += 80;
477c: bf,72,d2,3a         ldsbw R3a,[R72+d2]     R3a = (int)RANNUM;
4780: 64,3a,38            ad2w  R38,R3a          R38 += R3a;
4783: c7,74,13,39         stb   R39,[R74+13]     Rowtbu = R39;
4787: c4,30,39            stb   R39,R30          R30 = R39;
478a: 45,de,00,f0,32      ad3w  R32,Rf0,de       R32 = FN070;                      # Table  spark RPM scaling
478f: a0,ae,34            ldw   R34,Rae          R34 = N;
4792: ef,77,ee            call  360c             UUWordLu();
4795: a0,38,a6            ldw   Ra6,R38          NRMCES = R38;
4798: 65,80,00,38         ad2w  R38,80           R38 += 80;
479c: bf,72,d3,3a         ldsbw R3a,[R72+d3]     R3a = (int)[153];
47a0: 64,3a,38            ad2w  R38,R3a          R38 += R3a;
47a3: c7,74,12,39         stb   R39,[R74+12]     COLTBU = R39;                     # Adaptive Learning Cell to be updated
47a7: 99,08,30            cmpb  R30,8            
47aa: db,63               jgeu  480f             if ((uns) R30 >= 8) goto 480f;
47ac: 7d,0a,30            ml2b  R30,a            R30 *= a;
47af: 77,74,12,30         ad2b  R30,[R74+12]     R30 += COLTBU;                    # Adaptive Learning Cell to be updated
47b3: 45,82,03,fc,38      ad3w  R38,Rfc,382      R38 = FN1325;
47b8: 64,30,38            ad2w  R38,R30          R38 += R30;
47bb: b2,38,38            ldb   R38,[R38]        R38 = [R38];
47be: 98,38,00            cmpb  R0,R38           
47c1: d2,1e               jgt   47e1             if (0 > R38) goto 47e1;
47c3: 4b,74,0e,a8,38      sb3w  R38,Ra8,[R74+e]  R38 = NRMRLD - LSTROW;
47c8: db,02               jc    47cc             if (R38 > 0)  {
47ca: 03,38               negw  R38              R38 = -R38; }
47cc: 8b,fc,6c,38         cmpw  R38,[Rfc+6c]     
47d0: d9,0f               jgtu  47e1             if ((uns) R38 > DELROW ) goto 47e1;
47d2: 4b,74,10,a6,38      sb3w  R38,Ra6,[R74+10] R38 = NRMCES - LSTCOL;
47d7: db,02               jc    47db             if (R38 > 0)  {
47d9: 03,38               negw  R38              R38 = -R38; }
47db: 8b,fc,6e,38         cmpw  R38,[Rfc+6e]     
47df: d1,0a               jleu  47eb             if ((uns) R38 > DELCOL )  {
47e1: c3,74,0e,a8         stw   Ra8,[R74+e]      LSTROW = NRMRLD;
47e5: c3,74,10,a6         stw   Ra6,[R74+10]     LSTCOL = NRMCES;
47e9: 20,24               sjmp  480f             goto 480f; }

47eb: a3,72,0c,38         ldw   R38,[R72+c]      R38 = AEFUEL;
47ef: 8b,fc,72,38         cmpw  R38,[Rfc+72]     
47f3: d9,1a               jgtu  480f             if ((uns) R38 > AELIM ) goto 480f;
47f5: a0,9e,38            ldw   R38,R9e          R38 = EFTR;
47f8: 37,39,02            jnb   B7,R39,47fd      if (B7_R39 == 1)  {
47fb: 03,38               negw  R38              R38 = -R38; }
47fd: 8b,fc,76,38         cmpw  R38,[Rfc+76]     
4801: db,0c               jgeu  480f             if ((uns) R38 >= ADEFTR) goto 480f;
4803: 9b,fc,66,b1         cmpb  Rb1,[Rfc+66]                                       # min act for adaptive control
4807: da,06               jle   480f             if (ACT <= Minact_adp) goto 480f;
4809: 9b,fc,67,b1         cmpb  Rb1,[Rfc+67]                                       # max act for adaptive control
480d: de,11               jlt   4820             if (ACT >= Maxact_adp)  {
480f: c3,01,b8,07,00      stw   R0,[R0+7b8]      LPCT1L = LPCT2L = 0;
4814: c3,01,ba,07,00      stw   R0,[R0+7ba]      LPCT1R = LPCT2R = 0;
4819: c3,01,b2,07,00      stw   R0,[R0+7b2]      EGOCT1 = 0;
481e: 20,76               sjmp  4896             return; }

4820: 33,27,0c            jnb   B3,R27,482f      if (SWTFL1 == 1)  {
4823: b3,01,b2,07,36      ldb   R36,[R0+7b2]     R36 = EGOCT1;
4828: 17,36               incb  R36              R36++;
482a: c7,01,b2,07,36      stb   R36,[R0+7b2]     EGOCT1 = R36; }
482f: 30,27,0c            jnb   B0,R27,483e      if (SWTFL2 == 1)  {
4832: b3,01,b3,07,36      ldb   R36,[R0+7b3]     R36 = EGOCT2;
4837: 17,36               incb  R36              R36++;
4839: c7,01,b3,07,36      stb   R36,[R0+7b3]     EGOCT2 = R36; }
483e: bf,72,14,38         ldsbw R38,[R72+14]     R38 = (int)BIAS;                  # computed HEGO bias
4842: fe,6d,10,00,38      sml2w R38,10           R3b:R38 = BIAS * 0x10;
4847: 65,00,80,38         ad2w  R38,8000         R38 += 0x8000;
484b: a3,fc,6a,3a         ldw   R3a,[Rfc+6a]     R3a = DELAMB;
484f: b3,01,e0,07,14      ldb   R14,[R0+7e0]     R14 = KWUCTR;
4854: 9b,fc,7a,14         cmpb  R14,[Rfc+7a]     
4858: db,06               jgeu  4860             if (R14 > KWUCNT)  {
485a: b3,fc,79,14         ldb   R14,[Rfc+79]     R14 = FAEGCT;
485e: 20,04               sjmp  4864             goto 4864; }
#
4860: b3,fc,78,14         ldb   R14,[Rfc+78]     R14 = ADEGCT;
4864: 9b,01,b2,07,14      cmpb  R14,[R0+7b2]     
4869: db,0f               jgeu  487a             if (R14 > EGOCT1)  {
#
# Update adaptive table for EGO 1
486b: 01,32               clrw  R32              R32 = 0;
486d: 01,3e               clrw  R3e              R3e = 0;
486f: a1,04,07,40         ldw   R40,704          R40 = LTMTB100;
4873: 51,80,ea,36         an3b  R36,Rea,80       R36 = Flags_ea & 80;
4877: ef,1d,00            call  4897             Sub15(); }
#
487a: 9b,01,b3,07,14      cmpb  R14,[R0+7b3]     
487f: db,15               jgeu  4896             if ((uns) R14 >= EGOCT2) return;
#
# Update adaptive table for EGO 2
4881: ad,02,32            ldzbw R32,2            R32 = (uns)2;
4884: ad,01,3e            ldzbw R3e,1            R3e = (uns)1;
4887: a1,5a,07,40         ldw   R40,75a          R40 = LTMTB200;
488b: 51,40,ea,36         an3b  R36,Rea,40       R36 = Flags_ea & 40;
488f: a3,fc,6a,3a         ldw   R3a,[Rfc+6a]     R3a = DELAMB;
4893: ef,01,00            call  4897             Sub15();
#
4896: f0                  ret                    return;


################################################################
# Adaptive learning
# GUFB pp. 6-50, 6-51
#
# Inputs:
#  R30 (word) = offset of KAM cell to be adjusted
#  R32 (word) = 0 for EGO #1, 2 for EGO #2
#  R36 (byte) = 0 if corresponding EGO lean, non-0 if rich
#  R38 (word) = computed EGO bias
#  R3A (word) = DELAMB (LAMBSE deadband)
#  R3E (word) = 0 for EGO #1, 1 for EGO #2
#  R40 (word) = base address of long-term KAM table for corresponding EGO
# Outputs:
# 
################################################################

  Sub15:
4897: 64,30,40            ad2w  R40,R30          R40 += R30;
489a: 98,00,36            cmpb  R36,R0           
489d: df,49               je    48e8             if (R36 == 0) goto 48e8;          # Jump if lean correction
#
# Rich correction
489f: 64,38,3a            ad2w  R3a,R38          R3a += R38;
48a2: a3,33,0a,02,42      ldw   R42,[R32+20a]    R42 = [R32+LAMBSE1];              # LAMBSEn [divide by 32768]
48a7: 88,3a,42            cmpw  R42,R3a          
48aa: d3,3b               jltu  48e7             if ((uns) R42 < R3a) return;
48ac: b3,3f,ba,07,3c      ldb   R3c,[R3e+7ba]    R3c = [R3e+LPCT1R] ;              # increment LPCTnR
48b1: 17,3c               incb  R3c              R3c++;
48b3: c7,3f,ba,07,3c      stb   R3c,[R3e+7ba]    [R3e+LPCT1R] = R3c;               # 
48b8: 45,82,03,fc,34      ad3w  R34,Rfc,382      R34 = FN1325;                     # Adaptive learning control table
48bd: 64,30,34            ad2w  R34,R30          R34 += R30;
48c0: b2,34,3d            ldb   R3d,[R34]        R3d = [R34];
48c3: 19,01,3d            shlb  R3d,1            R3d *= 2;
48c6: 98,3d,3c            cmpb  R3c,R3d          
48c9: d1,1c               jleu  48e7             if ((uns) R3c <= R3d) return;
48cb: b2,40,36            ldb   R36,[R40]        R36 = [R40];
48ce: 9b,fc,70,36         cmpb  R36,[Rfc+70]                                       # ROM adaptive control min
48d2: d1,13               jleu  48e7             if ((uns) R36 <= MINADP) return;
48d4: 15,36               decb  R36              R36--;
48d6: c6,40,36            stb   R36,[R40]        [R40] = R36;
48d9: c7,3f,ba,07,00      stb   R0,[R3e+7ba]     [R3e+LPCT1R] = 0;                 # KAM Table store
48de: a3,01,02,07,36      ldw   R36,[R0+702]     R36 = CHKSUM;                     # KAM checksum
48e3: 05,36               decw  R36              R36--;                            # update KAM cksum and return
48e5: 20,49               sjmp  4930             goto 4930; }
#
# Jump here from 48aa, 48c9, 48d2
48e7: f0                  ret                    return;
# 
# Lean correction
48e8: 03,3a               negw  R3a              R3a = -R3a;
48ea: 64,38,3a            ad2w  R3a,R38          R3a += R38;
48ed: a3,33,0a,02,42      ldw   R42,[R32+20a]    R42 = [R32+LAMBSE1];              # LAMBSEn [divide by 32768]
48f2: 88,3a,42            cmpw  R42,R3a          
48f5: d9,43               jgtu  493a             if ((uns) R42 <= R3a)  {          # return
48f7: b3,3f,b8,07,3c      ldb   R3c,[R3e+7b8]    R3c = [R3e+LPCT1L];               # increment LPCTnL
48fc: 17,3c               incb  R3c              R3c++;                            
48fe: c7,3f,b8,07,3c      stb   R3c,[R3e+7b8]    [R3e+LPCT1L] = R3c;              
4903: 45,82,03,fc,34      ad3w  R34,Rfc,382      R34 = FN1325;                     # Adaptive learning control table
4908: 64,30,34            ad2w  R34,R30          R34 += R30;
490b: b2,34,3d            ldb   R3d,[R34]        R3d = [R34];                      # pull value from ROM Table
490e: 19,01,3d            shlb  R3d,1            R3d *= 2;                         # byte << 1 (times 2)
4911: 98,3d,3c            cmpb  R3c,R3d          
4914: d1,24               jleu  493a             if ((uns) R3c <= R3d) return;
4916: b2,40,36            ldb   R36,[R40]        R36 = [R40];
4919: 9b,fc,71,36         cmpb  R36,[Rfc+71]                                       # adaptive control max
491d: db,1b               jgeu  493a             if ((uns) R36 >= MAXADP) return;
491f: 17,36               incb  R36              R36++;
4921: c6,40,36            stb   R36,[R40]        [R40] = R36;
4924: c7,3f,b8,07,00      stb   R0,[R3e+7b8]     [R3e+LPCT1L] = 0;                 # KAM - store value into same loc as above
4929: a3,01,02,07,36      ldw   R36,[R0+702]     R36 = CHKSUM;                     # KAM checksum
492e: 07,36               incw  R36              R36++;                            # incr cksum to match incr to value
#
# KAM adjustment done, finish up
# Jump here from 48e5
4930: c3,01,02,07,36      stw   R36,[R0+702]     CHKSUM = R36;                     # KAM checksum
4935: c7,3f,b2,07,00      stb   R0,[R3e+7b2]     [R3e+EGOCT1] = 0; }               # Clear EGOCTn
#
# Jump here from 48f5, 4914, 491d
493a: f0                  ret                    return;

#
# Lookup long term trims from KAM, save to KAMRFn
# Update LAMMUL as required
#
  Sub16:
493b: ad,80,3a            ldzbw R3a,80           R3a = (uns)80;                    # Set default LTFT values (0x80 = 1.0)
493e: ad,80,40            ldzbw R40,80           R40 = (uns)80;                    #
4941: 3f,a1,25            jb    B7,Ra1,4969      if (CRKFLG == 1) goto 4969;
4944: 31,ed,03            jnb   B1,Red,494a      if (LEGOFG1 == 0) goto 494a;
4947: 38,ed,1f            jb    B0,Red,4969      if (LEGOFG2 == 1) goto 4969;
#
494a: 33,ec,1e            jnb   B3,Rec,496b      if (REFFLG == 1)  {
494d: 37,26,06            jnb   B7,R26,4956      if (HCAMFG == 0) goto 4956;
4950: 9b,fc,7c,00         cmpb  R0,[Rfc+7c]      
4954: d7,15               jne   496b             if (0 == HCAMSW)  {
#
# Use special idle cells based on ISFLAG
# 
4956: af,72,eb,30         ldzbw R30,[R72+eb]     R30 = (uns)ISFLAG;
495a: 75,50,30            ad2b  R30,50           R30 += 50;
495d: 29,28               scall 4a87             FN1325_lkup();
495f: af,33,04,07,3a      ldzbw R3a,[R32+704]    R3a = (uns)[R32+LTMTB100];        # KAM Table 1
4964: af,33,5a,07,40      ldzbw R40,[R32+75a]    R40 = (uns)[R32+LTMTB200];        # KAM Table 2
#
4969: 20,90               sjmp  49fb             goto 49fb; } }
#
# Lookup normally using N, LOAD
# Do 4-point interpolation
#
496b: 45,de,00,f0,32      ad3w  R32,Rf0,de       R32 = FN070;                      # RPM scaling
4970: a0,ae,34            ldw   R34,Rae          R34 = N;
4973: ef,96,ec            call  360c             UUWordLu();
4976: a0,38,a6            ldw   Ra6,R38          NRMCES = R38;
4979: 45,b2,00,f0,32      ad3w  R32,Rf0,b2       R32 = FN021;                      # Load Scaling
497e: a3,74,de,34         ldw   R34,[R74+de]     R34 = LOAD;                       # engine load (VE)
4982: ef,87,ec            call  360c             UUWordLu();
4985: a0,38,a8            ldw   Ra8,R38          NRMRLD = R38;
4988: b0,a9,30            ldb   R30,Ra9          R30 = Ra9;
498b: 7d,0a,30            ml2b  R30,a            R30 *= a;
498e: 74,a7,30            ad2b  R30,Ra7          R30 += Ra7;
4991: 28,f4               scall 4a87             FN1325_lkup();
4993: b3,33,04,07,3c      ldb   R3c,[R32+704]    R3c = [R32+LTMTB100];             # KAM Table 1
4998: b3,33,5a,07,40      ldb   R40,[R32+75a]    R40 = [R32+LTMTB200];             # KAM Table 2
499d: 07,30               incw  R30              R30++;                            # Get next column
499f: 28,e6               scall 4a87             FN1325_lkup();
49a1: b3,33,04,07,3d      ldb   R3d,[R32+704]    R3d = [R32+LTMTB100];             # KAM Table 1
49a6: b3,33,5a,07,41      ldb   R41,[R32+75a]    R41 = [R32+LTMTB200];             # KAM Table 2
49ab: 99,07,a9            cmpb  Ra9,7            
49ae: d3,08               jltu  49b8             if ((uns) Ra9 >= 7)  {
# On last row of normal table - use the values from this row instead of idle cells
49b0: a0,3c,3e            ldw   R3e,R3c          R3e = R3c;
49b3: a0,40,42            ldw   R42,R40          R42 = R40;
49b6: 20,1d               sjmp  49d5             goto 49d5; }
# Get values from next row
49b8: 75,09,30            ad2b  R30,9            R30 += 9;                         # Bump to next row, original column
49bb: 28,ca               scall 4a87             FN1325_lkup();
49bd: b3,33,04,07,3e      ldb   R3e,[R32+704]    R3e = [R32+LTMTB100];             # KAM Table 1
49c2: b3,33,5a,07,42      ldb   R42,[R32+75a]    R42 = [R32+LTMTB200];             # KAM Table 2
49c7: 07,30               incw  R30              R30++;                            # Next column
49c9: 28,bc               scall 4a87             FN1325_lkup();
49cb: b3,33,04,07,3f      ldb   R3f,[R32+704]    R3f = [R32+LTMTB100];             # KAM Table 1
49d0: b3,33,5a,07,43      ldb   R43,[R32+75a]    R43 = [R32+LTMTB200];             # KAM Table 2
#
# R3C-R3F = contents of the 4 cells from LTMTB1
# R40-R43 = contents of the 4 cells from LTMTB2
#
# Note the use of UTabLookUp to do the interpolation as if these were 2x2 tables!
#
49d5: ac,a6,30            ldzbw R30,Ra6          R30 = (uns)NRMCES;                # load "fraction" part of column
49d8: ac,a8,32            ldzbw R32,Ra8          R32 = (uns)NRMRLD;                #  and row
49db: ad,02,34            ldzbw R34,2            R34 = (uns)2;
49de: a1,40,00,38         ldw   R38,40           R38 = 40;                         # bank 2 long term trims
49e2: ef,05,ed            call  36ea             UTabLookUp();
49e5: ac,3b,40            ldzbw R40,R3b          R40 = (uns)R3b;                   # bank 2 result
49e8: ac,a6,30            ldzbw R30,Ra6          R30 = (uns)NRMCES;                # load "fraction" part of column
49eb: ac,a8,32            ldzbw R32,Ra8          R32 = (uns)NRMRLD;                # and row
49ee: ad,02,34            ldzbw R34,2            R34 = (uns)2;
49f1: a1,3c,00,38         ldw   R38,3c           R38 = 3c;                         # bank 1 long term trims
49f5: ef,f2,ec            call  36ea             UTabLookUp();
49f8: ac,3b,3a            ldzbw R3a,R3b          R3a = (uns)R3b;                   # bank 1 result
# Come here from idle cell case
49fb: 65,80,00,3a         ad2w  R3a,80           R3a += 80;                        # Offset by 1.0
49ff: 65,80,00,40         ad2w  R40,80           R40 += 80;
4a03: c3,01,b4,07,3a      stw   R3a,[R0+7b4]     KAMRF1 = R3a;                     # and store as KAMRFn
4a08: c3,01,b6,07,40      stw   R40,[R0+7b6]     KAMRF2 = R40;                     #
4a0d: 38,ed,09            jb    B0,Red,4a19      if (LEGOFG2 == 1) goto 4a19;      # Bank 2 EGO not switching
4a10: b3,fe,16,30         ldb   R30,[Rfe+16]     R30 = NUMEGO;
4a14: 99,01,30            cmpb  R30,1            
4a17: d7,0c               jne   4a25             if (R30 == 1)  {                  # jmp if the no of EGOs != 1
# One EGO case (or two EGOs with EGO 2 failed)
4a19: a3,01,b4,07,30      ldw   R30,[R0+7b4]     R30 = KAMRF1;
4a1e: c3,01,b6,07,30      stw   R30,[R0+7b6]     KAMRF2 = R30;
4a23: 20,0d               sjmp  4a32             goto 4a32; }
# Two EGO case
4a25: 31,ed,0a            jnb   B1,Red,4a32      if (LEGOFG1 == 1)  {              # Bank 1 EGO not switching
4a28: a3,01,b6,07,30      ldw   R30,[R0+7b6]     R30 = KAMRF2;
4a2d: c3,01,b4,07,30      stw   R30,[R0+7b4]     KAMRF1 = R30; }

#################################################
# LAMMUL RAMP BACK LOGIC
# GUFB p. 6-17
#################################################
4a32: 45,18,00,f0,32      ad3w  R32,Rf0,18       R32 = &FN393F;         # FN393F(ECT)
4a37: b0,b0,34            ldb   R34,Rb0          R34 = ECT;
4a3a: ef,6f,eb            call  35ac             subyteLU();
#
# R38 = FN393F(ECT)
4a3d: 9b,72,c7,38         cmpb  R38,[R72+c7]     
4a41: d9,1a               jgtu  4a5d             if (FN393F(ECT) <= MULTMR)  {
4a43: a3,72,e8,30         ldw   R30,[R72+e8]     R30 = LAMMUL;
4a47: 89,00,01,30         cmpw  R30,100          
4a4b: df,10               je    4a5d             if (LAMMUL != 100)  {
4a4d: d9,04               jgtu  4a53             if ((uns) LAMMUL <= 100)  {
# LAMMUL < 1, increment
4a4f: 07,30               incw  R30              R30++;
4a51: 20,02               sjmp  4a55             goto 4a55; }

# LAMMUL > 1, decrement
4a53: 05,30               decw  R30              R30--;

# Store LAMMUL, clear MULTMR
4a55: c3,72,e8,30         stw   R30,[R72+e8]     LAMMUL = R30;
4a59: c7,72,c7,00         stb   R0,[R72+c7]      MULTMR = 0; } }

#################################################
# LAMMUL RESET LOGIC
# GUFB p. 6-18
#################################################
4a5d: b3,fe,02,32         ldb   R32,[Rfe+2]      R32 = TRLOAD;
4a61: 99,04,32            cmpb  R32,4            
4a64: d3,20               jltu  4a86             if ((uns) TRLOAD < 4) return;
4a66: 32,ee,1d            jnb   B2,Ree,4a86      if (OLFLG == 0) return;
4a69: 3e,26,05            jb    B6,R26,4a71      if (DNDSUP == 0)  {
4a6c: 91,02,ec            orb   Rec,2            NEUFLG = 1;
4a6f: 20,15               sjmp  4a86             return; }

4a71: 31,ec,12            jnb   B1,Rec,4a86      if (NEUFLG == 0) return;
4a74: 71,fd,ec            an2b  Rec,fd           NEUFLG = 0;
4a77: 45,4a,02,fc,32      ad3w  R32,Rfc,24a      R32 = FN371;   # FN371(ECT)
4a7c: bc,b0,34            ldsbw R34,Rb0          R34 = (int)ECT;
4a7f: ef,7f,eb            call  3601             SUWordLU();
4a82: c3,72,e8,38         stw   R38,[R72+e8]     LAMMUL = FN371(ECT); }
#
4a86: f0                  ret                    return;

################################################################
# FN1325 lookup
#
# Inputs:
#  R30 (word) - offset into FN1325 - (row * 0xA) + col
# Outputs:
#  R30 (word) - same
#  R32 (word) - corresponding offset into LTMTBn table
#  R34 (word) - background loop count to update if R30 == R32
#
  FN1325_lkup:
4a87: a0,30,32            ldw   R32,R30          R32 = R30;
4a8a: 45,82,03,fc,34      ad3w  R34,Rfc,382      R34 = FN1325;
4a8f: 64,30,34            ad2w  R34,R30          R34 += R30;
4a92: be,34,34            ldsbw R34,[R34]        R34 = (int)[R34];
4a95: 37,35,05            jnb   B7,R35,4a9d      if (R34 < 0) {
4a98: 03,34               negw  R34              R34 = -R34;
4a9a: a0,34,32            ldw   R32,R34          R32 = R34; }
4a9d: f0                  ret                    return;

################################################################
# Calculate pulsewidth conversion factor (PWCF)
# GUFB p. 6-79
# Called only from Sub24/Sub25 <- Sub20 <- Sub19/Calc_BG_Fuel
# Inputs:
#  R3C (word) = fuel flow rate / injector slope
# Outputs:
#  R30 = R3C * PWCF
#
  Calc_PWCF:
4a9e: a3,fc,2e,30         ldw   R30,[Rfc+2e]     R30 = PIPOUT;                     # # PIPs between events, same injector (x 0x20) (= 0x100 for A9L)
4aa2: 09,01,30            shlw  R30,1            R30 *= 2;                         #  
4aa5: 99,02,31            cmpb  R31,2            
4aa8: d1,04               jleu  4aae             if ((uns) R31 > 2 )  {            # Clip to 0x200
4aaa: a1,00,02,30         ldw   R30,200          R30 = 200; }
#
4aae: 09,06,30            shlw  R30,6            R30 *= 40;                        # (= 0x8000 for A9L)
4ab1: b3,fc,31,34         ldb   R34,[Rfc+31]     R34 = INJOUT;                     # injectors per port (= 1)
4ab5: 7f,fc,32,34         ml2b  R34,[Rfc+32]     R34 *= NUMOUT;                    # no. of injector ports (= 8)
4ab9: 7f,fe,07,34         ml2b  R34,[Rfe+7]      R34 *= ENGCYL;                    # PIPs/rev * 2 (= 8)
4abd: 6c,ae,34            ml2w  R34,Rae          R37:R34 = R35:R34 * N;            # INJOUT * NUMOUT * ENGCYL * N
4ac0: 0c,05,34            shrdw R34,5            R37:R34 /= 20;                    #  scale result
4ac3: 88,00,36            cmpw  R36,R0           
4ac6: df,03               je    4acb             if (R36 != 0)  {
4ac8: bd,ff,34            ldsbw R34,ff           R34 = 0xffff; }                   # clip on overflow
#
# R30 (word) = PIPOUT * 0x80
# R34 (word) = INJOUT * NUMOUT * ENGCYL * N / 0x20
# R3C (word) == ???
#
4acb: 6c,3c,30            ml2w  R30,R3c          R33:R30 = R31:R30 * R3d:R3c;
4ace: 8c,34,30            divw  R30,R34          R31:R30 = R33:R30 / R35:R34;
4ad1: d5,03               jnv   4ad6             if (OVF == 0) return;
4ad3: bd,ff,30            ldsbw R30,ff           R30 = 0xffff; }
4ad6: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 2C - calc injector pulse width?
#################################################################


  Calc_BG_Fuel:
#
# GUFB p. 6-80 top, middle
#
4ad7: 01,3e               clrw  R3e              R3e = 0;
4ad9: 37,a1,51            jnb   B7,Ra1,4b2d      if (CRKFLG == 1)  {
#
# Cranking fuel
#
4adc: 38,24,30            jb    B0,R24,4b0f      if (Wot == 0)  {
4adf: 45,d2,00,fa,32      ad3w  R32,Rfa,d2       R32 = FN348;                      # Cranking Fuel Pulse Width vs ECT
4ae4: bc,b0,34            ldsbw R34,Rb0          R34 = (int)ECT;
4ae7: ef,17,eb            call  3601             SUWordLU();
4aea: af,74,80,36         ldzbw R36,[R74+80]     R36 = (uns)BP;                    # barometric pressure
4aee: 6c,36,38            ml2w  R38,R36          R3b:R38 = R39:R38 * BP;
4af1: 8d,ef,00,38         divw  R38,ef           R39:R38 = R3b:R38 / 0xef;
4af5: d5,03               jnv   4afa             if (OVF == 1)  {
4af7: bd,ff,38            ldsbw R38,ff           R38 = 0xffff; }
#
4afa: c0,42,38            stw   R38,R42          R42 = R38;                        # R42 (word) = FN348(ECT) * (BP/29.875)
4afd: 45,ba,00,fa,32      ad3w  R32,Rfa,ba       R32 = FN306;                      # fuel crank pw multiplier vs. time
4b02: af,72,cf,34         ldzbw R34,[R72+cf]     R34 = (uns)CRKTMR;
4b06: ef,03,eb            call  360c             UUWordLu();
4b09: 4c,42,38,3c         ml3w  R3c,R38,R42      R3f:R3c = R39:R38 * R43:R42;      # R3C-3F (doubleword) = FN348(ECT) * (BP/29.875) * FN306(CRKTMR)
4b0d: 29,ae               scall 4cbd             DW_R3C_x4(); }                    # R3CL * 4 and clamped
#
# Jump here from:
#  4adc (CRKFLG && Wot)
#
# R3E = upper 16 bits of BGFUL1; 0 if WOT (clearing flooded engine)
#
4b0f: a3,f4,46,22         ldw   R22,[Rf4+46]     R22 = ALOSL;                      # injector slope low
4b13: c3,76,1a,3e         stw   R3e,[R76+1a]     BGFUL1 = R3e;
4b17: c3,76,1c,3e         stw   R3e,[R76+1c]     BGFUL2 = R3e;
4b1b: 4c,22,3e,3c         ml3w  R3c,R3e,R22      R3f:R3c = R3f:R3e * R23:R22;
4b1f: 29,9c               scall 4cbd             DW_R3C_x4();                      # R3CL * 4 and clamped
4b21: c3,72,16,3e         stw   R3e,[R72+16]     LBMF_INJ1 = R3e;
4b25: c3,72,18,3e         stw   R3e,[R72+18]     LBMF_INJ2 = R3e;
4b29: 71,df,e7            an2b  Re7,df           FFULFLG = 0;                      # Use background fuel
4b2c: f0                  ret                    return; }
#
# Jump here from:
#  4ad9 (!CRKFLG)
#
# Not cranking
# GUFB p. 6-80 bottom
# R3E (word) = 0
#
4b2d: 3b,2f,df            jb    B3,R2f,4b0f      if (NLMT_FLG == 1) goto 4b0f;     # RPM limiter fuel cutoff; R3E == 0
4b30: 32,ee,05            jnb   B2,Ree,4b38      if (OLFLG == 1)  {
#
# Open loop fuel
#
4b33: ef,f6,f9            call  452c             Calc_OL_Fuel();                   # Call address patched by Z_TABOFT in GUFB.xls
                                                                                   # "Disabled" -> Calc_OL_Fuel
                                                                                   # "Enabled"  -> 0x8800 (patch)
                                                                                   # "Enabled w/ no WRMEGO check" -> 0x8806 (patch)
4b36: 20,03               sjmp  4b3b             goto 4b3b; }
#
# Closed loop fuel
#
4b38: ef,8b,f7            call  42c6             Calc_CL_Fuel();
#
# Store LAMBSEn for calibration console use
# (no readers of DSLMBSn in the strategy)
#
4b3b: a3,74,8c,38         ldw   R38,[R74+8c]     R38 = LAMBSE1;                    # Desired air/fuel ratio for the left bank
4b3f: 69,00,80,38         sb2w  R38,8000         R38 -= 8000;
4b43: c3,74,84,38         stw   R38,[R74+84]     DSLMBS1 = R38;
4b47: a3,74,8e,38         ldw   R38,[R74+8e]     R38 = LAMBSE2;                    # Desired air/fuel ratio for the right bank
4b4b: 69,00,80,38         sb2w  R38,8000         R38 -= 8000;
4b4f: c3,74,86,38         stw   R38,[R74+86]     DSLMBS2 = R38;
4b53: 2d,e6               scall 493b             Sub16();                          # Get KAMRFn from LTFT tables, handle LAMMUL
4b55: ef,35,04            call  4f8d             Sub29();                          # Calculate transient fuel
4b58: ef,a2,01            call  4cfd             Sub27();                          # Calculate background injector timing

#################################################################
# Tasklist Routine at 2151, routine offset 8E Fall thru?
# Inputs:
# R40 (byte) - ???
#################################################################

  Sub19:
4b5b: 01,16               clrw  R16              R16 = 0;                          # Bank 1 first
4b5d: 28,26               scall 4b85             Sub20();
4b5f: af,fe,16,16         ldzbw R16,[Rfe+16]     R16 = (uns)NUMEGO;
4b63: 31,16,02            jnb   B1,R16,4b68      if (B1_R16 == 1)  {
4b66: 28,1d               scall 4b85             Sub20(); }                        # Bank 2 if there is one
#
# FFULFLG computation
# GUFB p. 6-82, middle
#
4b68: 9b,f2,02,00         cmpb  R0,[Rf2+2]       
4b6c: d7,13               jne   4b81             if (0 == Bfulsw)  {
4b6e: 38,26,10            jb    B0,R26,4b81      if (IMFMFLG == 0)  {              # Instantaneous MAF input range error
4b71: 3b,c5,0d            jb    B3,Rc5,4b81      if (MFMFLG == 0)  {
4b74: 38,e7,0a            jb    B0,Re7,4b81      if (FOFFLG == 0)  {
4b77: 3a,e7,07            jb    B2,Re7,4b81      if (HSPFLG == 0)  {
4b7a: 3b,25,04            jb    B3,R25,4b81      if (FAM_FLG == 0)  {
4b7d: 91,20,e7            orb   Re7,20           FFULFLG = 1;                      # OK to use foreground air charge for PW calculation
4b80: f0                  ret                    return; } } } } } }

4b81: 71,df,e7            an2b  Re7,df           FFULFLG = 0;                      # Can't trust foreground air charge, use background PW
4b84: f0                  ret                    return;

# Part of background fuel logic
# Inputs:
#  R16 (word) = 0 for bank 1, 2 for bank 2
# Outputs:
#  BASEFFn
#  FUELFLOWn
#  LBMF_INJn
  Sub20:
4b85: ef,02,02            call  4d8a             DFSO_Calc();                      # Call address patched by Z_DFSW in GUFB.xls
                                                                                   # "enabled"  = 0x4D8A
                                                                                   # "disabled" = 0x4EE0, which bypasses all the DFSO logic
# R40 (word) = "D" from DFSO_calc
4b88: b1,40,38            ldb   R38,40           R38 = 40;                         # = 1 (scaled)
4b8b: 32,a1,0b            jnb   B2,Ra1,4b99      if (UNDSP == 1)  {
4b8e: 45,f6,00,fa,32      ad3w  R32,Rfa,f6       R32 = FN387;                      # Pulsewidth multiplier as function of ECT
4b93: b0,b0,34            ldb   R34,Rb0          R34 = ECT;
4b96: ef,13,ea            call  35ac             subyteLU(); }
# 
# Jump here from:
#  4b8b (!UNDSP)
#
4b99: 5c,38,40,14         ml3b  R14,R40,R38      R14 = R40 * R38;                  # R14 (word) <- D
4b9d: a0,a2,40            ldw   R40,Ra2          R40 = AM;
4ba0: 28,c6               scall 4c68             Calc_base_fuel_flow();            # Returns base fuel flow in R43:R40
4ba2: c3,17,82,01,42      stw   R42,[R16+182]    [R16+BASEFF1] = R42;              # Save high word per bank
4ba7: 28,d6               scall 4c7f             Add_AE_fuel();
4ba9: d6,03               jge   4bae             if (R42 < 0)  {
4bab: 6c,00,40            ml2w  R40,R0           R43:R40 = 0; }                    # if sum is negative, clip at zero
#
# R43:R40 (doubleword) = fuel flow rate
#
4bae: 28,d8               scall 4c88             Sub23();                          # Multiply by DFSO multiplier D
4bb0: c3,17,34,02,42      stw   R42,[R16+234]    [R16+FUELFLOW1] = R42;            # save high word per bank
4bb5: a0,42,1e            ldw   R1e,R42          R1e = R42;
4bb8: 01,1c               clrw  R1c              R1c = 0;
4bba: 0c,04,1c            shrdw R1c,4            R1f:R1c /= 10;                    # scale by 1/16
4bbd: af,fe,07,18         ldzbw R18,[Rfe+7]      R18 = (uns)ENGCYL;                # PIPs/rev * 2
4bc1: 6c,ae,18            ml2w  R18,Rae          R1b:R18 = ENGCYL * N;             #  * N
4bc4: 0c,03,18            shrdw R18,3            R1b:R18 /= 8;                     # Account for scale factors (ENGCYL: 2, N: 4)
4bc7: 8c,18,1c            divw  R1c,R18          R1d:R1c = R1f:R1c / R19:R18;      # Divide flow rate / # injector pulses,
                                                                                   #  result is fuel mass per pulse in R1c
4bca: d5,03               jnv   4bcf             if (OVF == 1)  {
4bcc: bd,ff,1c            ldsbw R1c,ff           R1c = 0xffff; }
#
4bcf: c3,17,96,01,1c      stw   R1c,[R16+196]    [R16+LBMF_INJ1] = R1c;            # Save per bank
4bd4: 45,56,02,f4,32      ad3w  R32,Rf4,256      R32 = FN389;                      # Inj. breakpoint vs VBAT, lbm/rev
4bd9: af,74,93,34         ldzbw R34,[R74+93]     R34 = (uns)VBAT;                  # Battery Voltage Level * 16
4bdd: ef,2c,ea            call  360c             UUWordLu();
4be0: 6c,ae,38            ml2w  R38,Rae          R3b:R38 = FN389(VBAT) * N;        # Injector breakpoint as lbm/m (lbm/hr?)
4be3: 0c,01,38            shrdw R38,1            R3b:R38 /= 2;
4be6: 6c,00,1c            ml2w  R1c,R0           R1f:R1c = 0;
4be9: a3,f4,46,22         ldw   R22,[Rf4+46]     R22 = ALOSL;                      # injector slope low
4bed: 88,3a,42            cmpw  R42,R3a                                            # compare flow rate to low slope
4bf0: d1,15               jleu  4c07             if ((uns) R42 > R3a )  {
4bf2: 28,b2               scall 4ca6             Sub24();                          # Get breakpoint contribution to pulsewidth at low slope
4bf4: a0,30,1c            ldw   R1c,R30          R1c = R30;
4bf7: a3,f4,48,22         ldw   R22,[Rf4+48]     R22 = AHISL;                      # injector slope high
4bfb: 28,a9               scall 4ca6             Sub24();                          # Get breakpoint contribution at high slope
4bfd: 48,30,1c,1e         sb3w  R1e,R1c,R30      R1e = R1c - R30;                  #  and subtract it from low slope PW
4c01: 68,3a,42            sb2w  R42,R3a          R42 -= R3a;                       #  and subtract breakpoint from flow rate
4c04: a8,38,40            sbbw  R40,R38          R40 -= R38 - CY; }
#
# Jump here from:
#  4bf0 (R42 <= R3A), i.e. fuel rate less/equal low slope
#
# R43:R40 (doubleword): fuel flow rate
# R22 (word): injector slope (low if jumped here, high if fell through)
#
4c07: 28,a5               scall 4cae             Sub25();                          # calc one more time
4c09: 64,1c,30            ad2w  R30,R1c          R30 += R1c;                       # and add it to the results from above
4c0c: d3,03               jnc   4c11             if (unsigned overflow)  {
4c0e: bd,ff,30            ldsbw R30,ff           R30 = 0xffff; }
#
4c11: c3,17,94,03,30      stw   R30,[R16+394]    [R16+BGFUL1] = R30;               # Save per bank
4c16: 6c,00,40            ml2w  R40,R0           R43:R40 = 0;
4c19: 11,14               clrb  R14              R14 = 0;
4c1b: 28,62               scall 4c7f             Add_AE_fuel();
#
# R43:R40 contains AEFTRFF as a signed doubleword
#
4c1d: d6,09               jge   4c28             if (R42 < 0)  {
4c1f: 17,14               incb  R14              R14++;
4c21: 02,42               cplw  R42              R42 = ~R42;
4c23: 03,40               negw  R40              R40 = -R40;
4c25: a4,00,42            adcw  R42,R0           R42 += CY; }
#
4c28: 28,5e               scall 4c88             Sub23();                          # Multiply total fuel by D (decel fuel factor)
4c2a: 28,82               scall 4cae             Sub25();
4c2c: a1,ff,7f,32         ldw   R32,7fff         R32 = 7fff;
4c30: 88,32,30            cmpw  R30,R32          
4c33: d1,03               jleu  4c38             if ((uns) R30 > R32 )  {
4c35: a0,32,30            ldw   R30,R32          R30 = R32; }
#
4c38: 30,14,02            jnb   B0,R14,4c3d      if (Isl_acon == 1)  {
4c3b: 03,30               negw  R30              R30 = -R30; }
#
4c3d: 64,1e,30            ad2w  R30,R1e          R30 += R1e;
4c40: d5,07               jnv   4c49             if (OVF == 1)  {
4c42: a0,32,30            ldw   R30,R32          R30 = R32;
4c45: d6,02               jge   4c49             if (R30 < 0)  {
4c47: 03,30               negw  R30              R30 = -R30; } }
#
4c49: c3,17,9c,03,30      stw   R30,[R16+39c]    [R16+FFULC1] = R30;               # Save as (signed) pulsewidth delta for accel/transient fuel
4c4e: a0,a2,40            ldw   R40,Ra2          R40 = AM;
4c51: 28,15               scall 4c68             Calc_base_fuel_flow();
4c53: 28,33               scall 4c88             Sub23();
4c55: 28,57               scall 4cae             Sub25();
4c57: a3,74,d4,32         ldw   R32,[R74+d4]     R32 = ARCHG;
4c5b: fa                  di                     disable ints;
4c5c: ff                  nop                    
4c5d: c3,17,98,03,30      stw   R30,[R16+398]    [R16+FFULM1] = R30;
4c62: c3,76,26,32         stw   R32,[R76+26]     ARCHG_BG = R32;
4c66: fb                  ei                     enable ints;
4c67: f0                  ret                    return;

#
# Calculate base fuel flow
# GUFB p. 6-75
# Inputs:
#  R16 (word) = 0 for bank 1, 2 for bank 2
#  R40 (word) = AM
# Outputs:
#  R43:R40 (doubleword) = BASEFFn
#
  Calc_base_fuel_flow:
4c68: 6d,7c,11,40         ml2w  R40,117c         R43:R40 = R41:R40 * 0x117c;       # Constant 0x117c represents stoichiometric fuel:air ratio
                                                                                   # *** My tune = 122F in place of 117C - see Z_AFR in GUFB.xls
4c6c: 8f,17,0a,02,40      divw  R40,[R16+20a]    R41:R40 = R43:R40 / [R16+LAMBSE1];
4c71: d5,03               jnv   4c76             if (OVF == 1)  {
4c73: bd,ff,40            ldsbw R40,ff           R40 = 0xffff; }
#
4c76: 6f,17,b4,07,40      ml2w  R40,[R16+7b4]    R43:R40 = R41:R40 * [R16+KAMRF1];
4c7b: 0d,05,40            shldw R40,5            R43:R40 *= 20;
4c7e: f0                  ret                    return;

#
# Sum base fuel with accel, transient fuel
# Inputs:
#  R40-R43 (doubleword): Base fuel flow rate, BASEFFn
#  AEFTRFFL, AEFTRFF (doubleword): (Accel + transient)/2 fuel flow rate
# Outputs:
#  R40-43 (doubleword): Total fuel flow rate for one bank
#
  Add_AE_fuel:
4c7f: 67,76,2a,40         ad2w  R40,[R76+2a]     R40 += AEFTRFFL;
4c83: a7,76,28,42         adcw  R42,[R76+28]     R42 += AEFTRFF + CY;
4c87: f0                  ret                    return;

#
# Fuel rate portion of FUELPWn calculation
# GUFB p. 6-76
# Inputs:
#  R14 (word): D (Decel Fuel Shutoff multiplier)
#  R40-43 (doubleword): Desired fuel flow rate
# Outputs:
#  R40-43 (doubleword): D * flow rate, scaled
#
  Sub23:
4c88: 99,07,43            cmpb  R43,7            
4c8b: d1,05               jleu  4c92             if ((uns) R43 > 7 )  {
4c8d: bd,ff,42            ldsbw R42,ff           R42 = 0xffff;                    # Clip if shift would overflow
4c90: 20,03               sjmp  4c95             goto 4c95; }
#
4c92: 0d,05,40            shldw R40,5            R43:R40 *= 20;
#
4c95: 4c,14,42,40         ml3w  R40,R42,R14      R43:R40 = R43:R42 * D;
4c99: 99,1f,43            cmpb  R43,1f           
4c9c: d1,04               jleu  4ca2             if ((uns) R43 > 1f )  {
4c9e: bd,ff,42            ldsbw R42,ff           R42 = 0xffff;                    # Clip if shift would overflow
4ca1: f0                  ret                    return; }
#
4ca2: 0d,03,40            shldw R40,3            R43:R40 *= 8;
4ca5: f0                  ret                    return;

#
# Part of Calc_BG_Fuel
#
# Inputs:
#  R3b:R38: Fuel flow rate (as lbm/m)
#  R22 (word): Injector slope
#
# Outputs:
#  
  Sub24:
4ca6: a0,38,3c            ldw   R3c,R38          R3c = R38;
4ca9: a0,3a,3e            ldw   R3e,R3a          R3e = R3a;
4cac: 20,06               sjmp  4cb4             goto 4cb4;

#
# Part of Calc_BG_Fuel
# Inputs:
#  R43:R40: Fuel flow rate
#  R22 (word): Injector slope
#
# Outputs:
#  R30 (word) = ?? * PWCF
#
  Sub25:
4cae: a0,40,3c            ldw   R3c,R40          R3c = R40;
4cb1: a0,42,3e            ldw   R3e,R42          R3e = R42;
#
# Jump here from 4cac
#
4cb4: 0c,04,3c            shrdw R3c,4            R3f:R3c /= 10;
4cb7: 8c,22,3c            divw  R3c,R22          R3d:R3c = R3f:R3c / R23:R22;
4cba: 2d,e2               scall 4a9e             Calc_PWCF();
4cbc: f0                  ret                    return;


  DW_R3C_x4:
4cbd: 99,3f,3f            cmpb  R3f,3f                                             # clamp max R3F to 3FFF
4cc0: d1,04               jleu  4cc6             if ((uns) R3f > 3f )  {
4cc2: a1,ff,3f,3e         ldw   R3e,3fff         R3e = 3fff; }
4cc6: 0d,02,3c            shldw R3c,2            R3f:R3c *= 4;
4cc9: f0                  ret                    return;


#################################################################
# Tasklist Routine at 2151, routine offset 1E
# update fuel consumption for DOL
# See GUFB p. 14-2
#
# Inputs/outputs:
#  FUEL_SUM_l, FUEL_SUM_h
#  DOL_COUNT
#
# Clobbers: R14-R1b
#################################################################

  Update_flDOL:
4cca: 9b,74,ce,00         cmpb  R0,[R74+ce]                                        # Fuel Sum High
4cce: d2,2c               jgt   4cfc             if (0 <= FUEL_SUM_h)  {
4cd0: af,fc,31,14         ldzbw R14,[Rfc+31]     R14 = (uns)INJOUT;                # No of injectors fired by each output port. (= 1 in A9L)
4cd4: 6d,7c,1e,14         ml2w  R14,1e7c         R17:R14 = R15:R14 * 0x1e7c;       # 1 * 1e7c = 1e7c
4cd8: 01,18               clrw  R18              R18 = 0;
4cda: a1,00,02,1a         ldw   R1a,200          R1a = 200;
4cde: 8c,14,18            divw  R18,R14          R19:R18 = R1b:R18 / R15:R14;      # R18 = 0x2000000 / 0x1e7c = 10cb
4ce1: fa                  di                     disable ints;
4ce2: a3,74,cc,14         ldw   R14,[R74+cc]     R14 = FUEL_SUM_l;
4ce6: af,74,ce,16         ldzbw R16,[R74+ce]     R16 = (uns)FUEL_SUM_h;
4cea: 8c,18,14            divw  R14,R18          R15:R14 = R17:R14 / R19:R18;      # = FUEL_SUM / R18
4ced: c3,74,cc,16         stw   R16,[R74+cc]     FUEL_SUM_l = R16;                 # FUEL_SUM_l = FUEL_SUM % R18
4cf1: c7,74,ce,00         stb   R0,[R74+ce]      FUEL_SUM_h = 0;
4cf5: 09,01,14            shlw  R14,1            R14 *= 2;                         
4cf8: 64,14,c6            ad2w  Rc6,R14          DOL_COUNT += R14;                 # add to Data Output Link Count
4cfb: fb                  ei                     enable ints; }
#
4cfc: f0                  ret                    return;


##########################################################
# Calculate background injector timing
# GUFB pp. 6-93, 6-94
##########################################################

Sub27:
4cfd: 11,3e               clrb  R3e              R3e = 0;
4cff: 3e,26,16            jb    B6,R26,4d18      if (DNDSUP == 0)  {
#
# Transmission in neutral
4d02: 9b,f4,08,00         cmpb  R0,[Rf4+8]                                         
4d06: df,10               je    4d18             if (0 != CINTSW)  {
4d08: 45,3f,00,fc,30      ad3w  R30,Rfc,3f       R30 = &NITMR3;                    # "A" logic (GUFB p. 6-94)
4d0d: ef,3f,ea            call  374f             Check_Timers();
4d10: db,06               jc    4d18             if (not time)  {
4d12: b3,f4,09,3f         ldb   R3f,[Rf4+9]      R3f = CINTV;                      # Static neutral injector timing
4d16: 20,64               sjmp  4d7c             goto 4d7c; } } }
#
4d18: 33,ef,0c            jnb   B3,Ref,4d27      if (IDLFLG == 1)  {
#
# At idle in drive
4d1b: 9b,fc,3e,00         cmpb  R0,[Rfc+3e]      
4d1f: df,06               je    4d27             if (0 != CIDRSW)  {
4d21: b3,fc,3d,3f         ldb   R3f,[Rfc+3d]     R3f = MIDTV;                      # Use static drive idle injector timing
4d25: 20,55               sjmp  4d7c             goto 4d7c; } }
#
4d27: 30,ec,06            jnb   B0,Rec,4d30      if (MFAFLG == 1)  {
#
# Managed Fuel Air active
4d2a: b3,fc,3c,3f         ldb   R3f,[Rfc+3c]     R3f = MINTV;                      # Use static MFA injector timing
4d2e: 20,4c               sjmp  4d7c             goto 4d7c; }
#
# General case - use FN1315
4d30: 45,de,00,f0,32      ad3w  R32,Rf0,de       R32 = FN070;                      # RPM scaling
4d35: a0,ae,34            ldw   R34,Rae          R34 = N;
4d38: ef,d1,e8            call  360c             UUWordLu();
4d3b: 08,04,38            shrw  R38,4            R38 /= 10;
4d3e: b0,38,30            ldb   R30,R38          R30 = R38;
4d41: 45,72,01,f4,32      ad3w  R32,Rf4,172      R32 = FN085;                      # injector time load scaling
4d46: a3,74,de,34         ldw   R34,[R74+de]     R34 = LOAD;                       # engine load (VE)
4d4a: ef,bf,e8            call  360c             UUWordLu();
4d4d: b0,38,32            ldb   R32,R38          R32 = R38;
4d50: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
4d53: 45,8a,01,f4,38      ad3w  R38,Rf4,18a      R38 = FN1315;                     # Injector Timing (crank degrees)(RPM vs LOAD)
4d58: ef,80,e9            call  36db             UTabLu16();
4d5b: 11,3c               clrb  R3c              R3c = 0;
4d5d: b0,3b,3d            ldb   R3d,R3b          R3d = R3b;
4d60: 08,01,3c            shrw  R3c,1            R3c /= 2;
4d63: 6f,f4,26,3c         ml2w  R3c,[Rf4+26]     R3f:R3c = R3d:R3c * IDKMUL;
4d67: 67,f4,28,3e         ad2w  R3e,[Rf4+28]     R3e += IDKADD;                    # injector delay global = 0
4d6b: d6,02               jpos  4d6f             if (R3e < 0)  {
4d6d: 01,3e               clrw  R3e              R3e = 0; }                        # clip to 0 if negative
#
4d6f: 89,00,2d,3e         cmpw  R3e,2d00         
4d73: d1,04               jleu  4d79             if ((uns) R3e > 2d00 )  {
4d75: a1,00,2d,3e         ldw   R3e,2d00         R3e = 2d00; }                     # clip max
4d79: 09,02,3e            shlw  R3e,2            R3e *= 4;
4d7c: ef,d5,e8            call  3654             Urolav_3Arg(INJDLY,3e,TCINJD);       # Calculate rolling average
4d7f: 80,01,3e,00,58,d0   #args  
4d85: c3,72,00,3e         stw   R3e,[R72+0]      INJDLY = R3e;                     # Store result
4d89: f0                  ret                    return;

#
# Decel Fuel Shut Off logic
# GUFB pp. 6-67 - 6-73
#  
# Inputs:
# Outputs:
#  R40 (word) = "D" (decel factor from FM374 if DFSO active, or 1 if not);
#   scaled so 0x8000 == 1.0
#  DFSFLG = 1 iff "D" == 0, 0 otherwise
#  Declflg = 1 if conditions met for DFSO
#
  DFSO_Calc:
#
# "A" Logic
# GUFB p. 6-72
#
4d8a: a3,fc,46,1a         ldw   R1a,[Rfc+46]     R1a = DFLOD;
4d8e: 8b,74,de,1a         cmpw  R1a,[R74+de]                                       # engine load (VE)
4d92: d1,05               jleu  4d99             if ((uns) DFLOD > LOAD )  {
4d94: 91,80,e8            orb   Re8,80           Dcelq1 = 1;
4d97: 20,12               sjmp  4dab             goto 4dab; }
#
4d99: 67,fc,48,1a         ad2w  R1a,[Rfc+48]     R1a += DFLODH;
4d9d: d3,03               jnc   4da2             if (unsigned overflow)  {
4d9f: bd,ff,1a            ldsbw R1a,ff           R1a = 0xffff; }                   # clip if overflow
#
4da2: 8b,74,de,1a         cmpw  R1a,[R74+de]                                       # engine load (VE)
4da6: db,03               jgeu  4dab             if ((uns) (DFLOD + DFLODH) < LOAD)  {
4da8: 71,7f,e8            an2b  Re8,7f           Dcelq1 = 0; }
#
4dab: b3,fe,02,20         ldb   R20,[Rfe+2]      R20 = TRLOAD;
4daf: 99,02,20            cmpb  R20,2            
4db2: d3,03               jltu  4db7             if ((uns) TRLOAD < 2) goto 4db7;
4db4: 37,e7,05            jnb   B7,Re7,4dbc      if (NDSFLG == 1)  {
#
4db7: 91,40,e8            orb   Re8,40           Dcelq2 = 1;
4dba: 20,0e               sjmp  4dca             goto 4dca; }
#
4dbc: 99,04,20            cmpb  R20,4            
4dbf: db,06               jgeu  4dc7             if ((uns) TRLOAD >= 4) goto 4dc7;
4dc1: 9b,fc,4e,cc         cmpb  Rcc,[Rfc+4e]     
4dc5: d3,03               jltu  4dca             if ((uns) NDDTIM >= DSTM1)  {
#
4dc7: 71,bf,e8            an2b  Re8,bf           Dcelq2 = 0; }
#
4dca: 9b,fc,52,cd         cmpb  Rcd,[Rfc+52]     
4dce: d1,05               jleu  4dd5             if ((uns) NACTMR > DSFTM)  {
4dd0: 91,20,e8            orb   Re8,20           Dcelq3 = 1;
4dd3: 20,08               sjmp  4ddd             goto 4ddd; }
#
4dd5: 98,00,cd            cmpb  Rcd,R0           
4dd8: df,03               je    4ddd             if (NACTMR != 0)  {
4dda: 71,df,e8            an2b  Re8,df           Dcelq3 = 0; }
#
# "B" logic
# GUFB p. 6-73
#
4ddd: 11,18               clrb  R18              R18 = 0;                          # Scale DSDRPM same as N
4ddf: b3,72,e6,19         ldb   R19,[R72+e6]     R19 = DSDRPM;
4de3: 08,02,18            shrw  R18,2            R18 /= 4;
4de6: 48,18,ae,18         sb3w  R18,Rae,R18      R18 = N - R18;
4dea: 8b,fc,56,18         cmpw  R18,[Rfc+56]     
4dee: da,05               jle   4df5             if ((uns) R18 < SHFRPM)  {
4df0: 91,10,e8            orb   Re8,10           Dcelq4 = 1;
4df3: 20,10               sjmp  4e05             goto 4e05; }
#
4df5: a3,fc,56,1a         ldw   R1a,[Rfc+56]     R1a = SHFRPM;
4df9: 6b,fc,58,1a         sb2w  R1a,[Rfc+58]     R1a -= SHFHYS;
4dfd: 88,18,1a            cmpw  R1a,R18          
4e00: de,03               jlt   4e05             if (R1a >= R18)  {
4e02: 71,ef,e8            an2b  Re8,ef           Dcelq4 = 0; }
#
4e05: 8b,fc,4a,18         cmpw  R18,[Rfc+4a]     
4e09: da,05               jle   4e10             if ((uns) R18 < DSFRPM)  {
4e0b: 91,08,e8            orb   Re8,8            Dcelq5 = 1;
4e0e: 20,10               sjmp  4e20             goto 4e20; }
#
# GUFB p. 6-71
#
4e10: a3,fc,4a,1a         ldw   R1a,[Rfc+4a]     R1a = DSFRPM;                     # min rpm decel fuel shutoff
4e14: 6b,fc,4c,1a         sb2w  R1a,[Rfc+4c]     R1a -= DSFRPH;
4e18: 88,18,1a            cmpw  R1a,R18          
4e1b: da,03               jle   4e20             if ((uns) R1a < R18)  {
4e1d: 71,f7,e8            an2b  Re8,f7           Dcelq5 = 0; }
#
# "A" logic
# GUFB p. 6-72
#
4e20: b3,fc,5c,1a         ldb   R1a,[Rfc+5c]     R1a = DFSVS;
4e24: 9b,74,3f,1a         cmpb  R1a,[R74+3f]     
4e28: d9,05               jgtu  4e2f             if ((uns) R1a <= VSBAR_H)  {
4e2a: 91,08,ca            orb   Rca,8            Dfsvs_hys_flag = 1;
4e2d: 20,0f               sjmp  4e3e             goto 4e3e; }
#
4e2f: 7b,fc,5d,1a         sb2b  R1a,[Rfc+5d]     R1a -= DFSVSH;
4e33: d3,09               jltu  4e3e             if ((uns) R1a >= 0)  {
4e35: 9b,74,3f,1a         cmpb  R1a,[R74+3f]     
4e39: d1,03               jleu  4e3e             if ((uns) R1a > VSBAR_H )  {
4e3b: 71,f7,ca            an2b  Rca,f7           Dfsvs_hys_flag = 0; } }
#
# DLTMR Logic
# Doesn't match DLTMR logic on GUFB p. 20-16!
#
4e3e: a3,74,de,34         ldw   R34,[R74+de]     R34 = LOAD;                       # engine load (VE)
4e42: 8b,fc,5e,34         cmpw  R34,[Rfc+5e]     
4e46: db,05               jgeu  4e4d             if ((uns) LOAD < DFLDL)  {
4e48: 91,04,ca            orb   Rca,4            Dfldl_hys_flag = 1;
4e4b: 20,09               sjmp  4e56             goto 4e56; }
#
4e4d: 8b,fc,60,34         cmpw  R34,[Rfc+60]     
4e51: d1,03               jleu  4e56             if ((uns) LOAD > DFLDH)  {
4e53: 71,fb,ca            an2b  Rca,fb           Dfldl_hys_flag = 0; }
#
4e56: 91,08,a1            orb   Ra1,8            DMFLG = 1;                        # Decel fuel low load timer enabled flag, 1 = Count up timer.
4e59: 37,d0,03            jnb   B7,Rd0,4e5f      if (APT >= 0) goto 4e5f;
4e5c: 3a,ca,07            jb    B2,Rca,4e66      if (Dfldl_hys_flag == 0)  {
#
4e5f: 71,f7,a1            an2b  Ra1,f7           DMFLG = 0;
4e62: c7,72,d0,00         stb   R0,[R72+d0]      DLTMR = 0; }
#
# Main DFSO logic
# GUFB p. 6-71
#
4e66: 51,f8,c5,32         an3b  R32,Rc5,f8       R32 = Fmem_flags & f8;
4e6a: d7,74               jne   4ee0             if (R32 == 0)  {
4e6c: 45,6a,03,fc,32      ad3w  R32,Rfc,36a      R32 = FN374;                      # DFSO Open Loop Fuel Multiplier vs RPM
4e71: a0,ae,34            ldw   R34,Rae          R34 = N;
4e74: ef,95,e7            call  360c             UUWordLu();
4e77: a0,38,40            ldw   R40,R38          R40 = R38;                        # R40 (Word) <- Result of FN374
4e7a: 33,e8,63            jnb   B3,Re8,4ee0      if (Dcelq5 == 1)  {
4e7d: 38,ec,60            jb    B0,Rec,4ee0      if (MFAFLG == 0)  {               # Not in Managed Fuel Air mode
4e80: 3d,2a,5d            jb    B5,R2a,4ee0      if (RUNNING == 0)  {              # Not in KOER self test
4e83: 9b,fc,45,b0         cmpb  Rb0,[Rfc+45]                                       # min ect decel fuel shutoff (140.0DegF)
4e87: d6,06               jge   4e8f             if (ECT >= DFSECT) goto 4e8f;
4e89: 9b,f4,0d,c8         cmpb  Rc8,[Rf4+d]      
4e8d: d1,51               jleu  4ee0             if ((uns) ATMR1 > AGB)  {
#
4e8f: 33,a1,0a            jnb   B3,Ra1,4e9c      if (DMFLG == 0) goto 4e9c;
4e92: b3,72,d0,1a         ldb   R1a,[R72+d0]     R1a = DLTMR;
4e96: 9b,fc,62,1a         cmpb  R1a,[Rfc+62]     
4e9a: d3,3c               jltu  4ed8             if ((uns) DLTMR < DLDFSO) goto 4ed8;
#
4e9c: 37,d0,14            jnb   B7,Rd0,4eb3      if (APT >= 0) goto 4eb3;
4e9f: 3f,e7,11            jb    B7,Re7,4eb3      if (NDSFLG == 1) goto 4eb3;
4ea2: 34,e8,0e            jnb   B4,Re8,4eb3      if (Dcelq4 == 0) goto 4eb3;
4ea5: 99,03,20            cmpb  R20,3            
4ea8: d9,09               jgtu  4eb3             if ((uns) R20 > 3 ) goto 4eb3;
4eaa: b3,fc,4f,1a         ldb   R1a,[Rfc+4f]     R1a = DSTM2;
4eae: 98,cc,1a            cmpb  R1a,Rcc          
4eb1: d9,25               jgtu  4ed8             if ((uns) DSTM2 > NDDTIM) goto 4ed8;
#
4eb3: 37,e8,2a            jnb   B7,Re8,4ee0      if (Dcelq1 == 1)  {
4eb6: 36,e8,27            jnb   B6,Re8,4ee0      if (Dcelq2 == 1)  {
4eb9: 33,ca,24            jnb   B3,Rca,4ee0      if (Dfsvs_hys_flag == 1)  {
4ebc: 9b,fc,63,00         cmpb  R0,[Rfc+63]      
4ec0: d7,16               jne   4ed8             if (0 != PTDFSW) goto 4ed8;
4ec2: 37,d0,1b            jnb   B7,Rd0,4ee0      if (APT < 0)  {
4ec5: b3,72,aa,1a         ldb   R1a,[R72+aa]     R1a = CTTMR;
4ec9: 9b,fc,50,1a         cmpb  R1a,[Rfc+50]     
4ecd: d3,11               jltu  4ee0             if ((uns) CTTMR >= CTDFSO)  {
4ecf: 3d,e8,06            jb    B5,Re8,4ed8      if (Dcelq3 == 1) goto 4ed8;
4ed2: 9b,fc,51,1a         cmpb  R1a,[Rfc+51]     
4ed6: d1,08               jleu  4ee0             if ((uns) CTTMR > CTEDSO)  {
#
4ed8: 91,02,ca            orb   Rca,2            Declflg = 1;                      # Success!
4edb: b1,01,b3            ldb   Rb3,1            PPCTR = 1;                        # Set PPCTR = 1
4ede: 20,07               sjmp  4ee7             goto 4ee7; } } } } } } } } } } }  # D = R40 = FN374(N) from 4e77 above
# 
4ee0: a1,80,00,40         ldw   R40,80           R40 = 80;                         # Not enabled, set D = 1.0
4ee4: 71,fd,ca            an2b  Rca,fd           Declflg = 0;
#
4ee7: 71,fd,27            an2b  R27,fd           DFSFLG = 0;                       # Clear DFSFLG 
4eea: 89,00,00,40         cmpw  R40,0            
4eee: d7,03               jne   4ef3             if (R40 != 0) return;             # Return with DFSFLG disabled
4ef0: 91,02,27            orb   R27,2            DFSFLG = 1; }                     # Enable DFSO
4ef3: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset E
#################################################################
#
# AEFUEL (accelerator pump) logic
# GUFB p. 6-57
#
  Do_accelpump:
4ef4: 01,38               clrw  R38              R38 = 0;
4ef6: 37,a1,02            jnb   B7,Ra1,4efb      if (CRKFLG == 0) goto 4efb;
4ef9: 20,89               sjmp  4f84             goto 4f84;
#
4efb: b3,74,20,30         ldb   R30,[R74+20]     R30 = TAR;                        # scale and translated TAR
4eff: 9b,f4,34,30         cmpb  R30,[Rf4+34]     
4f03: d1,f4               jleu  4ef9             if ((uns) R30 <= AETAR) goto 4ef9;
4f05: 35,29,10            jnb   B5,R29,4f18      if (AEOFLG == 0) goto 4f18;
4f08: a3,74,de,42         ldw   R42,[R74+de]     R42 = LOAD;                       # engine load (VE)
4f0c: 6b,74,9e,42         sb2w  R42,[R74+9e]     R42 -= AELOAD;
4f10: d3,06               jltu  4f18             if ((uns) LOAD - AELOAD < 0) goto 4f18;
4f12: 8b,f4,32,42         cmpw  R42,[Rf4+32]     
4f16: d1,6c               jleu  4f84             if ((uns) LOAD - AELOAD > AEACLD )  {
#
4f18: 45,9e,00,f0,32      ad3w  R32,Rf0,9e       R32 = FN019B;                     # Table 8C9E fuel tp scaling
4f1d: b3,74,20,34         ldb   R34,[R74+20]     R34 = TAR;                        # scale and translated TAR
4f21: ef,93,e6            call  35b7             UUbyteLu();
4f24: b0,38,30            ldb   R30,R38          R30 = R38;
4f27: 45,a8,00,f0,32      ad3w  R32,Rf0,a8       R32 = FN020B;                     # Table 8CA8 fuel ECT scaling
4f2c: b3,f4,35,36         ldb   R36,[Rf4+35]     R36 = FRCTAE;
4f30: ef,b5,f7            call  46e8             Sub14();
4f33: 0a,07,34            asrw  R34,7            R34 /= 80;
4f36: ef,73,e6            call  35ac             subyteLU();                       # R38 = FN020B(temp)
4f39: b0,38,32            ldb   R32,R38          R32 = R38;
4f3c: ad,08,34            ldzbw R34,8            R34 = (uns)8;
4f3f: 45,f5,01,f4,38      ad3w  R38,Rf4,1f5      R38 = FN1303;                     # accel pump rate - (Deg/sec vs ECT)
4f44: ef,94,e7            call  36db             UTabLu16();                       # 2D table lookup
4f47: ac,3b,3c            ldzbw R3c,R3b          R3c = (uns)R3b;
4f4a: 45,eb,01,f4,32      ad3w  R32,Rf4,1eb      R32 = FN331B;                     # Accelerator Enrichment Multiplier vs TP
4f4f: 4b,72,a6,aa,34      sb3w  R34,Raa,[R72+a6] R34 = TP - RATCH;                 # RAA is Throttle position - 126 - RATCH=Closed TP
4f54: db,02               jc    4f58             if (R34 > 0)  {
4f56: 01,34               clrw  R34              R34 = 0; }
4f58: 08,08,34            shrw  R34,8            R34 /= 100;
4f5b: ef,59,e6            call  35b7             UUbyteLu();
4f5e: 6c,38,3c            ml2w  R3c,R38          R3f:R3c = R3d:R3c * R39:R38;
4f61: b3,74,80,34         ldb   R34,[R74+80]     R34 = BP;                         # BP - barometric pressure
4f65: 45,a6,01,f0,32      ad3w  R32,Rf0,1a6      R32 = FN378;                      # Table 90A6
4f6a: ef,4a,e6            call  35b7             UUbyteLu();
4f6d: 11,39               clrb  R39              R39 = 0;
4f6f: 6c,38,3c            ml2w  R3c,R38          R3f:R3c = R3d:R3c * R39:R38;
4f72: 0d,03,3c            shldw R3c,3            R3f:R3c *= 8;
4f75: a3,f4,2c,38         ldw   R38,[Rf4+2c]     R38 = AEM;                        # accel pump multiplier
4f79: 6c,3e,38            ml2w  R38,R3e          R3b:R38 = R39:R38 * R3f:R3e;
4f7c: 98,00,3a            cmpb  R3a,R0           
4f7f: df,03               je    4f84             if (R3a != 0)  {
4f81: bd,ff,38            ldsbw R38,ff           R38 = 0xffff; } }
4f84: 6d,22,02,38         ml2w  R38,222          R3b:R38 = R39:R38 * EGRPER;
4f88: c3,72,0c,3a         stw   R3a,[R72+c]      AEFUEL = R3a;
4f8c: f0                  ret                    return;

#
# Transient fuel calculations
# 
  Sub29:
4f8d: b3,f4,3e,18         ldb   R18,[Rf4+3e]     R18 = MEFTRA;
4f91: 3f,a1,09            jb    B7,Ra1,4f9d      if (CRKFLG == 1) goto 4f9d;
4f94: 3a,a1,06            jb    B2,Ra1,4f9d      if (UNDSP == 1) goto 4f9d;
4f97: 9b,f4,3a,c8         cmpb  Rc8,[Rf4+3a]     
4f9b: db,07               jgeu  4fa4             if (ATMR1 < TFCTM)  {
4f9d: 71,f7,28            an2b  R28,f7           EFFLG1 = 0;                       # Too soon after start to use transient fuel
4fa0: 01,38               clrw  R38              R38 = 0;
4fa2: 21,23               sjmp  50c7             goto 50c7; }
#
4fa4: 45,d2,00,f0,32      ad3w  R32,Rf0,d2       R32 = FN022B;                     # Table 8CD2 - Column scaler for temp.
4fa9: b3,f4,2a,36         ldb   R36,[Rf4+2a]     R36 = ALPHA;
4fad: ef,38,f7            call  46e8             Sub14();
4fb0: 0a,07,34            asrw  R34,7            R34 /= 80;
4fb3: ef,f6,e5            call  35ac             subyteLU();
4fb6: ac,38,a6            ldzbw Ra6,R38          NRMCES = (uns)R38;
4fb9: 45,fa,00,f0,32      ad3w  R32,Rf0,fa       R32 = FN021;                      # Table 8CFA load scaling
4fbe: a3,74,de,34         ldw   R34,[R74+de]     R34 = LOAD;                       # engine load (VE)
4fc2: ef,47,e6            call  360c             UUWordLu();
4fc5: 08,04,38            shrw  R38,4            R38 /= 10;
4fc8: a0,38,a8            ldw   Ra8,R38          NRMRLD = R38;
4fcb: a0,a6,30            ldw   R30,Ra6          R30 = NRMCES;                     
4fce: a0,a8,32            ldw   R32,Ra8          R32 = NRMRLD;
4fd1: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
4fd4: 45,ba,02,fc,38      ad3w  R38,Rfc,2ba      R38 = FN1322;                     # Time constant
4fd9: ef,ff,e6            call  36db             UTabLu16();
4fdc: 5f,f4,3c,3b,40      ml3b  R40,R3b,[Rf4+3c] R40 = R3b * MTEFTC;
4fe1: a0,a6,30            ldw   R30,Ra6          R30 = NRMCES;
4fe4: a0,a8,32            ldw   R32,Ra8          R32 = NRMRLD;
4fe7: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
4fea: 45,6a,02,fc,38      ad3w  R38,Rfc,26a      R38 = FN1321;                     # Intake surface fuel
4fef: ef,e9,e6            call  36db             UTabLu16();
4ff2: 5f,f4,3b,3b,3a      ml3b  R3a,R3b,[Rf4+3b] R3a = R3b * MTEISF;
4ff7: 08,01,3a            shrw  R3a,1            R3a /= 2;
4ffa: 33,28,14            jnb   B3,R28,5011      if (EFFLG1 == 0) goto 5011;
4ffd: 31,27,29            jnb   B1,R27,5029      if (DFSFLG == 1)  {
5000: af,fc,44,38         ldzbw R38,[Rfc+44]     R38 = (uns)AISFM;
5004: 6c,3a,38            ml2w  R38,R3a          R3b:R38 = R39:R38 * R3b:R3a;
5007: 0d,09,38            shldw R38,9            R3b:R38 *= 200;
500a: d3,0e               jnc   501a             if (overflow)  {
500c: bd,ff,3a            ldsbw R3a,ff           R3a = 0xffff;
#
500f: 20,09               sjmp  501a             goto 501a;
#
5011: b3,f4,3d,14         ldb   R14,[Rf4+3d]     R14 = TFCISW;
5015: 38,14,02            jb    B0,R14,501a      if (Isl_acon == 0)  {
5018: 01,3a               clrw  R3a              R3a = 0; } }
501a: c3,74,14,00         stw   R0,[R74+14]      AISFL = 0;
501e: c3,74,16,3a         stw   R3a,[R74+16]     AISF = R3a;
5022: 01,38               clrw  R38              R38 = 0;
5024: 91,08,28            orb   R28,8            EFFLG1 = 1;
5027: 20,9e               sjmp  50c7             goto 50c7; }
#
5029: 4b,74,18,06,34      sb3w  R34,R6,[R74+18]  R34 = IO_Timer - DELTIM;
502e: c3,74,18,06         stw   R6,[R74+18]      DELTIM = IO_Timer;
5032: 6d,44,28,34         ml2w  R34,2844         R37:R34 = R35:R34 * 2844;
5036: a0,36,34            ldw   R34,R36          R34 = R36;
5039: fe,6c,9e,34         sml2w R34,R9e          R37:R34 = R35:R34 * EFTR;
503d: 67,74,14,34         ad2w  R34,[R74+14]     R34 += AISFL;
5041: a7,74,16,36         adcw  R36,[R74+16]     R36 += AISF + CY;
5045: c3,74,14,34         stw   R34,[R74+14]     AISFL = R34;
5049: c3,74,16,36         stw   R36,[R74+16]     AISF = R36;
504d: 11,18               clrb  R18              R18 = 0;
504f: 3b,ec,4e            jb    B3,Rec,50a0      if (REFFLG == 0)  {
5052: 9b,72,d7,00         cmpb  R0,[R72+d7]      
5056: de,48               jlt   50a0             if (0 >= ISCFLG)  {
5058: df,11               je    506b             if (0 == ISCFLG) goto 506b;
505a: af,72,e6,30         ldzbw R30,[R72+e6]     R30 = (uns)DSDRPM;
505e: 09,06,30            shlw  R30,6            R30 *= 40;
5061: 48,30,ae,30         sb3w  R30,Rae,R30      R30 = N - R30;
5065: 8b,f4,38,30         cmpw  R30,[Rf4+38]     
5069: de,35               jlt   50a0             if (R30 >= TFSMN)  {
506b: 8b,74,16,3a         cmpw  R3a,[R74+16]     
506f: df,2f               je    50a0             if (R3a != AISF)  {
5071: 4b,74,16,3a,34      sb3w  R34,R3a,[R74+16] R34 = R3a - AISF;
5076: d9,02               jgtu  507a             if ((uns) R34 <= 0)  {
5078: 03,34               negw  R34              R34 = -R34; }
507a: 01,36               clrw  R36              R36 = 0;
507c: 0d,08,34            shldw R34,8            R37:R34 *= 100;
507f: 88,00,3a            cmpw  R3a,R0           
5082: d7,05               jne   5089             if (R3a == 0)  {
5084: a0,36,34            ldw   R34,R36          R34 = R36;
5087: 20,03               sjmp  508c             goto 508c; }

5089: 8c,3a,34            divw  R34,R3a          R35:R34 = R37:R34 / R3b:R3a;
508c: 8b,f4,40,34         cmpw  R34,[Rf4+40]     
5090: d1,0e               jleu  50a0             if ((uns) R34 > TFCDED )  {
5092: b3,f4,3e,18         ldb   R18,[Rf4+3e]     R18 = MEFTRA;
5096: 8b,74,16,3a         cmpw  R3a,[R74+16]     
509a: db,04               jgeu  50a0             if (R3a > AISF)  {
509c: b3,f4,3f,18         ldb   R18,[Rf4+3f]     R18 = MEFTRD; } } } } } }
50a0: 11,42               clrb  R42              R42 = 0;
50a2: 6b,74,16,3a         sb2w  R3a,[R74+16]     R3a -= AISF;
50a6: db,04               jc    50ac             if (R3a > 0)  {
50a8: 17,42               incb  R42              R42++;
50aa: 03,3a               negw  R3a              R3a = -R3a; }
50ac: af,f4,36,38         ldzbw R38,[Rf4+36]     R38 = (uns)Kft;
50b0: 6c,3a,38            ml2w  R38,R3a          R3b:R38 = R39:R38 * R3b:R3a;
50b3: 0d,01,38            shldw R38,1            R3b:R38 *= 2;
50b6: 8c,40,38            divw  R38,R40          R39:R38 = R3b:R38 / R41:R40;
50b9: dd,03               jv    50be             if (OVF == 1) goto 50be;
50bb: 37,39,04            jnb   B7,R39,50c2      if (B7_R39 == 1)  {
50be: a1,ff,7f,38         ldw   R38,7fff         R38 = 7fff; }
50c2: 30,42,02            jnb   B0,R42,50c7      if (B0_R42 == 1)  {
50c5: 03,38               negw  R38              R38 = -R38; }
50c7: c0,9e,38            stw   R38,R9e          EFTR = R38;
50ca: 7d,78,18            ml2b  R18,78           R18 *= 78;
50cd: fe,6c,18,38         sml2w R38,R18          R3b:R38 = R39:R38 * R19:R18;
50d1: 0d,01,38            shldw R38,1            R3b:R38 *= 2;
50d4: c3,72,08,3a         stw   R3a,[R72+8]      EFTRFF = R3a;
50d8: 0e,01,38            asrdw R38,1            R3b:R38 /= 2;
50db: a3,72,0c,18         ldw   R18,[R72+c]      R18 = AEFUEL;
50df: 08,01,18            shrw  R18,1            R18 /= 2;
50e2: 64,18,3a            ad2w  R3a,R18          R3a += R18;
50e5: c3,76,28,3a         stw   R3a,[R76+28]     AEFTRFF = R3a;
50e9: c3,76,2a,38         stw   R38,[R76+2a]     AEFTRFFL = R38;
50ed: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 2E
# Update fuel pump enable. Skip if flag set.
# turn pump off if more than 1 sec elapsed since last PIP occurred
#################################################################

  Update_fpump:
50ee: 38,d9,11            jb    B0,Rd9,5102      if (Vip_fp_override == 0)  {
50f1: a3,72,be,14         ldw   R14,[R72+be]     R14 = TSLPIP;
50f5: 89,00,04,14         cmpw  R14,400                                            # = 1024 = 1 second
50f9: d3,04               jltu  50ff             if ((uns) R14 >= 400)  {
50fb: 71,7f,46            an2b  R46,7f           Pump = 0;
50fe: f0                  ret                    return; }
#
50ff: 91,80,46            orb   R46,80           Pump = 1; }
5102: f0                  ret                    return;

#################################################################
# Common EGR logic
# GUFB p. 8-7
#################################################################

  Sub30:
5103: 3f,a1,28            jb    B7,Ra1,512e      if (CRKFLG == 1) goto 512e;
5106: 51,fa,c5,38         an3b  R38,Rc5,fa       R38 = Fmem_flags & fa;
510a: d7,22               jne   512e             if (R38 != 0) goto 512e;
510c: 45,1f,00,fa,30      ad3w  R30,Rfa,1f       R30 = &EGRTD3;
5111: ef,3b,e6            call  374f             Check_Timers();
5114: db,18               jc    512e             if (not time) goto 512e;
5116: 38,d0,15            jb    B0,Rd0,512e      if (APT != 0) goto 512e;           # Closed throttle
# At part throttle (APT == 0)
5119: 3e,e6,16            jb    B6,Re6,5132      if (Pfehp_flg == 0)  {
511c: a3,72,a8,38         ldw   R38,[R72+a8]
5120: 6b,fa,28,38         sb2w  R38,[Rfa+28]     R38 = EOFF - EGRDED;
5124: db,02               jc    5128             if (R38 > 0)  {
5126: 01,38               clrw  R38              R38 = 0; }
#
5128: 8b,72,96,38         cmpw  R38,[R72+96]                                       # compare to raw EVP AD value
512c: d3,04               jltu  5132             if (IEVP < EOFF - EGRDED)  {

# Disable EGR
512e: 71,fe,28            an2b  R28,fe           EGREN = 0;
5131: f0                  ret                    return; } }

# Enable EGR
5132: 91,01,28            orb   R28,1            EGREN = 1;
5135: f0                  ret                    return;


#################################################################
# Tasklist Routine at 2151, routine offset 30
# EVP something 
#################################################################

  Calc_EVP:
5136: b3,fa,31,14         ldb   R14,[Rfa+31]     R14 = PFEHP;                      # 97D9 EGR Type contents = 00 - egr type ( 0=sonic, 1=PFE, 2=none)
513a: 30,14,03            jnb   B0,R14,5140      if (PFEHP & 1 == 1)  {            # jmp if sonic or no EGR
# Pressure Feedback EGR (PFE) - not present on A9L
513d: 91,40,e6            orb   Re6,40           Pfehp_flg = 1; }                  # PFEHP FLG - sonic h/w present from calibration data
#
5140: 31,14,0c            jnb   B1,R14,514f      if (PFEHP & 2 == 2)  {            # jmp if EGR = none or sonic
#
# PFEHP == 2 - No EGR hardware (or disabled in calibration)
#
5143: 75,02,9a            ad2b  R9a,2            Bg_offset += 2;                   # Skip over next B/G routine, which is Calc_EGR
5146: c7,74,0a,00         stb   R0,[R74+a]       EM = 0;                           # EGR Mass Flow = 0
514a: c7,72,ee,00         stb   R0,[R72+ee]      EGRACT = 0;                       # Actual EGR percent = 0
514e: f0                  ret                    return; }
#
# Either PFE or sonic EGR
514f: 37,a1,03            jnb   B7,Ra1,5155      if (CRKFLG == 0) goto 5155;
5152: e7,0d,01            jump  5262             goto 5262;
#
# Not cranking
5155: 3e,e6,03            jb    B6,Re6,515b      if (Pfehp_flg == 1) goto 515b;    # PFEHP FLG - sonic h/w present from calibration data
5158: e7,99,00            jump  51f4             goto 51f4;
#
# PFE calculations
#
# Calculate BPCOR from BP
# GUFB p. 8-15
515b: 45,08,01,fa,32      ad3w  R32,Rfa,108      R32 = FN004;                      # Table - BP correction for exhaust backpressure calculation, "Hg
5160: b3,74,80,34         ldb   R34,[R74+80]     R34 = BP;                         # BP - barometric pressure
5164: ef,50,e4            call  35b7             UUbyteLu();
5167: c7,74,81,38         stb   R38,[R74+81]     BPCOR = R38;                      # 1FF - BPCOR - BP corrected
#
# Calculate PEXT (exhaust absolute presssure) or PE (upstream exhaust gauge pressure)?
# GUFB pp. 8-2, 8-16
#
516b: a3,01,b4,07,34      ldw   R34,[R0+7b4]     R34 = KAMRF1;                     # KAMRF1 - Adaptive Fuel strategy correction factor. It is composed of the value LTMTB1rc + .5
5170: 6c,a2,34            ml2w  R34,Ra2          R37:R34 = KAMRF * AM;             # AM -> Air mass flow, (lb/min)
5173: 0c,07,34            shrdw R34,7            R34:R37 /= 80;
5176: 88,00,36            cmpw  R36,R0           
5179: df,03               je    517e             if (R36 != 0)  {
517b: bd,ff,34            ldsbw R34,ff           R34 = 0xffff; }                   # Clip to FFFF on overflow
#
517e: 45,12,01,fa,32      ad3w  R32,Rfa,112      R32 = FN074;                      # Table - Upstream pressure as a function of (AM * KAMREF).
5183: ef,86,e4            call  360c             UUWordLu();
5186: 6d,00,ef,38         ml2w  R38,ef00         R3b:R38 = R39:R38 * 0xef00;
518a: b3,74,81,37         ldb   R37,[R74+81]     R37 = BPCOR;                      # 1FF - BPCOR - BP corrected
518e: 11,36               clrb  R36              R36 = 0;
5190: 08,01,36            shrw  R36,1            R36 /= 2;
5193: 8c,36,38            divw  R38,R36          R39:R38 = R3b:R38 / R37:R36;
5196: d5,03               jnv   519b             if (OVF == 1)  {
5198: bd,ff,38            ldsbw R38,ff           R38 = 0xffff; }
#
519b: c0,40,38            stw   R38,R40          R40 = R38;                        # R40 = PE? PEXT?
#
# Calculate DP (downstream gauge pressure)
# GUFB p. 8-15
#
519e: a3,72,84,30         ldw   R30,[R72+84]     R30 = EPTBAR;                     # 104 - EPTBAR - Rolling average of the synchronously sampled EPT sensor (time constant = TCEPT),
                                                                                    secs
51a2: 08,01,30            shrw  R30,1            R30 /= 2;
51a5: a3,01,ee,07,32      ldw   R32,[R0+7ee]     R32 = EPTZER;                     # filtered EVP saved in KAM
51aa: 08,01,32            shrw  R32,1            R32 /= 2;
51ad: 68,32,30            sb2w  R30,R32          R30 -= R32;
51b0: a3,fa,2c,32         ldw   R32,[Rfa+2c]     R32 = XFREPT;                     # 97D4 - XFREPT - Transfer function of EPT sensor, " H20/counts
51b4: fe,6c,32,30         sml2w R30,R32          R33:R30 = R31:R30 * R33:R32;
51b8: 28,d9               scall 5293             Sub31();
51ba: 48,32,40,34         sb3w  R34,R40,R32      R34 = R40 - R32;
51be: 3f,33,06            jb    B7,R33,51c7      if (B7_R33 == 1) goto 51c7;
51c1: db,09               jc    51cc             if (R34 > 0)  {
51c3: 01,34               clrw  R34              R34 = 0;
51c5: 20,05               sjmp  51cc             goto 51cc;
#
51c7: d3,03               jltu  51cc             if ((uns) R34 >= 0)  {
51c9: bd,ff,34            ldsbw R34,ff           R34 = 0xffff; } }
51cc: c3,72,f6,34         stw   R34,[R72+f6]     DELPR = R34;                      # 176 - DELPR - Pressure drop across the control orifice, " H20 = PE - DP
51d0: 45,b6,01,fa,32      ad3w  R32,Rfa,1b6      R32 = 995e;                       # Table 995E - EGR mass flow as a function of DELPR, lb/min.
51d5: ef,34,e4            call  360c             UUWordLu();
51d8: b3,74,80,34         ldb   R34,[R74+80]     R34 = BP;                         # BP - barometric pressure
51dc: 7d,4b,34            ml2b  R34,4b           R34 *= 4b;
51df: 65,75,3a,34         ad2w  R34,3a75         R34 += 3a75;
51e3: 6c,34,38            ml2w  R38,R34          R3b:R38 = R39:R38 * R35:R34;
51e6: 09,01,3a            shlw  R3a,1            R3a *= 2;
51e9: d3,03               jnc   51ee             if ((uns) R3a >= 0)  {
51eb: b1,ff,3b            ldb   R3b,ff           R3b = ff; }
51ee: c7,74,0a,3b         stb   R3b,[R74+a]      EM = R3b;                         # 288 EM - EGR Mass Flow
51f2: 20,3e               sjmp  5232             goto 5232;
#
# EGR Mass (EM) calculation - Sonic
# GUFB p. 8-10
#
51f4: 11,38               clrb  R38              R38 = 0;
51f6: 51,f8,c5,34         an3b  R34,Rc5,f8       R34 = Fmem_flags & f8;
51fa: d7,32               jne   522e             if (R34 == 0)  {                  # Skip if ACT, ECT, EVP, MAF, or TP failed
51fc: b3,72,d7,34         ldb   R34,[R72+d7]     R34 = ISCFLG;                     # 157 - ISCFLG - ISC MODE Flag (1 = RPM CONTROL Mode)
5200: 99,01,34            cmpb  R34,1            
5203: de,06               jlt   520b             if (R34 < 1) goto 520b;
5205: 8b,74,90,00         cmpw  R0,[R74+90]                                        # 20E - DELOPT - Filtered desired EGR valve position.
5209: df,23               je    522e             if (0 != DELOPT)  {
#
520b: a3,72,f0,34         ldw   R34,[R72+f0]     R34 = EVP;                        # 170 - EVP - EGR valve position reading in A/D counts.
520f: 6b,72,a8,34         sb2w  R34,[R72+a8]     R34 -= EOFF;                      # 128 - EOFF - The EGR valve reading when the valve is fully closed in A/D counts
5213: db,02               jgeu  5217             if (R34 < 0)  {
5215: 01,34               clrw  R34              R34 = 0; }                        # clip to 0
5217: 45,5c,01,fa,32      ad3w  R32,Rfa,15c      R32 = FN219A;                     # Table - EGR mass flow as a function of EGR valve position (EVP-EOFF).
521c: 08,08,34            shrw  R34,8            R34 /= 100;                       # scale down to 1 byte
521f: ef,ea,e3            call  360c             UUWordLu();
5222: 7f,74,80,38         ml2b  R38,[R74+80]     R38 *= BP;                        # BP - barometric pressure
5226: 9d,ef,38            divb  R38,ef           R38 /= ef;
5229: d5,03               jnv   522e             if (OVF == 1)  {
522b: b1,ff,38            ldb   R38,ff           R38 = ff; } } }                   # Substitute value if division overflows
#
522e: c7,74,0a,38         stb   R38,[R74+a]      EM = R38;                         # Save new EM
#
# Calculate EGRACT
#
5232: b3,74,0a,34         ldb   R34,[R74+a]      R34 = EM;                         # 
5236: 7d,c8,34            ml2b  R34,c8           R34 *= c8;
5239: 01,36               clrw  R36              R36 = 0;
523b: 0d,04,34            shldw R34,4            R37:R34 *= 10;
523e: 8c,a4,34            divw  R34,Ra4          R35:R34 = R37:R34 / AMPEM;
5241: dd,06               jv    5249             if (OVF == 1) goto 5249;
5243: 89,ff,00,34         cmpw  R34,ff           
5247: d1,03               jleu  524c             if ((uns) R34 > ff )  {
#
5249: b1,ff,34            ldb   R34,ff           R34 = ff; }                       # clip
# 
524c: af,72,ee,32         ldzbw R32,[R72+ee]     R32 = (uns)EGRACT;                # old AD sensor value - EGRACT - Actual EGR percent = 100*EM/AMPEM.
5250: c7,72,ee,34         stb   R34,[R72+ee]     EGRACT = R34;                     # save new over old value 16E - EGRACT - Actual EGR percent = 100*EM/AMPEM.
5254: 11,35               clrb  R35              R35 = 0;
5256: 36,e6,09            jnb   B6,Re6,5262      if (Pfehp_flg == 1)  {            # PFEHP FLG - sonic h/w present from calibration data
# Save rolling average instead for PFE (not present on A9L)
5259: ef,02,e4            call  365e             Urolav_1Arg(97ee);
525c: 46,d0               #args  
525e: c7,72,ee,3e         stb   R3e,[R72+ee]     EGRACT = R3e; }                   # filtered sensor output - EGRACT - Actual EGR percent = 100*EM/AMPEM.
#
# Jump here from 5152, 5256
5262: 2e,9f               scall 5103             Sub30();
5264: 71,7f,24            an2b  R24,7f           TSEGRE_On = 0;
5267: b3,fa,2a,38         ldb   R38,[Rfa+2a]     R38 = EGRMPT;                     # EGRMPT - Calibration time delay to ramp EGR in, secs.
526b: 9b,fe,05,ad         cmpb  Rad,[Rfe+5]                                        # 9E5F - CTLOW - Temperature of Engine Coolant at Cold Startup, deg F.
526f: d2,0f               jgt   5280             if (TCSTRT > CTLOW) goto 5280;
5271: 30,28,10            jnb   B0,R28,5284      if (EGREN == 1)  {
5274: 91,80,24            orb   R24,80           TSEGRE_On = 1;                    # set TSEGRE FLG -
5277: 9b,74,e6,38         cmpb  R38,[R74+e6]                                       # 264 timer TSEGRE - Accumulated time EGR is enabled.
527b: d9,07               jgtu  5284             if ((uns) R38 <= TSEGRE)  {
527d: 71,7f,24            an2b  R24,7f           TSEGRE_On = 0;                    # clr TSEGRE FLG -
#
5280: c7,74,e6,38         stb   R38,[R74+e6]     TSEGRE = R38; } }                 # set 264 timer TSEGRE
#
5284: 3e,e6,25            jb    B6,Re6,52ac      if (Pfehp_flg == 0)  {            # PFEHP FLG - sonic h/w present from calibration data
5287: 38,28,22            jb    B0,R28,52ac      if (EGREN == 0)  {                # EGREN - Flag which indicates EGR enabled
528a: c7,72,ef,00         stb   R0,[R72+ef]      EGRATE = 0;                       # 16F - EGRATE - Desired EGR rate in percent
528e: c3,74,90,00         stw   R0,[R74+90]      DELOPT = 0;                       # 20E - DELOPT - Filtered desired EGR valve position.
5292: f0                  ret                    return;

  Sub31:
5293: 89,00,e7,32         cmpw  R32,e700         
5297: d6,05               jge   529e             if (R32 < e700)  {
5299: a1,00,9c,32         ldw   R32,9c00         R32 = 9c00;
529d: f0                  ret                    return; }

529e: 89,80,0c,32         cmpw  R32,c80          
52a2: da,04               jle   52a8             if ((uns) R32 < c80)  {
52a4: a1,80,0c,32         ldw   R32,c80          R32 = c80; }
52a8: 09,02,32            shlw  R32,2            R32 *= 4;
52ab: f0                  ret                    return; } }

# Continued from 5284, 5287
52ac: 45,de,00,f0,32      ad3w  R32,Rf0,de       R32 = FN070;                      # Table 8CDE Engine speed N normalizing function
52b1: a0,ae,34            ldw   R34,Rae          R34 = N;
52b4: ef,55,e3            call  360c             UUWordLu();
52b7: a0,38,a6            ldw   Ra6,R38          NRMCES = R38;
52ba: 45,fa,00,f0,32      ad3w  R32,Rf0,fa       R32 = FN021;                      # Input = LOAD and Output = Normalized load
52bf: a3,74,de,34         ldw   R34,[R74+de]     R34 = LOAD;                       # engine load (VE)
52c3: ef,46,e3            call  360c             UUWordLu();
52c6: a0,38,a8            ldw   Ra8,R38          NRMRLD = R38;
52c9: a0,a6,30            ldw   R30,Ra6          R30 = NRMCES;
52cc: a0,a8,32            ldw   R32,Ra8          R32 = NRMRLD;
52cf: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
52d2: 45,06,02,fa,38      ad3w  R38,Rfa,206      R38 = FN908A;                     # Sea level EGR Table.
52d7: ef,10,e4            call  36ea             UTabLookUp();
52da: ac,3b,3c            ldzbw R3c,R3b          R3c = (uns)R3b;
52dd: af,74,83,38         ldzbw R38,[R74+83]     R38 = (uns)Mult_bp212A;           # 201 - MULT BP212A - ?
52e1: ef,66,05            call  584a             Scale_R3c();
52e4: a0,3c,42            ldw   R42,R3c          R42 = R3c;
52e7: a0,a6,30            ldw   R30,Ra6          R30 = NRMCES;
52ea: a0,a8,32            ldw   R32,Ra8          R32 = NRMRLD;
52ed: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
52f0: 45,56,02,fa,38      ad3w  R38,Rfa,256      R38 = FN908B;                     # Altitude EGR Table. *** Z_EGRINT patches this to FN908A ***
52f5: ef,f2,e3            call  36ea             UTabLookUp();
52f8: ac,3b,3c            ldzbw R3c,R3b          R3c = (uns)R3b;
52fb: 45,50,01,fa,32      ad3w  R32,Rfa,150      R32 = FN217A;                     # EGRALT multiplier as a function of Barometric Pressure BP.
5300: b3,74,80,34         ldb   R34,[R74+80]     R34 = BP;                         # BP - barometric pressure
5304: ef,b0,e2            call  35b7             UUbyteLu();
5307: 11,39               clrb  R39              R39 = 0;
5309: ef,3e,05            call  584a             Scale_R3c();
530c: 64,42,3c            ad2w  R3c,R42          R3c += R42;
530f: 45,3a,01,fa,32      ad3w  R32,Rfa,13a      R32 = FN211;                      # EGR Multiplier as a function of ECT.
5314: b0,b0,34            ldb   R34,Rb0          R34 = ECT;
5317: ef,97,e2            call  35b1             SSByteLU();
531a: b0,38,3a            ldb   R3a,R38          R3a = R38;
531d: 45,74,01,fa,32      ad3w  R32,Rfa,174      R32 = FN220;                      # Multiplier as a function of Air Charge Temperature ACT.
5322: b0,b1,34            ldb   R34,Rb1          R34 = ACT;                        # RB1 = ACT (ACT = RB1 * 4)
5325: ef,84,e2            call  35ac             subyteLU();
5328: 7c,3a,38            ml2b  R38,R3a          R38 *= R3a;
532b: 6c,3c,38            ml2w  R38,R3c          R3b:R38 = R39:R37 * R3d:R3c;
532e: 0d,03,38            shldw R38,3            R3b:R38 *= 8;
5331: 11,38               clrb  R38              R38 = 0;
5333: b3,fa,25,39         ldb   R39,[Rfa+25]     R39 = X;                          # EGR Table multiplier.
5337: 6c,3a,38            ml2w  R38,R3a          R3b:R38 = R39:R38 * R3b:R3a;
533a: b3,74,e6,39         ldb   R39,[R74+e6]     R39 = TSEGRE;                     # Accumulated time EGR is enabled (sec)
533e: 11,38               clrb  R38              R38 = 0;
5340: 9f,fa,2a,38         divb  R38,[Rfa+2a]     R38 /= EGRMPT;                    # Calibration time delay to ramp EGR in, sec.
5344: dd,08               jv    534e             if (OVF == 0)  {
5346: 11,39               clrb  R39              R39 = 0;
5348: 6c,3a,38            ml2w  R38,R3a          R3b:R38 = R39:R38 * R3b:R3a;
534b: 0d,08,38            shldw R38,8            R3b:R38 *= 100; }
534e: 30,ec,4e            jnb   B0,Rec,539f      if (MFAFLG == 1)  {               # Managed Fuel Air State flag, set to 1 if MFA is being used.
5351: a0,3a,3c            ldw   R3c,R3a          R3c = R3a;
5354: 45,46,01,f0,32      ad3w  R32,Rf0,146      R32 = FN083;                      # generates Table entry point. Input = N and Output = Normalized N.
5359: a0,ae,34            ldw   R34,Rae          R34 = N;
535c: ef,ad,e2            call  360c             UUWordLu();
535f: a0,38,30            ldw   R30,R38          R30 = R38;
5362: 45,32,01,f0,32      ad3w  R32,Rf0,132      R32 = FN082;                      # generates Table entry point. Input = LOAD and Output = Normalized Load.
5367: a3,74,de,34         ldw   R34,[R74+de]     R34 = LOAD;                       # engine load (VE)
536b: ef,9e,e2            call  360c             UUWordLu();
536e: a0,38,32            ldw   R32,R38          R32 = R38;
5371: ad,04,34            ldzbw R34,4            R34 = (uns)4;
5374: 45,a6,02,fa,38      ad3w  R38,Rfa,2a6      R38 = FN1223;                     # Managed fuel Air EGR Table. X -input = FN083 - Normalized Engine Speed, RPM Y -inp
                                                                                   ut = FN082 - Normalized load. Output = Multiplier.
5379: ef,6e,e3            call  36ea             UTabLookUp();
537c: b3,74,82,38         ldb   R38,[R74+82]     R38 = Mult_bp311;
5380: 7c,3b,38            ml2b  R38,R3b          R38 *= R3b;
5383: 5f,74,f4,39,38      ml3b  R38,R39,[R74+f4] R38 = R39 * MFAMUL;
5388: 03,38               negw  R38              R38 = -R38;
538a: 65,00,20,38         ad2w  R38,2000         R38 += 2000;
538e: 37,39,02            jnb   B7,R39,5393      if (B7_R39 == 1)  {
5391: 01,38               clrw  R38              R38 = 0; }
5393: 6c,3c,38            ml2w  R38,R3c          R3b:R38 = R39:R38 * R3d:R3c;
5396: 0d,03,38            shldw R38,3            R3b:R38 *= 8;
5399: d3,04               jnc   539f             if ((uns) R38 >= 0)  {
539b: a1,ff,ff,3a         ldw   R3a,ffff         R3a = ffff; } }
539f: 77,fa,24,3a         ad2b  R3a,[Rfa+24]     R3a += KPEI;
53a3: b4,00,3b            adcb  R3b,R0           R3b += CY;
53a6: 98,00,3b            cmpb  R3b,R0           
53a9: df,03               je    53ae             if (R3b != 0)  {
53ab: b1,ff,3a            ldb   R3a,ff           R3a = ff; }
53ae: c7,72,ef,3a         stb   R3a,[R72+ef]     EGRATE = R3a;
53b2: 3e,e6,63            jb    B6,Re6,5418      if (Pfehp_flg == 0)  {
53b5: 98,00,3a            cmpb  R3a,R0           
53b8: d7,06               jne   53c0             if (R3a == 0)  {
53ba: c3,74,90,00         stw   R0,[R74+90]      DELOPT = 0;
53be: 20,57               sjmp  5417             return; }

53c0: 5d,a4,3a,38         ml3b  R38,R3a,a4       R38 = R3a * a4;
53c4: 6c,a4,38            ml2w  R38,Ra4          R3b:R38 = R39:R38 * AMPEM;
53c7: 0c,05,38            shrdw R38,5            R3b:R38 /= 20;
53ca: a0,3a,38            ldw   R38,R3a          R38 = R3a;
53cd: 6d,bc,03,38         ml2w  R38,3bc          R3b:R38 = R39:R38 * Sparek1;
53d1: af,74,80,34         ldzbw R34,[R74+80]     R34 = (uns)BP;                    # BP - barometric pressure
53d5: 8c,34,38            divw  R38,R34          R39:R38 = R3b:R38 / R35:R34;
53d8: dd,15               jv    53ef             if (OVF == 1) goto 53ef;
53da: 45,7e,01,fa,32      ad3w  R32,Rfa,17e      R32 = FN221;                      # EGR position vs. desired flow
53df: a0,38,34            ldw   R34,R38          R34 = R38;
53e2: ef,27,e2            call  360c             UUWordLu();
53e5: 09,08,38            shlw  R38,8            R38 *= 100;
53e8: 47,72,a8,38,34      ad3w  R34,R38,[R72+a8] R34 = R38 + EOFF;
53ed: d3,03               jnc   53f2             if ((uns) R34 >= 0)  {
53ef: bd,c0,34            ldsbw R34,c0           R34 = (int)c0; }
53f2: a3,72,a8,42         ldw   R42,[R72+a8]     R42 = EOFF;
53f6: 8b,74,90,42         cmpw  R42,[R74+90]     
53fa: d3,04               jltu  5400             if ((uns) R42 >= DELOPT)  {
53fc: c3,74,90,42         stw   R42,[R74+90]     DELOPT = R42; }
5400: ef,51,e2            call  3654             Urolav_3Arg(DELOPT,34,TCDLOP);       # FILTER old, new, factor
5403: 0e,02,34,00,40,d0   #args  
5409: 89,80,e6,3e         cmpw  R3e,e680                                           # check result
540d: d1,04               jleu  5413             if ((uns) R3e > e680 )  {
540f: a1,80,e6,3e         ldw   R3e,e680         R3e = e680; }                     # clip value to 90% max
5413: c3,74,90,3e         stw   R3e,[R74+90]     DELOPT = R3e;                     # save filtered output
5417: f0                  ret                    return; }

5418: 7d,a4,3a            ml2b  R3a,a4           R3a *= a4;
541b: a0,a4,38            ldw   R38,Ra4          R38 = AMPEM;
541e: 6c,3a,38            ml2w  R38,R3a          R3b:R38 = R39:R38 * R3b:R3a;
5421: c0,3c,3a            stw   R3a,R3c          R3c = R3a;
5424: 99,07,3b            cmpb  R3b,7            
5427: d1,05               jleu  542e             if ((uns) R3b > 7 )  {
5429: bd,ff,3a            ldsbw R3a,ff           R3a = 0xffff;
542c: 20,03               sjmp  5431             goto 5431; }
#
542e: 0d,05,38            shldw R38,5            R3b:R38 *= 20;
5431: c7,72,fe,3b         stb   R3b,[R72+fe]     DESEM = R3b;
5435: a3,fa,36,32         ldw   R32,[Rfa+36]     R32 = MINDES;
5439: 67,fa,38,32         ad2w  R32,[Rfa+38]     R32 += DESHYS;
543d: 88,32,3c            cmpw  R3c,R32          
5440: d3,03               jltu  5445             if ((uns) R3c >= R32)  {
5442: 91,10,a1            orb   Ra1,10           Egronflg = 1; }
5445: 8b,fa,36,3c         cmpw  R3c,[Rfa+36]     
5449: db,03               jgeu  544e             if (R3c > MINDES)  {
544b: 71,ef,a1            an2b  Ra1,ef           Egronflg = 0; }
544e: 38,28,02            jb    B0,R28,5453      if (EGREN == 1) goto 5453;
5451: 20,69               sjmp  54bc             goto 54bc;

5453: 3c,a1,02            jb    B4,Ra1,5458      if (Egronflg == 1) goto 5458;
5456: 20,70               sjmp  54c8             goto 54c8;

5458: a0,3a,34            ldw   R34,R3a          R34 = R3a;
545b: 45,de,01,fa,32      ad3w  R32,Rfa,1de      R32 = 9986;                       # Table 9986
5460: ef,a9,e1            call  360c             UUWordLu();
5463: 6d,00,ef,38         ml2w  R38,ef00         R3b:R38 = R39:R38 * 0xef00;
5467: b3,74,80,37         ldb   R37,[R74+80]     R37 = BP;                         # BP - barometric pressure
546b: 11,36               clrb  R36              R36 = 0;
546d: 8c,36,38            divw  R38,R36          R39:R38 = R3b:R38 / R37:R36;
5470: d5,03               jnv   5475             if (OVF == 1)  {
5472: bd,ff,38            ldsbw R38,ff           R38 = 0xffff; }
5475: 08,02,38            shrw  R38,2            R38 /= 4;
5478: 08,02,40            shrw  R40,2            R40 /= 4;
547b: 48,38,40,32         sb3w  R32,R40,R38      R32 = R40 - R38;
547f: 2e,12               scall 5293             Sub31();
5481: c0,34,32            stw   R32,R34          R34 = R32;
5484: a3,72,f4,32         ldw   R32,[R72+f4]     R32 = DESDP;                      # orig value
5488: a3,fa,42,36         ldw   R36,[Rfa+42]     R36 = TCDP;
548c: ef,db,e1            call  366a             Rolav();
548f: c3,72,f4,3e         stw   R3e,[R72+f4]     DESDP = R3e;                      # filtered value
5493: a3,fa,2e,38         ldw   R38,[Rfa+2e]     R38 = IXFRPR;
5497: fe,6c,3e,38         sml2w R38,R3e          R3b:R38 = R39:R38 * R3f:R3e;
549b: 0d,02,38            shldw R38,2            R3b:R38 *= 4;
549e: a3,01,ee,07,36      ldw   R36,[R0+7ee]     R36 = EPTZER;                    # filtered EVP saved in KAM
54a3: 08,01,36            shrw  R36,1            R36 /= 2;
54a6: 64,36,3a            ad2w  R3a,R36          R3a += R36;
54a9: d5,05               jnv   54b0             if (OVF == 1)  {
54ab: bd,ff,3a            ldsbw R3a,ff           R3a = 0xffff;
54ae: 20,07               sjmp  54b7             goto 54b7; }

54b0: d6,02               jge   54b4             if (R3a < 0)  {
54b2: 01,3a               clrw  R3a              R3a = 0; }
54b4: 09,01,3a            shlw  R3a,1            R3a *= 2;
54b7: c3,72,fc,3a         stw   R3a,[R72+fc]     CONPR = R3a;
54bb: f0                  ret                    return;

54bc: c7,74,0a,00         stb   R0,[R74+a]       EM = 0;                           # 288 EM - EGR Mass Flow
54c0: c7,72,ee,00         stb   R0,[R72+ee]      EGRACT = 0;
54c4: c7,72,ef,00         stb   R0,[R72+ef]      EGRATE = 0;
54c8: c7,72,fe,00         stb   R0,[R72+fe]      DESEM = 0;
54cc: a3,72,84,30         ldw   R30,[R72+84]     R30 = EPTBAR;
54d0: c3,72,fc,30         stw   R30,[R72+fc]     CONPR = R30;                      # 17C - CONPR
54d4: c3,72,f4,40         stw   R40,[R72+f4]     DESDP = R40;                      # 174 - DESDP
54d8: f0                  ret                    return;


#################################################################
# Tasklist Routine at 2151, routine offset 32
# EGR actuator logic
#################################################################

  Calc_EGR:
54d9: 3e,e6,63            jb    B6,Re6,553f      if (Pfehp_flg == 0)  {            # PFE HP flag
#
# Sonic EGR Valve Output Control logic
# GUFB p. 8-12
#
54dc: 8b,74,90,00         cmpw  R0,[R74+90]                                        # 20E - DELOPT
54e0: db,52               jgeu  5534             if (0 < DELOPT)  {
54e2: a3,fa,28,30         ldw   R30,[Rfa+28]     R30 = EGRDED;                     # 
54e6: 67,72,a8,30         ad2w  R30,[R72+a8]     R30 += EOFF;                      # 128 - EOFF
54ea: d3,03               jnc   54ef             if (unsigned overflow)  {
54ec: bd,c0,30            ldsbw R30,c0           R30 = (int)c0; }                  # clip on overflow
#
54ef: 8b,72,f0,30         cmpw  R30,[R72+f0]                                       # 170 - EVP
54f3: d3,0c               jltu  5501             if ((uns) R30 < EVP) goto 5501;
54f5: 3f,29,0c            jb    B7,R29,5504      if (EGRFLG == 0)  {               # jmp if EGRFLG
54f8: a3,fa,26,d2         ldw   Rd2,[Rfa+26]     Egrdc_w = DCOFF;               # 97CE - DCOFF
54fc: 91,80,29            orb   R29,80           EGRFLG = 1;
54ff: 20,03               sjmp  5504             goto 5504;
#
# Desired EVP < actual
5501: 71,7f,29            an2b  R29,7f           EGRFLG = 0; }
#
5504: a3,74,90,34         ldw   R34,[R74+90]     R34 = DELOPT;
5508: 08,01,34            shrw  R34,1            R34 /= 2;
550b: a3,72,f0,32         ldw   R32,[R72+f0]     R32 = EVP;
550f: 08,01,32            shrw  R32,1            R32 /= 2;
5512: 68,32,34            sb2w  R34,R32          R34 -= R32;
5515: c3,72,f2,34         stw   R34,[R72+f2]     EGRERR = R34;
5519: 45,9a,01,fa,32      ad3w  R32,Rfa,19a      R32 = FN239;                      # EGR Duty Cycle Adder vs. EGRERR
551e: ef,e5,e0            call  3606             SSWordLU();
5521: 64,d2,38            ad2w  R38,Rd2          R38 += Egrdc_w;                   # Add to EGRDC (as word)
5524: dd,08               jv    552e             if (OVF == 1) goto 552e;          # Clip to 7333 (90%) on overflow
5526: da,0c               jle   5534             if ((uns) R38 < 0)  {             # Clip to 0
5528: 89,33,73,38         cmpw  R38,7333         
552c: d1,04               jleu  5532             if ((uns) R38 > 7333 )  {         # Clip to 7333 (90%) max
#
552e: a1,33,73,38         ldw   R38,7333         R38 = 7333; }
#
5532: 20,05               sjmp  5539             goto 5539; } }
#
# DELOPT == 0 or EGRDC == 0
# Jump here from 54e0, 5526
5534: 01,38               clrw  R38              R38 = 0;
5536: 71,7f,29            an2b  R29,7f           EGRFLG = 0;                       # clr EGRFLG
#
5539: a0,38,d2            ldw   Rd2,R38          Egrdc_w = R38;
553c: e7,48,00            jump  5587             goto Update_EGR2; }
#
# Pfehp_flg == 1 - Pressure Feedback EGR logic
#
553f: 9b,72,fe,00         cmpb  R0,[R72+fe]      
5543: df,3a               je    557f             if (0 == DESEM) goto 557f;
5545: 3f,29,07            jb    B7,R29,554f      if (EGRFLG == 0)  {
5548: a3,fa,26,d2         ldw   Rd2,[Rfa+26]     Egrdc_w = DCOFF;
554c: 91,80,29            orb   R29,80           EGRFLG = 1; }
554f: a3,72,fc,30         ldw   R30,[R72+fc]     R30 = CONPR;
5553: 08,01,30            shrw  R30,1            R30 /= 2;
5556: a3,72,84,34         ldw   R34,[R72+84]     R34 = EPTBAR;
555a: 08,01,34            shrw  R34,1            R34 /= 2;
555d: 68,30,34            sb2w  R34,R30          R34 -= R30;
5560: c3,72,fa,34         stw   R34,[R72+fa]     PRESER = R34;
5564: 45,9a,01,fa,32      ad3w  R32,Rfa,19a      R32 = 9942;
5569: ef,9a,e0            call  3606             SSWordLU();
556c: 64,d2,38            ad2w  R38,Rd2          R38 += Egrdc_w;
556f: dd,08               jv    5579             if (OVF == 1) goto 5579;
5571: da,0f               jle   5582             if (R38 <= 0) goto 5582;
5573: 89,33,73,38         cmpw  R38,7333         
5577: d1,0b               jleu  5584             if ((uns) R38 > 7333 )  {
5579: a1,33,73,38         ldw   R38,7333         R38 = 7333;
557d: 20,05               sjmp  5584             goto 5584;

557f: 71,7f,29            an2b  R29,7f           EGRFLG = 0;
5582: 01,38               clrw  R38              R38 = 0; }
5584: c0,d2,38            stw   R38,Rd2          Egrdc_w = R38;

#################################################################
# Tasklist Routine at 2151, routine offset 6E
# Fall thru ?
# Update EGR stuff
#################################################################
#
# EVR Control Algorithm - Common
# GUFB p. 8-21
#
  Update_EGR2:
5587: 98,00,d3            cmpb  Rd3,R0           
558a: d7,0f               jne   559b             if (EGRDC == 0)  {
558c: c7,74,a3,00         stb   R0,[R74+a3]      EGRCNT = 0;
5590: c7,74,a4,00         stb   R0,[R74+a4]      EGRPER = 0;
5594: f0                  ret                    return;
#
# Convert EGRDC to EGRCNT and EGRPER using this table
#
5595: 0a,17,2c,40,58,6e   byte  0a,17,2c,40,58,6e
#
559b: ad,06,30            ldzbw R30,6            R30 = (uns)6;                      # initialize table index
# Loop back to here
559e: 9b,31,94,55,d3      cmpb  EGRDC,[R30+5594]   
55a3: d9,03               jgtu  55a8             if ((uns) EGRDC > [5594+R30] ) goto 55a8;
55a5: e0,30,f6            djnz  R30,559e         R30--;
                                                 if (R30 != 0) goto 559e;
# R30 = count
55a8: 09,0b,30            shlw  R30,b            R30 *= 800;
55ab: c7,74,a3,31         stb   R31,[R74+a3]     EGRCNT = R31;
55af: 11,30               clrb  R30              R30 = 0;                           # clear low bits of EGRCNT (redundant with 55A8?)
55b1: 9c,d3,30            divb  R30,Rd3          R30 = (EGRCNT * 100) / EGRDC;
55b4: dd,05               jv    55bb             if (OVF == 1) goto 55bb;           # jump if EGRDC was 0 or overflow
55b6: 99,c0,30            cmpb  R30,c0           
55b9: d1,03               jleu  55be             if ((uns) R30 > c0 )  {
#
55bb: b1,c0,30            ldb   R30,c0           R30 = c0; }                        # clip EGRPER to 12
#
55be: c7,74,a4,30         stb   R30,[R74+a4]     EGRPER = R30;
55c2: f0                  ret                    return;

#################################################################
# Background Tasklist Routine at 2151, routine offset 34
# Update spark advance
#################################################################

  Update_advance:
55c3: 3f,a1,03            jb    B7,Ra1,55c9      if (CRKFLG == 1) goto 55c9;
55c6: 32,a1,05            jnb   B2,Ra1,55ce      if (UNDSP == 1)  {
#
55c9: b1,28,c2            ldb   Rc2,28           SAF = 28;                         # Z_CRKSPK in GUFB.xls (degrees BTDC x 4)
55cc: 22,43               sjmp  5811             goto 5811; }
#
55ce: 3a,28,02            jb    B2,R28,55d3      if (Newsa == 1) goto 55d3;        # Jump if new spark required
55d1: 22,3e               sjmp  5811             goto 5811;                        # Otherwise skip all this stuff
#
# Pre-calculate RPM and LOAD table indices
#
55d3: 45,de,00,f0,32      ad3w  R32,Rf0,de       R32 = FN070;                      # Spark RPM scaling
55d8: a0,ae,34            ldw   R34,Rae          R34 = N;
55db: ef,2e,e0            call  360c             UUWordLu();
55de: a0,38,a6            ldw   Ra6,R38          NRMCES = R38;
55e1: 45,fa,00,f0,32      ad3w  R32,Rf0,fa       R32 = FN021;                      # Table 8CFA load scaling
55e6: a3,74,de,34         ldw   R34,[R74+de]     R34 = LOAD;                       # engine load (VE)
55ea: ef,1f,e0            call  360c             UUWordLu();
55ed: a0,38,a8            ldw   Ra8,R38          NRMRLD = R38;
#
# Torque Truncation Spark logic - calculate 'C'
# GUFB pp. 7-13, 7-14
# Only applies to AOD, AXOD automatic transmissions
#
55f0: 01,18               clrw  R18              R18 = 0;
55f2: b3,74,3f,34         ldb   R34,[R74+3f]     R34 = VSBAR_H;                    # 2BD - vehicle speed filtered(1) (MPH) 2BC is 8.8 format
55f6: 7f,f8,18,34         ml2b  R34,[Rf8+18]     R34 *= TTNOV;
55fa: a0,ae,36            ldw   R36,Rae          R36 = N;
55fd: 08,03,36            shrw  R36,3            R36 /= 8;
5600: 88,36,34            cmpw  R34,R36          
5603: db,14               jgeu  5619             if (R34 > R36)  {
5605: a0,a6,30            ldw   R30,Ra6          R30 = NRMCES;
5608: a0,a8,32            ldw   R32,Ra8          R32 = NRMRLD;
560b: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
560e: 45,90,02,f8,38      ad3w  R38,Rf8,290      R38 = FN1119;                     # Torque Reduction Table (auto trans protection)
5613: ef,d4,e0            call  36ea             UTabLookUp();
5616: ac,3b,18            ldzbw R18,R3b          R18 = (uns)R3b; }
#
# R18 (word) = "C" retard for torque truncation (auto trans)
#
5619: 3f,d0,02            jb    B7,Rd0,561e      if (Cl_thrtl == 1) goto 561e;
561c: 20,83               sjmp  56a1             goto 56a1;                        # Jump if not closed throttle
#
# Closed throttle spark logic
# GUFB p. 7-11
#
561e: 45,90,00,f8,32      ad3w  R32,Rf8,90       R32 = FN112;                      # Closed Throttle Spark advance (added, ECT->adv)
5623: b0,b0,34            ldb   R34,Rb0          R34 = ECT;
5626: ef,88,df            call  35b1             SSByteLU();
5629: bc,38,42            ldsbw R42,R38          R42 = (int)R38;
562c: 45,7c,00,f8,32      ad3w  R32,Rf8,7c       R32 = FN111;                      # Closed Throttle Base spark advance (RPM->adv)
5631: a0,ae,34            ldw   R34,Rae          R34 = N;
5634: ef,cf,df            call  3606             SSWordLU();
5637: 64,38,42            ad2w  R42,R38          R42 += R38;
563a: 67,f8,02,42         ad2w  R42,[Rf8+2]      R42 += KCS1;                      # Constant spark adder closed throttle
#
# Hi Cam (cold start) spark determination
#
563e: a3,f8,06,38         ldw   R38,[Rf8+6]      R38 = HCSD;
5642: 88,38,ae            cmpw  Rae,R38          
5645: d1,03               jleu  564a             if ((uns) N > R38 )  {
5647: 91,10,ed            orb   Red,10           Hcsdq = 1; }
#
564a: 6b,f8,08,38         sb2w  R38,[Rf8+8]      R38 -= HCSDH;
564e: 88,38,ae            cmpw  Rae,R38          
5651: db,03               jgeu  5656             if (N > R38)  {
5653: 71,ef,ed            an2b  Red,ef           Hcsdq = 0; }
#
5656: 34,ed,23            jnb   B4,Red,567c      if (Hcsdq == 1)  {                # Jump if not hi cam
5659: 45,38,01,f8,32      ad3w  R32,Rf8,138      R32 = FN400;                      # Table FN400 Time since startup kicker time delay, sec.
565e: b0,ad,34            ldb   R34,Rad          R34 = TCSTRT;                     # Input is TCSTRT, max repetition 6.
5661: ef,48,df            call  35ac             subyteLU();
5664: 98,38,c8            cmpb  Rc8,R38          
5667: db,13               jgeu  567c             if (ATMR1 < R38)  {               # Jump if not Hi Cam
#
# Hi Cam spark calculation
#
5669: 45,9e,00,f8,32      ad3w  R32,Rf8,9e       R32 = FN115;                      # Hi Cam CT Spark Subtracter
566e: b3,74,80,34         ldb   R34,[R74+80]     R34 = BP;                         # BP - barometric pressure
5672: ef,3f,df            call  35b4             USByteLU();
5675: 16,38               sexb  R38              R38 = (int)R38;
5677: 68,38,42            sb2w  R42,R38          R42 -= R38;
567a: 20,16               sjmp  5692             goto 5692; } }
#
567c: 32,26,13            jnb   B2,R26,5692      if (NFLG == 1)  {
#
# Neutral Idle spark calculation
#
567f: 67,f8,12,42         ad2w  R42,[Rf8+12]     R42 += NSADD;                     # Neutral Idle constant adder
5683: b3,72,c4,34         ldb   R34,[R72+c4]     R34 = CTNTMR;
5687: 45,1e,01,f8,32      ad3w  R32,Rf8,11e      R32 = FN180;                      # Neutral Idle Spark subtractor vs time in neutral, deg.
568c: ef,28,df            call  35b7             UUbyteLu();
568f: 68,38,42            sb2w  R42,R38          R42 -= R38; }
# 
# R18 (word) = "C" (torque truncation retard for auto trans)
# 
5692: 48,18,42,3c         sb3w  R3c,R42,R18      R3c = R42 - R18;
5696: af,72,d6,38         ldzbw R38,[R72+d6]     R38 = (uns)SPKMUL;                # Scale by SPKMUL (see closed loop idle control logic)
569a: 29,ae               scall 584a             Scale_R3c();
569c: a0,3c,42            ldw   R42,R3c          R42 = R3c;
569f: 21,6a               sjmp  580b             goto 580b;
#
#
56a1: 30,d0,48            jnb   B0,Rd0,56ec      if (B0_APT == 1)  {               # check WOT flag
                                                                                   # *** Z_WSPKSW "disable" in GUFB.xls patches this instruction to ***
                                                                                   # 20, 49    sjmp 56ec
#
# Wide Open Throttle spark calculation
#
56a4: 45,d4,00,f8,32      ad3w  R32,Rf8,d4       R32 = FN131;                      # WOT spark advance vs RPM
56a9: a0,ae,34            ldw   R34,Rae          R34 = N;
56ac: ef,5d,df            call  360c             UUWordLu();
56af: a0,38,42            ldw   R42,R38          R42 = R38;
56b2: 45,f8,00,f8,32      ad3w  R32,Rf8,f8       R32 = FN133;                      # WOT Spark Advance vs. BP
56b7: b3,74,80,34         ldb   R34,[R74+80]     R34 = BP;                         # BP - barometric pressure
56bb: ef,f6,de            call  35b4             USByteLU();
56be: 16,38               sexb  R38              R38 = (int)R38;
56c0: 64,38,42            ad2w  R42,R38          R42 += R38;
56c3: 45,02,01,f8,32      ad3w  R32,Rf8,102      R32 = FN134;                      # WOT Spark Advance vs ECT
56c8: b0,b0,34            ldb   R34,Rb0          R34 = ECT;                        # INPUT: Engine Coolant Temp
56cb: ef,e3,de            call  35b1             SSByteLU();
56ce: 16,38               sexb  R38              R38 = (int)R38;                   # OUTPUT: ECT advance increment
56d0: 64,38,42            ad2w  R42,R38          R42 += R38;
56d3: 45,10,01,f8,32      ad3w  R32,Rf8,110      R32 = FN135;                      # WOT Spark Advance vs ACT
56d8: b0,b1,34            ldb   R34,Rb1          R34 = ACT;                        # RB1 = ACT (ACT = RB1 * 4)
56db: ef,d3,de            call  35b1             SSByteLU();
56de: 16,38               sexb  R38              R38 = (int)R38;
56e0: 64,38,42            ad2w  R42,R38          R42 += R38;
56e3: 67,f8,0a,42         ad2w  R42,[Rf8+a]      R42 += KWS1;                      # Spark Adder WOT
56e7: 68,18,42            sb2w  R42,R18          R42 -= R18;                       #  - "C" (A/T torque truncation retard)
56ea: 21,0d               sjmp  57f9             goto 57f9; }                      # done
#
# Part throttle spark calculation
#
56ec: a0,a6,30            ldw   R30,Ra6          R30 = NRMCES;
56ef: a0,a8,32            ldw   R32,Ra8          R32 = NRMRLD;
56f2: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
56f5: 45,94,01,f8,38      ad3w  R38,Rf8,194      R38 = FN904A;                     # Sea Level spark (RPM vs LOAD)
56fa: ef,ed,df            call  36ea             UTabLookUp();
56fd: ac,3b,3c            ldzbw R3c,R3b          R3c = (uns)R3b;
5700: af,74,83,38         ldzbw R38,[R74+83]     R38 = (uns)Mult_bp212A;
5704: 29,44               scall 584a             Scale_R3c();
5706: a0,3c,42            ldw   R42,R3c          R42 = R3c;
5709: a0,a6,30            ldw   R30,Ra6          R30 = NRMCES;
570c: a0,a8,32            ldw   R32,Ra8          R32 = NRMRLD;
570f: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
5712: 45,e4,01,f8,38      ad3w  R38,Rf8,1e4      R38 = FN905A;                     # Altitude spark timing Table (Deg BTDC)(RPM vs LOAD)
                                                                                   # *** Z_SPKINT patches this to point to FN904A
5717: ef,d0,df            call  36ea             UTabLookUp();
571a: ac,3b,3c            ldzbw R3c,R3b          R3c = (uns)R3b;
571d: 45,c8,00,f8,32      ad3w  R32,Rf8,c8       R32 = FN129A;                     # LOMALT Table multiplier as a function of BP.
                                                                                   # 0 at sea level, 1.0 at high altitude
5722: b3,74,80,34         ldb   R34,[R74+80]     R34 = BP;                         # BP - barometric pressure
5726: ef,8e,de            call  35b7             UUbyteLu();
5729: 11,39               clrb  R39              R39 = 0;
572b: 29,1d               scall 584a             Scale_R3c();
572d: 64,3c,42            ad2w  R42,R3c          R42 += R3c;
5730: a0,a6,30            ldw   R30,Ra6          R30 = NRMCES;
5733: a0,a8,32            ldw   R32,Ra8          R32 = NRMRLD;
5736: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
5739: 45,44,01,f8,38      ad3w  R38,Rf8,144      R38 = FN901;                     # Base spark timing Table (Deg BTDC)(RPM vs LOAD)
573e: ef,a9,df            call  36ea             UTabLookUp();
5741: ac,3b,34            ldzbw R34,R3b          R34 = (uns)R3b;
5744: 48,34,42,3c         sb3w  R3c,R42,R34      R3c = R42 - R34;
5748: 01,3a               clrw  R3a              R3a = 0;
574a: b3,72,c5,39         ldb   R39,[R72+c5]     R39 = LUGTMR;
574e: 11,38               clrb  R38              R38 = 0;
5750: af,f8,0f,36         ldzbw R36,[Rf8+f]      R36 = (uns)LUGTIM;
5754: 8c,36,38            divw  R38,R36          R39:R38 = R3b:R38 / R37:R36;
5757: 08,01,38            shrw  R38,1            R38 /= 2;
575a: 28,ee               scall 584a             Scale_R3c();
575c: 44,34,3c,42         ad3w  R42,R3c,R34      R42 = R3c + R34;
5760: a0,a6,30            ldw   R30,Ra6          R30 = NRMCES;
5763: a0,a8,32            ldw   R32,Ra8          R32 = NRMRLD;
5766: ad,0a,34            ldzbw R34,a            R34 = (uns)a;
5769: 45,34,02,f8,38      ad3w  R38,Rf8,234      R38 = FN1121;                     # X -input = Normalized engine speed on RPM - FN070,
                                                                                   # Y -input = Normalized LOAD - FN071,
                                                                                   # Output = Spark advance adder for EGR, deg per 1 percent EGR.
576e: ef,79,df            call  36ea             UTabLookUp();
5771: ac,3b,38            ldzbw R38,R3b          R38 = (uns)R3b;
5774: 7f,72,ee,38         ml2b  R38,[R72+ee]     R38 *= EGRACT;
5778: 08,06,38            shrw  R38,6            R38 /= 40;
577b: 64,38,42            ad2w  R42,R38          R42 += R38;
577e: 45,46,01,f0,32      ad3w  R32,Rf0,146      R32 = FN083;                      # generates Table entry point. Input = N and Output = Normalized N.
5783: a0,ae,34            ldw   R34,Rae          R34 = N;
5786: ef,83,de            call  360c             UUWordLu();
5789: a0,38,30            ldw   R30,R38          R30 = R38;
578c: 45,32,01,f0,32      ad3w  R32,Rf0,132      R32 = FN082;                      # generates Table entry point. Input = LOAD and Output = Normalized Load.
5791: a3,74,de,34         ldw   R34,[R74+de]     R34 = LOAD;                       # engine load (VE)
5795: ef,74,de            call  360c             UUWordLu();
5798: a0,38,32            ldw   R32,R38          R32 = R38;
579b: ad,04,34            ldzbw R34,4            R34 = (uns)4;
579e: 45,84,02,f8,38      ad3w  R38,Rf8,284      R38 = FN1124;                     # Spark Adder from engine speed N and LOAD.
57a3: ef,44,df            call  36ea             UTabLookUp();
57a6: bc,3b,3c            ldsbw R3c,R3b          R3c = (int)R3b;
57a9: af,74,82,38         ldzbw R38,[R74+82]     R38 = (uns)Mult_bp311;
57ad: 28,9b               scall 584a             Scale_R3c();
57af: af,74,f4,38         ldzbw R38,[R74+f4]     R38 = (uns)MFAMUL;
57b3: 28,95               scall 584a             Scale_R3c();
57b5: 64,3c,42            ad2w  R42,R3c          R42 += R3c;
57b8: 45,58,00,f8,32      ad3w  R32,Rf8,58       R32 = FN033;                      # ECT normalizing function.
57bd: bc,b0,34            ldsbw R34,Rb0          R34 = (int)ECT;
57c0: ef,3e,de            call  3601             SUWordLU();
57c3: a0,38,30            ldw   R30,R38          R30 = R38;
57c6: a0,a8,32            ldw   R32,Ra8          R32 = NRMRLD;
57c9: ad,07,34            ldzbw R34,7            R34 = (uns)7;
57cc: 45,e0,02,f8,38      ad3w  R38,Rf8,2e0      R38 = FN311;                      # MFA Part throttle spark modifier Table.
                                                                                   # X -input = Normalized ECT (FN033)
                                                                                   # Y -input = Normalized LOAD (FN071).
57d1: ef,13,df            call  36e7             STabLookup();
57d4: bc,3b,3a            ldsbw R3a,R3b          R3a = (int)R3b;
57d7: 64,3a,42            ad2w  R42,R3a          R42 += R3a;
57da: 45,be,00,f8,32      ad3w  R32,Rf8,be       R32 = FN126;                      # Spark advance vs. ACT
57df: b0,b1,34            ldb   R34,Rb1          R34 = ACT;                        # RB1 = ACT (ACT = RB1 * 4)
57e2: ef,cc,dd            call  35b1             SSByteLU();
57e5: 16,38               sexb  R38              R38 = (int)R38;
57e7: 44,38,42,3c         ad3w  R3c,R42,R38      R3c = R42 + R38;
57eb: 68,18,3c            sb2w  R3c,R18          R3c -= R18;                       #  - "C" (A/T torque truncation retard)
57ee: af,f8,0e,38         ldzbw R38,[Rf8+e]      R38 = (uns)Y;
57f2: 28,56               scall 584a             Scale_R3c();
57f4: 47,f8,04,3c,42      ad3w  R42,R3c,[Rf8+4]  R42 = R3c + KPS1;                 # constant spark adder for part throttle
#
# Retard timing if overspeed (via VSS) with function FN179A(VSBAR).
#
57f9: 32,e7,0f            jnb   B2,Re7,580b      if (HSPFLG == 1)  {               # If overspeed
57fc: 45,65,00,fa,32      ad3w  R32,Rfa,65       R32 = FN179A;                     # High Vehicle Speed Spark retard, mph.
5801: b3,74,3f,34         ldb   R34,[R74+3f]     R34 = VSBAR_H;                    # high byte of vehicle speed filtered(1) (MPH)
5805: ef,af,dd            call  35b7             UUbyteLu();
5808: 68,38,42            sb2w  R42,R38          R42 -= R38; }                     # retard spark
#
580b: a0,42,c2            ldw   Rc2,R42          SAF = R42;
580e: 71,fb,28            an2b  R28,fb           Newsa = 0;
# Jump here from 55D1
5811: 91,80,ed            orb   Red,80           LUGTMR_up = 1;
5814: 71,bf,ed            an2b  Red,bf           LUGTMR_dwn = 0;
5817: b3,72,c5,38         ldb   R38,[R72+c5]     R38 = LUGTMR;
581b: 9b,f8,0f,38         cmpb  R38,[Rf8+f]      
581f: d3,03               jltu  5824             if ((uns) R38 >= LUGTIM)  {
5821: 71,7f,ed            an2b  Red,7f           LUGTMR_up = 0; }
#
5824: 38,24,22            jb    B0,R24,5849      if (Wot == 1) return;
5827: 45,aa,00,f8,32      ad3w  R32,Rf8,aa       R32 = FN125;                  # LOAD function to activate LOM spark strategy.
582c: a0,ae,34            ldw   R34,Rae          R34 = N;                      # Input: RPM and Output: load.
582f: ef,da,dd            call  360c             UUWordLu();
5832: 8b,74,de,38         cmpw  R38,[R74+de]     
5836: d3,11               jltu  5849             if ((uns) R38 < LOAD) return;
5838: b3,f8,10,38         ldb   R38,[Rf8+10]     R38 = LUGSW;
583c: 30,38,04            jnb   B0,R38,5843      if (B0_R38 == 1)  {
583f: c7,72,c5,00         stb   R0,[R72+c5]      LUGTMR = 0; }
#
5843: 71,7f,ed            an2b  Red,7f           LUGTMR_up = 0;
5846: 91,40,ed            orb   Red,40           LUGTMR_dwn = 1; }
#
5849: f0                  ret                    return;


  Scale_R3c:
584a: fe,6c,38,3c         sml2w R3c,R38          R3f:R3c = R3d:R3c * R39:R38;
584e: 0e,07,3c            asrdw R3c,7            R3f:R3c /= 80;
5851: f0                  ret                    return;


#################################################################
# Background Tasklist Routine at 2151, routine offset 4
# Update Dwell - skip subr entirely if TFI Controlled Dwell
# N.B. A9L uses TFI; CCDSW = 0
#################################################################

  Update_dwell:
5852: 9b,f8,1a,00         cmpb  R0,[Rf8+1a]      
5856: df,57               je    58af             if (0 != CCDSW)  {                # Return if TFI controls dwell (A9L)
5858: b3,f8,2a,36         ldb   R36,[Rf8+2a]     R36 = DWLWF;                      # Weighting factor for ECT and ACT on Base Dwell
585c: ef,89,ee            call  46e8             Sub14();
585f: 0a,07,34            asrw  R34,7            R34 /= 80;
5862: 45,18,03,f8,32      ad3w  R32,Rf8,318      R32 = FN160A;                     # Min low speed dwell
5867: 9b,f8,2b,34         cmpb  R34,[Rf8+2b]     
586b: da,05               jle   5872             if ((uns) R34 < DWLTBP)  {
586d: 45,30,03,f8,32      ad3w  R32,Rf8,330      R32 = FN160B; }                   # Min high speed dwell
#
5872: af,74,93,34         ldzbw R34,[R74+93]     R34 = (uns)VBAT;                  # Battery Voltage Level * 16
5876: ef,93,dd            call  360c             UUWordLu();
5879: c3,74,c0,38         stw   R38,[R74+c0]     DWLBSE = R38;                     # Base amount of DWELL
587d: 6d,73,cb,38         ml2w  R38,cb73         R3b:R38 = R39:R38 * 0xcb73;       # convert to IOtime ticks ?
5881: c3,74,bc,3a         stw   R3a,[R74+bc]     Dwlbst = R3a;
5885: a3,74,be,38         ldw   R38,[R74+be]     R38 = Dwell;
5889: 6d,49,9d,38         ml2w  R38,9d49         R3b:R38 = Dwell * 0x9d49;
588d: c3,74,c2,3a         stw   R3a,[R74+c2]     Dwellms = R3a;
#
# Calculate Ppereng, Poffeng
#
5891: af,fe,07,32         ldzbw R32,[Rfe+7]      R32 = (uns)ENGCYL;                # PIPs/rev * 2
5895: 01,3a               clrw  R3a              R3a = 0;
5897: a3,f8,1c,38         ldw   R38,[Rf8+1c]     R38 = PACPER;
589b: 8c,32,38            divw  R38,R32          R39:R38 = PACPER / ENGCYL;
589e: c3,74,c6,38         stw   R38,[R74+c6]     Ppereng = R38;
58a2: 01,3a               clrw  R3a              R3a = 0;
58a4: a3,f8,1e,38         ldw   R38,[Rf8+1e]     R38 = PACOFF;
58a8: 8c,32,38            divw  R38,R32          R39:R38 = PACOFF / ENGCYL;
58ab: c3,74,c8,38         stw   R38,[R74+c8]     Poffeng = R38; }
#
58af: f0                  ret                    return;


#################################################################
# Tasklist Routine at 2151, routine offset 42
# Idle Speed controls
#################################################################

  Update_Idle:
58b0: 34,2b,01            jnb   B4,R2b,58b4      if (Disable_isc == 1)  {           # Ignore if disable flag set
58b3: f0                  ret                    return; }
#
# ISC Mode select
# GUFB p. 9-9
#
58b4: b3,f2,48,42         ldb   R42,[Rf2+48]     R42 = DASMPH;
58b8: 57,f2,49,42,40      ad3b  R40,R42,[Rf2+49] R40 = DASMPH + DASMHYST;          # Dashpot hysteresis
58bd: d3,03               jnc   58c2             if (unsigned overflow)  {
58bf: b1,ff,40            ldb   R40,ff           R40 = ff; }                       # clamp value to max of FF
58c2: 9b,74,3f,40         cmpb  R40,[R74+3f]     
58c6: d1,0b               jleu  58d3             if ((uns) DASMPH + DASMHYST <= VSBAR_H) goto 58d3;
58c8: 9b,74,3f,42         cmpb  R42,[R74+3f]     
58cc: d3,08               jltu  58d6             if ((uns) DASMPH >= VSBAR_H)  {
58ce: 71,f7,e7            an2b  Re7,f7           FLG_DASMNQ = 0;                   # Not in dashpot mode
58d1: 20,03               sjmp  58d6             goto 58d6;
# In dashpot mode
58d3: 91,08,e7            orb   Re7,8            FLG_DASMNQ = 1; }
#
58d6: 37,a1,2f            jnb   B7,Ra1,5908      if (CRKFLG == 1)  {
58d9: a3,72,a6,3a         ldw   R3a,[R72+a6]     R3a = RATCH;
58dd: c3,72,da,3a         stw   R3a,[R72+da]     DSTPBR = RATCH;
58e1: 01,14               clrw  R14              R14 = 0;
58e3: a3,72,be,3a         ldw   R3a,[R72+be]     R3a = TSLPIP;                     # time since last PIP recieved
58e7: 89,00,08,3a         cmpw  R3a,800                                            # = 2048 = 2 seconds
58eb: db,0e               jgeu  58fb             if (R3a < 800)  {
58ed: 45,84,03,f4,32      ad3w  R32,Rf4,384      R32 = FN884;                      # isc duty cycle during crank
58f2: b0,ad,34            ldb   R34,Rad          R34 = TCSTRT;
58f5: ef,b4,dc            call  35ac             subyteLU();
58f8: b0,38,15            ldb   R15,R38          R15 = R38; }
58fb: c0,b8,14            stw   R14,Rb8          ISCDTY = R14;
58fe: a3,fe,26,3a         ldw   R3a,[Rfe+26]     R3a = IFAM;
5902: c3,72,de,3a         stw   R3a,[R72+de]     FAM = R3a;
5906: 20,12               sjmp  591a             goto 591a; }
# Not cranking
5908: 33,c5,17            jnb   B3,Rc5,5922      if (MFMFLG == 1)  {
590b: 34,c5,14            jnb   B4,Rc5,5922      if (TFMFLG == 1)  {
# MAF and TP both failed continuous test
590e: a3,f6,7c,b8         ldw   Rb8,[Rf6+7c]     ISCDTY = FMMISC;                  #
5912: b3,f6,7e,42         ldb   R42,[Rf6+7e]     R42 = FMMDSD;
5916: c7,72,e6,42         stb   R42,[R72+e6]     DSDRPM = FMMDSD;
591a: b1,7f,3a            ldb   R3a,7f           R3a = 7f;
591d: c7,72,d6,3a         stb   R3a,[R72+d6]     SPKMUL = 0x7F;                    # = 0.99 per GUFB
5921: f0                  ret                    return; } }
#
# DSDRPM calculation
# GUFB pp. 9-24 - 9-26
#
5922: a3,fa,3e,1c         ldw   R1c,[Rfa+3e]     R1c = TCDESN;
5926: 35,2a,16            jnb   B5,R2a,593f      if (RUNNING == 0) goto 593f;     # jump if normal strategy - not self test mode
#
# RUNNING == 1 (self test mode)
#
5929: a3,72,6e,40         ldw   R40,[R72+6e]     R40 = RVIPRPM;
592d: 6b,f4,74,40         sb2w  R40,[Rf4+74]     R40 -= NUBASE;                    # R40 = RVIPRPM - NUBASE
5931: 8b,f3,90,00,00      cmpw  R0,[Rf2+90]      
5936: df,77               je    59af             if (0 != VTCDSN)  {
5938: a3,f3,90,00,1c      ldw   R1c,[Rf2+90]     R1c = VTCDSN;
593d: 20,70               sjmp  59af             goto 59af;
#
593f: 45,c4,01,f0,32      ad3w  R32,Rf0,1c4      R32 = Fn825A;                     # Table 90C4
5944: b0,b0,34            ldb   R34,Rb0          R34 = ECT;
5947: ef,62,dc            call  35ac             subyteLU();
#
# From here down R40 contains adjustments to the target idle RPM
#
594a: a0,38,40            ldw   R40,R38          R40 = R38;                        # R40 = Fn825A(ECT)
594d: 45,d4,01,f0,32      ad3w  R32,Rf0,1d4      R32 = Fn825B;                     # Table 90D4
5952: b0,b1,34            ldb   R34,Rb1          R34 = ACT;                        # RB1 = ACT (ACT = RB1 * 4)
5955: ef,54,dc            call  35ac             subyteLU();
5958: 64,38,40            ad2w  R40,R38          R40 += R38;                       # R40 = Fn825B(ACT) + Fn825A(ECT)
595b: 32,e8,0f            jnb   B2,Re8,596d      if (CTNFLG == 1)  {
# Closed throttle, not in gear
595e: b3,72,c4,34         ldb   R34,[R72+c4]     R34 = CTNTMR;
5962: 45,2a,01,f8,32      ad3w  R32,Rf8,12a      R32 = FN880;                      # Table 955A
5967: ef,4d,dc            call  35b7             UUbyteLu();                        
596a: 64,38,40            ad2w  R40,R38          R40 += R38; }                     # R40 = FN880(CTNTMR) + Fn825B(ACT) + Fn825A(ECT)
#
# BZZRPM logic
#
596d: 9b,f5,91,00,c8      cmpb  Rc8,[Rf4+91]     
5972: db,06               jgeu  597a             if (ATMR1 < BZZTM)  {
5974: 67,f4,78,40         ad2w  R40,[Rf4+78]     R40 += BZZRPM;                    # Extra RPM during early start for cleanout
5978: 20,03               sjmp  597d             goto 597d; }
#
# Hi-cam logic
#
597a: 3c,2f,15            jb    B4,R2f,5992      if (PTSCR == 0)  {                # Driver hasn't touched throttle yet
#
597d: 9b,f5,90,00,c8      cmpb  Rc8,[Rf4+90]     
5982: db,0e               jgeu  5992             if (ATMR1 < TKDTM)  {             # Time since start < desired kickdown time
5984: 45,ea,02,f4,32      ad3w  R32,Rf4,2ea      R32 = FN826A;                     # Table 92C0
5989: b0,ad,34            ldb   R34,Rad          R34 = TCSTRT;
598c: ef,1d,dc            call  35ac             subyteLU();
598f: 64,38,40            ad2w  R40,R38          R40 += R38; } }                   # Add hi-cam increment
#
# Heated windshield logic
#
5992: 31,e6,1a            jnb   B1,Re6,59af      if (HWFLAG == 1)  {
5995: 30,e6,17            jnb   B0,Re6,59af      if (HWFLGL == 1)  {
5998: 3e,26,14            jb    B6,R26,59af      if (DNDSUP == 0)  {
# Heated windshield on first time, and in neutral
599b: a3,f0,04,30         ldw   R30,[Rf0+4]      R30 = HWRPM;
599f: 6b,f4,74,30         sb2w  R30,[Rf4+74]     R30 -= NUBASE;
59a3: db,02               jc    59a7             if (R30 < 0)  {                   # underflow, clip to 0
59a5: 01,30               clrw  R30              R30 = 0; }
#
59a7: 88,30,40            cmpw  R40,R30          
59aa: db,03               jgeu  59af             if (R40 < R30)  {                 # Clip idle RPM adders to minimum of HWRPM
59ac: a0,30,40            ldw   R40,R30          R40 = R30; } } } } }
#
# R1C (word) = DESNLO time constant
# R40 (word) = Idle RPM adders to NUBASE (a.k.a. DSDRPM)
#
59af: 08,01,40            shrw  R40,1            R40 /= 2;
59b2: 98,00,41            cmpb  R41,R0                                             # R40 (word) = DSDRPM
59b5: df,03               je    59ba             if (R41 != 0)  {
#
59b7: ad,ff,40            ldzbw R40,ff           R40 = (uns)ff; }                  # Clip overflow
#
59ba: b0,40,35            ldb   R35,R40          R35 = R40;
59bd: 11,34               clrb  R34              R34 = 0;                          # R34 (word) = idle RPM adders (DSDRPM)
59bf: 8b,72,e4,34         cmpw  R34,[R72+e4]     
59c3: db,15               jgeu  59da             if (R34 < DESNLO)  {              # Desired RPM not increasing
59c5: a3,72,e4,32         ldw   R32,[R72+e4]     R32 = DESNLO;                     # Compute rolling average of DESNLO
59c9: ef,92,dc            call  365e             Urolav_1Arg(1c);
59cc: 1c,00               #args  
59ce: c3,72,e4,3e         stw   R3e,[R72+e4]     DESNLO = R3e;                     # filtered DESNLO
59d2: c0,40,3e            stw   R3e,R40          R40 = R3e;                        # 
59d5: 08,07,40            shrw  R40,7            R40 /= 80;                        # Scale R40
59d8: 20,07               sjmp  59e1             goto 59e1; }
#
59da: c3,72,e4,34         stw   R34,[R72+e4]     DESNLO = R34;                     # Desired RPM increasing, use DSDRPM as DESNLO
59de: 09,01,40            shlw  R40,1            R40 *= 2;
#
# R40 (word) = DSDRPM
#
59e1: 91,80,26            orb   R26,80           HCAMFG = 1;
59e4: 88,00,40            cmpw  R40,R0           
59e7: d7,03               jne   59ec             if (R40 == 0)  {
59e9: 71,7f,26            an2b  R26,7f           HCAMFG = 0; }                     # Turn hi-cam off if DSDRPM == 0
#
59ec: b3,72,eb,14         ldb   R14,[R72+eb]     R14 = ISFLAG;
59f0: c7,72,ec,14         stb   R14,[R72+ec]     ISLAST = ISFLAG;
#
59f4: 01,3e               clrw  R3e              R3e = 0;
59f6: a3,72,de,16         ldw   R16,[R72+de]     R16 = FAM;
#
# GUFB p. 9-26 top
# R14 (byte) = ISLAST (old value of ISFLAG):
#  B0: 1 = A/C was on
#  B1: 0 = Auto trans was in drive, 1 = was in neutral or is manual
# R16 (word) = FAM (filtered air mass)
# R3E (byte) = idle mode flags; will become new ISFLAG
# 
59fa: 36,26,09            jnb   B6,R26,5a06      if (DNDSUP == 0) goto 5a06;       # jmp if auto trans in neutral
59fd: b3,fe,02,30         ldb   R30,[Rfe+2]      R30 = TRLOAD;
5a01: 99,03,30            cmpb  R30,3
5a04: d9,09               jgtu  5a0f             if ((uns) R30 <= 3)  {            # jmp if not manual trans
#
# Manual trans or in neutral, set idle off NUBASE
#
5a06: 91,02,3e            orb   R3e,2            Isf_neut = 1;
5a09: 67,f4,74,40         ad2w  R40,[Rf4+74]     R40 += NUBASE;                    
5a0d: 20,04               sjmp  5a13             goto 5a13; }
#
# Auto trans in drive, set idle off DRBASE
#
5a0f: 67,f4,76,40         ad2w  R40,[Rf4+76]     R40 += DRBASE;
#
# Check if A/C on
# GUFB p. 9-26 upper middle
#
5a13: 3b,ea,03            jb    B3,Rea,5a19      if (ACCFLG == 1) goto 5a19;
5a16: 32,ea,03            jnb   B2,Rea,5a1c      if (ACIFLG == 1)  {
# A/C clutch engaged or about to be 
5a19: 91,01,3e            orb   R3e,1            Isf_acon = 1; }
#
5a1c: 38,3e,0b            jb    B0,R3e,5a2a      if (Isf_acon == 1) goto 5a2a;
5a1f: a3,f5,8c,00,30      ldw   R30,[Rf4+8c]     R30 = DACTM;
5a24: 8b,74,98,30         cmpw  R30,[R74+98]     
5a28: d1,04               jleu  5a2e             if ((uns) R30 > ACCTMR )  {
# 
5a2a: 67,f4,7a,40         ad2w  R40,[Rf4+7a]     R40 += DNAC; }
#
# Check power steering load
# GUFB p. 9-26 lower middle
# Not used on A9L
#
5a2e: 34,27,12            jnb   B4,R27,5a43      if (POWSFG == 1)  {
5a31: 57,f6,14,00,30      ad3b  R30,R0,[Rf6+14]  R30 = PSPSHP;                     # Pwr steering pressure switch present (not present on A9L)
5a36: df,0b               je    5a43             if (PSPSHP != 0)  {
# Pressure switch present and activated
5a38: 67,f5,8e,00,40      ad2w  R40,[Rf4+8e]     R40 += DNPOWS;
5a3d: 91,80,26            orb   R26,80           HCAMFG = 1;                       # Turn on hi cam flag to bypass adaptive airflow update
5a40: 91,01,3f            orb   R3f,1            Isf_pson = 1; } }
#
# Jump here from:
#  5a2e (!POWSFG)
#  5a36 (PSPSHP == 0)
#
# Clip DSDRPM if in drive and not just after cold start
# GUFB p. 9-26 bottom
#
5a43: 39,3e,14            jb    B1,R3e,5a5a      if (Isf_neut == 0)  {
5a46: b3,72,cd,30         ldb   R30,[R72+cd]     R30 = ATMR3;                      # time since entering 'running' mode
5a4a: 9b,fa,1e,30         cmpb  R30,[Rfa+1e]     
5a4e: d1,0a               jleu  5a5a             if ((uns) R30 > CRKTIM )  {
5a50: 8b,f4,7c,40         cmpw  R40,[Rf4+7c]     
5a54: d1,04               jleu  5a5a             if ((uns) R40 > ISCLPD )  {
5a56: a3,f4,7c,40         ldw   R40,[Rf4+7c]     R40 = ISCLPD; } } }
#
# Predicted DESMAF (idle airflow) Calculation
# GUFB p. 9-27
#
# R14 (byte): ISLAST, old value of ISFLAG
# R3E (byte): idle mode flags -> will be saved in ISFLAG
#  B0: 1 = A/C on
#  B1: 0 = Auto trans in drive, 1 = neutral or manual
# R3F (byte): additional idle flag
#  B0: 1 = P/S pressure switch on
# R40 (word): DSDRPM (target idle RPM)
# 
5a5a: 31,3e,07            jnb   B1,R3e,5a64      if (Isf_neut == 1)  {
5a5d: 45,c6,03,f4,32      ad3w  R32,Rf4,3c6      R32 = FN875N;
5a62: 20,05               sjmp  5a69             goto 5a69; }
#
5a64: 45,ba,03,f4,32      ad3w  R32,Rf4,3ba      R32 = FN875D;
5a69: a0,40,34            ldw   R34,R40          R34 = R40;
5a6c: 08,01,34            shrw  R34,1            R34 /= 2;
5a6f: 99,00,35            cmpb  R35,0            
5a72: d1,03               jleu  5a77             if ((uns) R35 > 0 )  {
5a74: b1,ff,34            ldb   R34,ff           R34 = ff; }                       # Clip DSDRPM if too big
#
5a77: ef,3d,db            call  35b7             UUbyteLu();
5a7a: a0,38,20            ldw   R20,R38          R20 = R38;                        # R20 (byte, zero extended) =
                                                                                   #  predicted airflow based on RPM
#
# N.B. R20 = working DESMAF
#
5a7d: 45,76,02,f4,32      ad3w  R32,Rf4,276      R32 = FN020C;                     # ECT scaler 
5a82: b0,b0,34            ldb   R34,Rb0          R34 = ECT;
5a85: ef,24,db            call  35ac             subyteLU();
5a88: ac,38,30            ldzbw R30,R38          R30 = (uns)R38;
5a8b: 09,04,30            shlw  R30,4            R30 *= 10;                        # R30 = ECT table index (X)
5a8e: 45,7e,00,fc,32      ad3w  R32,Rfc,7e       R32 = FN018B;                     # ATMR3 scaler
5a93: af,72,cd,34         ldzbw R34,[R72+cd]     R34 = (uns)ATMR3;                 #  time since entering 'running' mode
5a97: ef,72,db            call  360c             UUWordLu();
5a9a: a0,38,32            ldw   R32,R38          R32 = R38;                        # R32 = ATMR3 table index (Y)
5a9d: ad,07,34            ldzbw R34,7            R34 = (uns)7;                     # R34 = # of columns
5aa0: 45,90,03,f4,38      ad3w  R38,Rf4,390      R38 = FN1861;                     # Table 9366 - (ECT,ATMR3) = Airflow multiplier vs. ECT and ATMR3
5aa5: ef,42,dc            call  36ea             UTabLookUp();
5aa8: 7c,3b,20            ml2b  R20,R3b          R20 *= R3b;                       # Multiply desired airflow by cold start factor
                                                                                   # (0x40 = 1)
5aab: 08,02,20            shrw  R20,2            R20 /= 4;                         # Is now at least 0x10 times bigger than table lookup
5aae: 30,3e,05            jnb   B0,R3e,5ab6      if (Isf_acon == 1)  {
5ab1: 67,f5,86,00,20      ad2w  R20,[Rf4+86]     R20 += ACPPM; }                   # Add A/C increment 
#
5ab6: 30,3f,05            jnb   B0,R3f,5abe      if (Isf_pson == 1)  {
5ab9: 67,f5,8a,00,20      ad2w  R20,[Rf4+8a]     R20 += PSPPM; }                   # Add P/S increment
#
# Filtered Air Mass Adjustments
# GUFB p. 9-31
#
5abe: 31,14,0a            jnb   B1,R14,5acb      if (Isl_neut == 0) goto 5acb;
5ac1: 39,3e,14            jb    B1,R3e,5ad8      if (Isf_neut == 0)  {
# Was neutral, going to drive, bump up FAM
5ac4: 67,f5,82,00,16      ad2w  R16,[Rf4+82]     R16 += NDPPM;                      
5ac9: 20,0d               sjmp  5ad8             goto 5ad8;
#
5acb: 31,3e,0a            jnb   B1,R3e,5ad8      if (Isf_neut == 1)  {
# Was drive, going to neutral, bump FAM down
5ace: 6b,f5,84,00,16      sb2w  R16,[Rf4+84]     R16 -= DNPPM;
#
5ad3: db,03               jc    5ad8             if (R16 > 0)  {
5ad5: a0,00,16            ldw   R16,R0           R16 = 0; } } }                    # Clip FAM to 0 in event of underflow
#
5ad8: 30,14,0f            jnb   B0,R14,5aea      if (Isl_acon == 0) goto 5aea;
5adb: 38,3e,14            jb    B0,R3e,5af2      if (Isf_acon == 0)  {
# A/C was on, going off, bump FAM down
5ade: 6b,f5,88,00,16      sb2w  R16,[Rf4+88]     R16 -= DACPPM;
5ae3: db,0d               jc    5af2             if (R16 > 0)  {
5ae5: a0,00,16            ldw   R16,R0           R16 = 0;                          # Clip FAM to 0 in event of underflow
5ae8: 20,08               sjmp  5af2             goto 5af2;
#
5aea: 30,3e,05            jnb   B0,R3e,5af2      if (Isf_acon == 1)  {
# A/C was off, going on, bump FAM up
5aed: 67,f5,86,00,16      ad2w  R16,[Rf4+86]     R16 += ACPPM; } } }
#
5af2: 30,3f,15            jnb   B0,R3f,5b0a      if (Isf_pson == 0) goto 5b0a;
5af5: 3a,ec,15            jb    B2,Rec,5b0d      if (PSFLAG == 0)  {
# P/S state change, bump FAM up
5af8: 67,f5,8a,00,16      ad2w  R16,[Rf4+8a]     R16 += PSPPM;
5afd: 91,04,ec            orb   Rec,4            PSFLAG = 1;
5b00: c3,72,e0,00         stw   R0,[R72+e0]      IBGPSI = 0;                       # Reset idle RPM integrator counter
5b04: c7,72,ea,00         stb   R0,[R72+ea]      BGCNT = 0;                        #  and FAM counter
5b08: 20,03               sjmp  5b0d             goto 5b0d;
#
5b0a: 71,fb,ec            an2b  Rec,fb           PSFLAG = 0; }
#
# GUFB p. 9-27 bottom
#
5b0d: 31,e6,0a            jnb   B1,Re6,5b1a      if (HWFLAG == 1)  {
5b10: 30,e6,07            jnb   B0,Re6,5b1a      if (HWFLGL == 1)  {
5b13: 3e,26,04            jb    B6,R26,5b1a      if (DNDSUP == 0)  {
5b16: 67,f6,0c,20         ad2w  R20,[Rf6+c]      R20 += HWPPM; } } }              # DESMAF adder for heated windshield
#
5b1a: c7,72,eb,3e         stb   R3e,[R72+eb]     ISFLAG = R3e;
5b1e: c3,72,de,16         stw   R16,[R72+de]     FAM = R16;

5b22: 08,01,40            shrw  R40,1            R40 /= 2;
5b25: 98,00,41            cmpb  R41,R0           
5b28: df,03               je    5b2d             if (R41 != 0)  {
5b2a: ad,ff,40            ldzbw R40,ff           R40 = (uns)ff; }                 # Clip DSDRPM if too big to fit
#
5b2d: c7,72,e6,40         stb   R40,[R72+e6]     DSDRPM = R40;                    #  and save it
5b31: 09,06,40            shlw  R40,6            R40 *= 40;
#
# DSTPBR (TP rolling average) Calculation
# GUFB p. 9-16
#
5b34: a3,72,da,32         ldw   R32,[R72+da]     R32 = DSTPBR;
5b38: a0,aa,34            ldw   R34,Raa          R34 = TP;                         # RAA is Throttle position
5b3b: a3,fa,3c,36         ldw   R36,[Rfa+3c]     R36 = TCDASU;                     # Load time constant - assumes TP increasing
5b3f: 88,32,34            cmpw  R34,R32          
5b42: d9,04               jgtu  5b48             if ((uns) TP <= DSTPR)  {
5b44: a3,fa,3a,36         ldw   R36,[Rfa+3a]     R36 = TCDASD; }                   # TP decreasing, use decrease time constant
#
5b48: ef,18,db            call  3663             Urolav();
5b4b: c3,72,da,3e         stw   R3e,[R72+da]     DSTPBR = R3e;
#
# DASPOT Calculation
# GUFB p. 9-17
# R3E (word) = DSTPBR
#
5b4f: 37,d0,24            jnb   B7,Rd0,5b76      if (APT >= 0) goto 5b76;
#
# At closed throttle
#
5b52: 45,54,03,f4,32      ad3w  R32,Rf4,354      R32 = FN879;                      # dashpot decrement rate (dashpot decrement step at given flow(Kg/Hr(flow),Kg/Hr(Step))
5b57: a3,72,dc,34         ldw   R34,[R72+dc]     R34 = DASPOT;
5b5b: 33,e7,09            jnb   B3,Re7,5b67      if (FLG_DASMNQ == 0) goto 5b67;
#
# R3E (word) will become new DASPOT at 5BB0
#
5b5e: a3,f2,4a,3e         ldw   R3e,[Rf2+4a]     R3e = DASMIN;                     # 
5b62: 88,3e,34            cmpw  R34,R3e          
5b65: d1,49               jleu  5bb0             if ((uns) DASPOT > DASMIN)  {     # Branch taken -> clip DASPOT to DASMIN
# Bleed down dashpot
5b67: a0,34,3e            ldw   R3e,R34          R3e = R34;
5b6a: ef,9f,da            call  360c             UUWordLu();
5b6d: 68,38,3e            sb2w  R3e,R38          R3e -= R38;                       # New DASPOT = DASPOT - FN879(DASPOT)
5b70: db,3e               jc    5bb0             if (R3e > 0)  {
5b72: 01,3e               clrw  R3e              R3e = 0;                          # Clip to 0 on underflow
5b74: 20,3a               sjmp  5bb0             goto 5bb0;
#
# Throttle not closed, prepare DASPOT for next decel
# R3E (word) = DSTPBR
#
5b76: a3,f4,60,42         ldw   R42,[Rf4+60]     R42 = DELHYS;
5b7a: 67,72,a6,42         ad2w  R42,[R72+a6]     R42 += RATCH;  
5b7e: d3,03               jnc   5b83             if ((uns) R42 >= 0)  {
5b80: bd,c0,42            ldsbw R42,c0           R42 = (int)c0; }                  # Clip on overflow
#
5b83: 68,42,3e            sb2w  R3e,R42          R3e = DSTPBR - (DELHYS + RATCH);
5b86: db,02               jc    5b8a             if (R3e > 0)  {
5b88: 01,3e               clrw  R3e              R3e = 0; }                        # Clip to 0 on underflow
5b8a: a3,f4,5c,3c         ldw   R3c,[Rf4+5c]     R3c = DASPTK;
5b8e: 6c,3e,3c            ml2w  R3c,R3e          R3F:R3C = DASPTK * (DSTPBR - (DELHYS + RATCH));
5b91: 45,70,03,f4,32      ad3w  R32,Rf4,370      R32 = FN882;                      # Max Dashpot clip Dashpot clip(lbs/min) vs RPM
5b96: a0,ae,34            ldw   R34,Rae          R34 = N;
5b99: ef,70,da            call  360c             UUWordLu();                       # R38 (word) = FN882(N)
5b9c: 99,20,3f            cmpb  R3f,20           
5b9f: db,0c               jgeu  5bad             if ((uns) R3f >= 20) goto 5bad;
# R38 = FN882(N)
# R3C:R3E (doubleword) = DASPTK * (DSTPBR - (DELHYS + RATCH))
5ba1: 0d,02,3c            shldw R3c,2            R3F:R3C *= 4;                     # binary point adjust
5ba4: 67,f4,5e,3e         ad2w  R3e,[Rf4+5e]     R3e += DASPTO;
5ba8: 88,38,3e            cmpw  R3e,R38          
5bab: d1,03               jleu  5bb0             if ((uns) R3e > R38 )  {
#
5bad: a0,38,3e            ldw   R3e,R38          R3e = R38; } } }                  # Clip DASPOT to FN882(N) max
#
# Jump here from 5B74
#
5bb0: c3,72,dc,3e         stw   R3e,[R72+dc]     DASPOT = R3e;                     # Save DASPOT
5bb4: c0,1c,3e            stw   R3e,R1c          R1c = R3e;
#
# ISC Mode Select
# GUFB p. 9-10
# R1C (word) = DASPOT
#
5bb7: 3f,d0,13            jb    B7,Rd0,5bcd      if (APT >= 0)  {
#
# Enter Dashpot Preposition Mode
# R1C (word) = DASPOT
# R40 (word) = DSDRPM
#
5bba: c3,72,e2,ae         stw   Rae,[R72+e2]     NLAST = N;
5bbe: 11,3a               clrb  R3a              R3a = 0;                          # Preposition mode - Will be saved as ISCFLG 
5bc0: c7,72,c6,00         stb   R0,[R72+c6]      ISCTMR = 0;
5bc4: b1,7f,3c            ldb   R3c,7f           R3c = 7f;
5bc7: c7,72,d6,3c         stb   R3c,[R72+d6]     SPKMUL = 0x7F;                    # = .996 
5bcb: 20,a1               sjmp  5c6e             goto 5c6e; }                      # Set Preposition Mode
#
# Check other modes
#
5bcd: b1,01,3a            ldb   R3a,1            R3a = 1;                          # RPM control mode
5bd0: 35,2a,07            jnb   B5,R2a,5bda      if (RUNNING == 1)  {              # jump if normal strategy - not self test mode
#
# RUNNING == 1 - KEOR self test
#
5bd3: 88,1c,00            cmpw  R0,R1c           
5bd6: d7,02               jne   5bda             if (0 != DASPOT) goto 5bda;
5bd8: 20,94               sjmp  5c6e             goto 5c6e; }                      # Set RPM Control Mode - Running in self test and DASPOT == 0
#
#
5bda: b3,fe,02,16         ldb   R16,[Rfe+2]      R16 = TRLOAD;                     # 9E5C
5bde: 99,03,16            cmpb  R16,3            
5be1: d7,03               jne   5be6             if (R16 != 3) goto 5be6;          # Automatic or manual w/o neutral, clutch switches
5be3: 3e,26,42            jb    B6,R26,5c28      if (DNDSUP == 1) goto 5c28;       # Manual trans w/ both switches, but in gear
#
5be6: b3,f4,66,30         ldb   R30,[Rf4+66]     R30 = MINMPH;
5bea: 9b,74,3f,30         cmpb  R30,[R74+3f]                                       # 2BD - vehicle speed filtered(1) (MPH) 2BC is 8.8 format
5bee: d3,38               jltu  5c28             if ((uns) MINMPH < VSBAR_H) goto 5c28; # too fast for RPM control mode
5bf0: 88,00,1c            cmpw  R1c,R0           
5bf3: d7,33               jne   5c28             if (DASPOT != 0) goto 5c28;       # still bleeding down dashpot
5bf5: 47,f4,62,40,38      ad3w  R38,R40,[Rf4+62] R38 = DSDRPM + RPMCTL;
5bfa: 88,38,ae            cmpw  Rae,R38          
5bfd: d9,02               jgtu  5c01             if ((uns) N > DSDRPM + RPMCTL ) goto 5c01;
5bff: 20,6d               sjmp  5c6e             goto 5c6e;                        # Set RPM Control Mode
#
# Check RPM Lockout mode
# GUFB p. 9-11
# R16 (byte) = TRLOAD
# R1C (word) = DASPOT
# R3a (byte) = 1
#
5c01: 9b,72,d7,00         cmpb  R0,[R72+d7]      
5c05: de,37               jlt   5c3e             if (0 >= ISCFLG)  {
5c07: b3,72,c6,38         ldb   R38,[R72+c6]     R38 = ISCTMR;
5c0b: 9b,f4,6d,38         cmpb  R38,[Rf4+6d]     
5c0f: d3,17               jltu  5c28             if ((uns) ISCTMR < ISCTM) goto 5c28; # enter dashpot mode - GUFB p. 9-13
5c11: 4b,72,e2,ae,38      sb3w  R38,Rae,[R72+e2] R38 = NLAST - N;
5c16: db,02               jc    5c1a             if (R38 > 0)  {
5c18: 03,38               negw  R38              R38 = -R38; }                     # take absolute value
5c1a: 8b,f4,64,38         cmpw  R38,[Rf4+64]     
5c1e: d1,1e               jleu  5c3e             if ((uns) |NLAST - N| > NDIF )  {
#
# Enter dashpot mode (dashpot bled down, but RPM indicates decel)
# GUFB p. 9-14
#
5c20: c3,72,e2,ae         stw   Rae,[R72+e2]     NLAST = N;
5c24: c7,72,c6,00         stb   R0,[R72+c6]      ISCTMR = 0;                       # zero ISCTMR
#
# Enter dashpot mode
# GUFB p. 9-12
# R16 (byte) = TRLOAD
# R1C (word) = DASPOT
# R3a (byte) = 1
#
5c28: a0,1c,34            ldw   R34,R1c          R34 = DASPOT;
5c2b: 08,06,34            shrw  R34,6            R34 /= 40;
5c2e: 45,f8,02,f4,32      ad3w  R32,Rf4,2f8      R32 = FN839;
5c33: ef,81,d9            call  35b7             UUbyteLu();
5c36: c7,72,d6,38         stb   R38,[R72+d6]     SPKMUL = FN893(DASPOT);
5c3a: 13,3a               negb  R3a              R3a = -R3a;                       # -1 = dashpot mode
5c3c: 20,30               sjmp  5c6e             goto 5c6e; } }
#
# GUFB pp. 9-14, 9-15
# R16 (byte) = TRLOAD
# R1C (word) = DASPOT
# R3a (byte) = 1
#
5c3e: 99,03,16            cmpb  R16,3            
5c41: d3,03               jltu  5c46             if ((uns) TRLOAD < 3) goto 5c46;
5c43: 36,26,25            jnb   B6,R26,5c6b      if (DNDSUP == 1)  {               # jump taken = RPM lockout mode
5c46: af,f4,6e,38         ldzbw R38,[Rf4+6e]     R38 = (uns)LOWLOD;
5c4a: 33,ea,09            jnb   B3,Rea,5c56      if (ACCFLG == 1)  {
5c4d: 77,f4,6f,38         ad2b  R38,[Rf4+6f]     R38 += ACLOD;
5c51: d3,03               jnc   5c56             if ((uns) R38 >= 0)  {
5c53: ad,ff,38            ldzbw R38,ff           R38 = (uns)ff; } }                # clip if overflow
5c56: 09,06,38            shlw  R38,6            R38 *= 40;
5c59: 8b,74,de,38         cmpw  R38,[R74+de]
5c5d: d3,0c               jltu  5c6b             if ((uns) R38 >= LOAD)  {         # jump taken = RPM lockout mode
5c5f: c3,72,e2,ae         stw   Rae,[R72+e2]     NLAST = N;
5c63: c7,72,c6,00         stb   R0,[R72+c6]      ISCTMR = 0;
5c67: 13,3a               negb  R3a              R3a = -R3a;                       # Set dashpot mode
5c69: 20,03               sjmp  5c6e             goto 5c6e; } }                    #
#
5c6b: b1,02,3a            ldb   R3a,2            R3a = 2;                          # Set RPM Lockout mode
#
# Jump here from 5C3C
#
5c6e: c7,72,d7,3a         stb   R3a,[R72+d7]     ISCFLG = R3a;                     # Save new value of ISCFLG
5c72: af,72,eb,32         ldzbw R32,[R72+eb]     R32 = (uns)ISFLAG;
5c76: a3,72,d4,38         ldw   R38,[R72+d4]     R38 = IPSIBR;                     # Get idle integrator
5c7a: 0a,01,38            asrw  R38,1            R38 /= 2;                         # Scale IPSIBR (signed)
5c7d: 08,01,1c            shrw  R1c,1            R1c /= 2;                         #  and DASPOT for arithmetic headroom
5c80: 3f,e9,06            jb    B7,Re9,5c89      if (CTPTFG == 1) goto 5c89;
5c83: 9b,72,ec,32         cmpb  R32,[R72+ec]     
5c87: df,13               je    5c9c             if (R32 != ISLAST)  {
#
5c89: c3,72,e0,00         stw   R0,[R72+e0]      IBGPSI = 0;
5c8d: c7,72,ea,00         stb   R0,[R72+ea]      BGCNT = 0;
5c91: 88,00,38            cmpw  R38,R0           
5c94: d6,06               jge   5c9c             if (R38 < 0)  {
5c96: 01,38               clrw  R38              R38 = 0;
5c98: c3,72,d4,38         stw   R38,[R72+d4]     IPSIBR = R38; } }
#
5c9c: 09,01,32            shlw  R32,1            R32 *= 2;
5c9f: 01,3c               clrw  R3c              R3c = 0;
5ca1: 3f,28,08            jb    B7,R28,5cac      if (KAM_ERROR == 0)  {
5ca4: a3,33,e4,07,3c      ldw   R3c,[R32+7e4]    R3c = [R32+ISCKAM0];              # Get ISCKAM cell for this idle state
5ca9: 0a,01,3c            asrw  R3c,1            R3c /= 2; }                       # Scale it
#
# R20 = running sum of desired airflow / 2
#
5cac: 64,1c,20            ad2w  R20,R1c          R20 += R1c;                       # Sum DASPOT
5caf: 64,38,20            ad2w  R20,R38          R20 += R38;                       #  and IPSIBR
5cb2: 64,3c,20            ad2w  R20,R3c          R20 += R3c;                       #  and ISCKAMn
5cb5: a0,20,3e            ldw   R3e,R20          R3e = R20;
5cb8: d6,02               jge   5cbc             if (R20 < 0)  {
5cba: 01,3e               clrw  R3e              R3e = 0; }                        # Clip to 0 if negative
5cbc: 09,01,20            shlw  R20,1            R20 *= 2;                         # Restore original scale
5cbf: c3,72,d8,20         stw   R20,[R72+d8]     DESMAF = R20;                     # Save now that all inputs accounted for
5cc3: 09,01,3e            shlw  R3e,1            R3e *= 2;                         # Restore scale to R3E as well
#
# R3E (word) = desired idle airflow
#
5cc6: b3,72,d7,1e         ldb   R1e,[R72+d7]     R1e = ISCFLG;
5cca: a3,72,e0,1c         ldw   R1c,[R72+e0]     R1c = IBGPSI;                     # Idle air background loop counter
5cce: 45,b0,02,f4,32      ad3w  R32,Rf4,2b0      R32 = FN810;                      # ISC adder vs. RPM
5cd3: a0,ae,34            ldw   R34,Rae          R34 = N;
5cd6: ef,33,d9            call  360c             UUWordLu();
5cd9: 64,38,3e            ad2w  R3e,R38          R3e += R38;
5cdc: d3,03               jnc   5ce1             if ((uns) R3e >= 0)  {
5cde: bd,ff,3e            ldsbw R3e,ff           R3e = 0xffff; }
#
5ce1: 6b,f4,58,3e         sb2w  R3e,[Rf4+58]     R3e -= ITHBMA;                    # ITHBMA = closed throttle plate flow
5ce5: db,02               jc    5ce9             if (R3e < 0)  {
5ce7: 01,3e               clrw  R3e              R3e = 0; }
#
# R3E (word) = desired IAC airflow
#
5ce9: 98,00,1e            cmpb  R1e,R0           
5cec: da,3b               jle   5d29             if (R1e <= 0) goto 5d29;
5cee: 07,1c               incw  R1c              R1c++;
5cf0: d3,02               jnc   5cf4             if ((uns) R1c >= 0)  {
5cf2: 05,1c               decw  R1c              R1c--; }                          # Clip IBGPSI to FF
#
5cf4: c3,72,e0,1c         stw   R1c,[R72+e0]     IBGPSI = R1c;
5cf8: 11,16               clrb  R16              R16 = 0;
5cfa: 48,ae,40,14         sb3w  R14,R40,Rae      R14 = R40 - N;
5cfe: db,02               jc    5d02             if (R14 > 0)  {
5d00: 17,16               incb  R16              R16++; }
#
5d02: 3e,26,07            jb    B6,R26,5d0c      if (DNDSUP == 0)  {
5d05: 45,1c,03,f4,32      ad3w  R32,Rf4,31c      R32 = FN841N;                     # RPM error vs. spark - neutral
5d0a: 20,05               sjmp  5d11             goto 5d11; }
#
5d0c: 45,00,03,f4,32      ad3w  R32,Rf4,300      R32 = FN841D;                     # RPM error vs. spark - drive
#
5d11: a0,14,34            ldw   R34,R14          R34 = R14;
5d14: ef,ea,d8            call  3601             SUWordLU();
5d17: c7,72,d6,38         stb   R38,[R72+d6]     SPKMUL = R38;
5d1b: a0,14,34            ldw   R34,R14          R34 = R14;
5d1e: 30,16,02            jnb   B0,R16,5d23      if (Vsc_flg1 == 1)  {
5d21: 03,14               negw  R14              R14 = -R14; }
5d23: 8b,f4,68,14         cmpw  R14,[Rf4+68]     
5d27: d9,02               jgtu  5d2b             if ((uns) R14 > RPMDED) goto 5d2b;
#
5d29: 20,c6               sjmp  5df1             goto 5df1;
#
5d2b: c7,72,c6,00         stb   R0,[R72+c6]      ISCTMR = 0;                       # zero ISCTMR timer
5d2f: a3,fe,44,38         ldw   R38,[Rfe+44]     R38 = V860;
5d33: 3d,2a,08            jb    B5,R2a,5d3e      if (RUNNING == 0)  {              # not in KOER self test mode
5d36: 45,38,03,f4,32      ad3w  R32,Rf4,338      R32 = FN860;                      # ISC closed loop correction rate vs RPMERR
5d3b: ef,c3,d8            call  3601             SUWordLU(); }
#
5d3e: 88,38,1c            cmpw  R1c,R38          
5d41: db,02               jgeu  5d45             if ((uns) R1c >= R38) goto 5d45;
5d43: 20,ac               sjmp  5df1             goto 5df1;

5d45: 01,1c               clrw  R1c              R1c = 0;
5d47: c3,72,e0,1c         stw   R1c,[R72+e0]     IBGPSI = R1c;
5d4b: 3d,2a,14            jb    B5,R2a,5d62      if (RUNNING == 0)  {              # not in KOER self test
5d4e: 89,70,7d,b8         cmpw  Rb8,7d70         
5d52: d3,0e               jltu  5d62             if ((uns) ISCDTY >= 7d70)  {
5d54: 4b,f4,62,40,32      sb3w  R32,R40,[Rf4+62] R32 = R40 - RPMCTL;
5d59: d1,07               jleu  5d62             if ((uns) R32 > 0 )  {
5d5b: 88,ae,32            cmpw  R32,Rae          
5d5e: d1,02               jleu  5d62             if ((uns) R32 <= N) goto 5d62;
5d60: 20,8f               sjmp  5df1             goto 5df1; } } }
#
5d62: 35,2a,06            jnb   B5,R2a,5d6b      if (RUNNING == 1)  {             # jump if normal strategy - not self test mode
5d65: a1,00,40,38         ldw   R38,4000         R38 = 4000;
5d69: 20,0f               sjmp  5d7a             goto 5d7a; }

5d6b: b3,74,21,34         ldb   R34,[R74+21]     R34 = N_BYTE;                     # 29F - N byte
5d6f: 45,dc,02,f4,32      ad3w  R32,Rf4,2dc      R32 = FN824;                      # ISC gain vs. RPM
5d74: ef,40,d8            call  35b7             UUbyteLu();
5d77: 09,08,38            shlw  R38,8            R38 *= 100;

5d7a: 6c,14,38            ml2w  R38,R14          R3b:R38 = R39:R38 * R15:R14;
5d7d: 35,2a,0d            jnb   B5,R2a,5d8d      if (RUNNING == 0) goto 5d8d;     # jump if normal strategy - not self test mode
#
# RUNNING == 1 - KOER self test
#
5d80: a3,fe,40,38         ldw   R38,[Rfe+40]     R38 = VPSIND;
5d84: 38,16,21            jb    B0,R16,5da8      if (Vsc_flg1 == 0)  {
5d87: a3,fe,42,38         ldw   R38,[Rfe+42]     R38 = VPSINU;
5d8b: 20,1b               sjmp  5da8             goto 5da8;
#
5d8d: 3e,26,0d            jb    B6,R26,5d9d      if (DNDSUP == 1) goto 5d9d;
5d90: a3,f4,4e,38         ldw   R38,[Rf4+4e]     R38 = KPSIND;
5d94: 38,16,11            jb    B0,R16,5da8      if (Vsc_flg1 == 0)  {
5d97: a3,f4,4c,38         ldw   R38,[Rf4+4c]     R38 = KPSINU;
5d9b: 20,0b               sjmp  5da8             goto 5da8;

5d9d: a3,f4,52,38         ldw   R38,[Rf4+52]     R38 = KPSIDD;
5da1: 38,16,04            jb    B0,R16,5da8      if (Vsc_flg1 == 0)  {
5da4: a3,f4,50,38         ldw   R38,[Rf4+50]     R38 = KPSIDU; } } }

5da8: 6c,3a,38            ml2w  R38,R3a          R3b:R38 = R39:R38 * R3b:R3a;
5dab: 99,02,3b            cmpb  R3b,2            
5dae: d3,06               jltu  5db6             if ((uns) R3b >= 2)  {
5db0: a1,ff,7f,3a         ldw   R3a,7fff         R3a = 7fff;
5db4: 20,03               sjmp  5db9             goto 5db9; }

5db6: 0d,06,38            shldw R38,6            R3b:R38 *= 40;

5db9: a3,f4,54,34         ldw   R34,[Rf4+54]     R34 = PSIBRM;
5dbd: a3,f4,56,36         ldw   R36,[Rf4+56]     R36 = PSIBRN;
5dc1: 35,2a,08            jnb   B5,R2a,5dcc      if (RUNNING == 1)  {             # jump if normal strategy - not self test mode
#
# RUNNING == 1 - KOER self test mode
#
5dc4: a3,fe,3c,34         ldw   R34,[Rfe+3c]     R34 = VSIBRM;
5dc8: a3,fe,3e,36         ldw   R36,[Rfe+3e]     R36 = VSIBRN; }
#
5dcc: 30,16,02            jnb   B0,R16,5dd1      if (Vsc_flg1 == 1)  {
5dcf: 03,3a               negw  R3a              R3a = -R3a; }
#
5dd1: 67,72,d4,3a         ad2w  R3a,[R72+d4]     R3a += IPSIBR;
5dd5: d5,04               jnv   5ddb             if (OVF == 0) goto 5ddb;
5dd7: d6,09               jge   5de2             if (R3a >= 0) goto 5de2;
5dd9: 20,0f               sjmp  5dea             goto 5dea;

5ddb: de,08               jlt   5de5             if (R3a < 0) goto 5de5;
5ddd: 88,34,3a            cmpw  R3a,R34          
5de0: da,0b               jle   5ded             if ((uns) R3a < R34)  {
#
5de2: a0,34,3a            ldw   R3a,R34          R3a = R34;
#
5de5: 88,36,3a            cmpw  R3a,R36          
5de8: d6,03               jge   5ded             if (R3a < R36)  {
#
5dea: a0,36,3a            ldw   R3a,R36          R3a = R36; } }
#
5ded: c3,72,d4,3a         stw   R3a,[R72+d4]     IPSIBR = R3a;
5df1: a0,3e,32            ldw   R32,R3e          R32 = R3e;                        # R32 = DEBYMA_FM
5df4: 4d,ef,00,3e,34      ml3w  R34,R3e,ef       R37:R34 = R3f:R3e * 0xef;         # R34 = DEBYMA
5df9: af,74,80,3e         ldzbw R3e,[R74+80]     R3e = (uns)BP;                    # BP - barometric pressure
5dfd: 8c,3e,34            divw  R34,R3e          R35:R34 = R37:R34 / BP;
5e00: 8b,f4,5a,34         cmpw  R34,[Rf4+5a]                                       # 9030 - DEBYCP
5e04: db,04               jgeu  5e0a             if (R34 > DEBYCP)  {
5e06: a3,f4,5a,34         ldw   R34,[Rf4+5a]     R34 = DEBYCP; }
#
5e0a: 8b,f4,5a,32         cmpw  R32,[Rf4+5a]
5e0e: db,04               jgeu  5e14             if (R32 > DEBYCP)  {
#
5e10: a3,f4,5a,32         ldw   R32,[Rf4+5a]     R32 = DEBYCP; }
#
5e14: c3,74,e4,32         stw   R32,[R74+e4]     DEBYMA_FM = R32;
5e18: 45,80,02,f4,32      ad3w  R32,Rf4,280      R32 = FN800;                      # Airflow vs. duty cycle
5e1d: ef,ec,d7            call  360c             UUWordLu();
5e20: a0,38,40            ldw   R40,R38          R40 = R38;                        # R40 = FN800(DEBYMA)
5e23: af,fe,46,38         ldzbw R38,[Rfe+46]     R38 = (uns)V820A;
5e27: 3d,2a,0c            jb    B5,R2a,5e36      if (RUNNING == 0)  {              # Not in KOER self test mode
5e2a: a3,74,de,34         ldw   R34,[R74+de]     R34 = LOAD;                       # engine load (VE)
5e2e: 45,c4,02,f4,32      ad3w  R32,Rf4,2c4      R32 = FN820B;                     # Load vs. ISC duty cycle multiplier
5e33: ef,d6,d7            call  360c             UUWordLu(); }
#
5e36: 09,08,38            shlw  R38,8            R38 *= 100;
5e39: 6c,40,38            ml2w  R38,R40          R3b:R38 = R39:R38 * R41:R40;
5e3c: 0d,01,38            shldw R38,1            R3b:R38 *= 2;
5e3f: db,06               jc    5e47             if ((uns) R38 >= 0) goto 5e47;
5e41: 89,00,80,3a         cmpw  R3a,8000         
5e45: d1,04               jleu  5e4b             if ((uns) R3a > 8000 )  {
#
5e47: a1,00,80,3a         ldw   R3a,8000         R3a = 8000; }
#
5e4b: c0,b8,3a            stw   R3a,Rb8          ISCDTY = R3a;                     # *** Z_ISCSW patches this to load from R0 ***
5e4e: 99,01,1e            cmpb  R1e,1            
5e51: d7,70               jne   5ec3             if (R1e != 1) return;
5e53: b3,72,c6,38         ldb   R38,[R72+c6]     R38 = ISCTMR;                     # 146 timer - ISCTMR
5e57: 9b,f4,70,38         cmpb  R38,[Rf4+70]     
5e5b: d3,66               jltu  5ec3             if ((uns) R38 < UPDISC) return;
5e5d: 3f,26,63            jb    B7,R26,5ec3      if (HCAMFG == 1) return;
5e60: a3,72,d4,3c         ldw   R3c,[R72+d4]     R3c = IPSIBR;
5e64: 88,00,3c            cmpw  R3c,R0           
5e67: df,5a               je    5ec3             if (R3c == 0) return;
5e69: 3f,28,57            jb    B7,R28,5ec3      if (KAM_ERROR == 1) return;
5e6c: af,72,eb,32         ldzbw R32,[R72+eb]     R32 = (uns)ISFLAG;                
5e70: 09,01,32            shlw  R32,1            R32 *= 2;                         # index to word offset
5e73: a3,33,e4,07,38      ldw   R38,[R32+7e4]    R38 = [R32+ISCKAM0];              # Get ISCKAM cell for this idle state
5e78: af,f4,71,3a         ldzbw R3a,[Rf4+71]     R3a = (uns)UPDATM;                # 9047 - UPDATM
5e7c: 88,3a,1c            cmpw  R1c,R3a          
5e7f: d3,42               jltu  5ec3             if ((uns) R1c < R3a) return;
5e81: c3,72,e0,00         stw   R0,[R72+e0]      IBGPSI = 0;                       # 160 - IBGPSI
5e85: a3,01,ec,07,34      ldw   R34,[R0+7ec]     R34 = ISKSUM;                     # KAM Table 2 checksum
5e8a: 88,00,3c            cmpw  R3c,R0           
5e8d: d2,14               jgt   5ea3             if (R3c > 0) goto 5ea3;
5e8f: 8b,f4,56,38         cmpw  R38,[Rf4+56]                                       # 902C - PSIBRN
5e93: da,2e               jle   5ec3             if (R38 <= PSIBRN) return;
5e95: 05,38               decw  R38              R38--;
5e97: 05,34               decw  R34              R34--;                            # CkSum
5e99: 8b,f4,54,3c         cmpw  R3c,[Rf4+54]                                       # 902A - PSIBR M
5e9d: d6,16               jge   5eb5             if (R3c < PSIBRM)  {
5e9f: 07,3c               incw  R3c              R3c++;
5ea1: 20,12               sjmp  5eb5             goto 5eb5;
#
5ea3: 8b,f4,54,38         cmpw  R38,[Rf4+54]                                       # 902A - PSIBR M
5ea7: d6,1a               jge   5ec3             if (R38 >= PSIBRM) return;
5ea9: 07,38               incw  R38              R38++;
5eab: 07,34               incw  R34              R34++;                            # CkSum
5ead: 8b,f4,56,3c         cmpw  R3c,[Rf4+56]                                       # 902C - PSIBRN
5eb1: da,02               jle   5eb5             if ((uns) R3c < PSIBRN)  {
5eb3: 05,3c               decw  R3c              R3c--; } }
#
5eb5: c3,33,e4,07,38      stw   R38,[R32+7e4]    [R32+ISCKAM0] = R38;              # ISCKAMOL
5eba: c3,72,d4,3c         stw   R3c,[R72+d4]     IPSIBR = R3c;                     # 154 IPSIBR
5ebe: c3,01,ec,07,34      stw   R34,[R0+7ec]     ISKSUM = R34; }                   # KAM Table 2 checksum ISKSUM
#
5ec3: f0                  ret                    return;


#################################################################
# Tasklist Routine at 2151,
# Routine offset 44 (normal operation)
# Routine offset 96 (KOER self-test)
# Vehicle Speed Control checks VBAT
#################################################################

  Upd_VSC:
5ec4: b1,02,30            ldb   R30,2            R30 = 2;
5ec7: 9b,f2,47,30         cmpb  R30,[Rf2+47]                                       # VSTYPE = 1 on A9L
5ecb: d7,0a               jne   5ed7             if (2 != VSTYPE) goto 5ed7;
5ecd: b3,74,93,30         ldb   R30,[R74+93]     R30 = VBAT;                       # 211 Battery Voltage Level * 16
5ed1: 9b,f2,45,30         cmpb  R30,[Rf2+45]                                       # LOWBAT
5ed5: d9,07               jgtu  5ede             if ((uns) VBAT <= LOWBAT) {       # jmp battery voltage > ROM limit
#
# No VSC or battery voltage insufficient
5ed7: b1,80,b5            ldb   Rb5,80           Vsc_switches = 80;                # SCCS force OFF_BUT only
5eda: 11,a0               clrb  Ra0              Vsc_states = 0;                   # SCCS state clear all
5edc: 20,02               sjmp  5ee0             goto 5ee0; }                      # Skip updating switches
#
# Battery voltage is OK
5ede: 28,07               scall 5ee7             Upd_SCCS();                       # Update Vehicle Speed Control(VSC)SCCS
#
#
5ee0: 28,8f               scall 5f71             Sub32();
5ee2: 29,a3               scall 6087             Sub33();
5ee4: 29,e9               scall 60cf             Sub34();
5ee6: f0                  ret                    return;


#################################################################
# Self-test Tasklist Routine at 2151, routine offset 6A (KOEO self-test)
# Also called as subr of Upd_VSC
# Read Cruise control buttons (SCCS)
# Update Vehicle Speed Control(VSC)
# set VSC bits in RB5 & RA0 based on ABS voltage **CHANGE** on AD channel 4 (SCCS)
#################################################################

  Upd_SCCS:
5ee7: a3,72,98,38         ldw   R38,[R72+98]     R38 = IVSCCS;                     # AD channel 4 118 Cruise control buttons - Vehicle Speed Control Command Switch
5eeb: 4b,76,32,38,3a      sb3w  R3a,R38,[R76+32] R3a = R38 - IVSCCS_LST;           # difference to old value of buttons
5ef0: db,02               jc    5ef4             if (R3a < 0)  {
5ef2: 03,3a               negw  R3a              R3a = -R3a; }                     # ABS difference
#
5ef4: 8b,f2,12,3a         cmpw  R3a,[Rf2+12]                                       # 8E6C - Min change in IVSCCS to reset the debounce timer
5ef8: d1,0c               jleu  5f06             if ((uns) R3a > DEBAMP )  {
5efa: c3,76,32,38         stw   R38,[R76+32]     IVSCCS_LST = R38;                 # 3AC IVSCCS LST - Previous valid SCCS input
5efe: a3,f2,30,3a         ldw   R3a,[Rf2+30]     R3a = DEBTIM;                     # 8E8A - DEBTIM - Debounce time delay, seconds
5f02: c3,74,2a,3a         stw   R3a,[R74+2a]     DEBTMR = R3a; }                   # 2A8 timer? DEBOUNCE timer
#
5f06: 8b,74,2a,00         cmpw  R0,[R74+2a]                                        # zero 2A8 timer? DEBOUNCE timer
5f0a: d7,04               jne   5f10             if (0 == DEBTMR)  {
5f0c: c3,74,36,38         stw   R38,[R74+36]     VSCCS = R38; }                    # input, debounced counts
#
5f10: a3,74,36,38         ldw   R38,[R74+36]     R38 = VSCCS;
5f14: 71,02,b5            an2b  Rb5,2            B0_Vsc_switches = 0;
                                                 B2_Vsc_switches = 0;
                                                 RESUM_BUT = 0;
                                                 ACCEL_BUT = 0;
                                                 COAST_BUT = 0;
                                                 ON_STATE = 0;
                                                 OFF_BUT = 0;
#
# Interpret cruise control switch reading
# GUFB p. 15-10
#
5f17: 8b,f2,14,38         cmpw  R38,[Rf2+14]                                       # 8E6E - HI OFF - Input VSC command Switch input range, counts
5f1b: db,04               jgeu  5f21             if ((uns) R38 < HI_OFF)  {
5f1d: 91,80,b5            orb   Rb5,80           OFF_BUT = 1;                      # set RB5 bit 7 OFF BUTTON
5f20: f0                  ret                    return; }
#
5f21: 8b,f2,16,38         cmpw  R38,[Rf2+16]                                       # 8E70 - LOW ON - Input VSCCS input range, counts.
5f25: d1,04               jleu  5f2b             if ((uns) R38 > LOW_ON )  {
5f27: 91,80,a0            orb   Ra0,80           ON_STATE = 1;                     # set RA0 bit 7 ON STATE
5f2a: f0                  ret                    return; }
#
5f2b: 8b,f2,18,38         cmpw  R38,[Rf2+18]                                       # 8E72 - LCOAST - Input VSCCS input range, counts.
5f2f: d1,0a               jleu  5f3b             if ((uns) R38 > LCOAST )  {
5f31: 8b,f2,1a,38         cmpw  R38,[Rf2+1a]                                       # 8E74 - HCOAST - Input VSCCS input range, counts.
5f35: db,04               jgeu  5f3b             if (R38 > HCOAST)  {
5f37: 91,20,b5            orb   Rb5,20           COAST_BUT = 1;                    # set RB5 bit 5 COAST BUTTON
5f3a: f0                  ret                    return; } }
#
5f3b: 8b,f2,1c,38         cmpw  R38,[Rf2+1c]                                       # 8E76 - LACCEL - Input VSCCS input range, counts.
5f3f: d1,0a               jleu  5f4b             if ((uns) R38 > LACCEL )  {
5f41: 8b,f2,1e,38         cmpw  R38,[Rf2+1e]                                       # 8E78 - HACCEL - Input VSCCS input range, counts.
5f45: db,04               jgeu  5f4b             if ((uns) R38 < HACCEL)  {
5f47: 91,10,b5            orb   Rb5,10           ACCEL_BUT = 1;                    # set RB5 bit 4 ACCEL BUTTON
5f4a: f0                  ret                    return; } }
#
5f4b: 8b,f2,20,38         cmpw  R38,[Rf2+20]                                       # 8E7A - LRESUM - Input VSCCS input range, counts.
5f4f: d1,0a               jleu  5f5b             if ((uns) R38 > LRESUM )  {
5f51: 8b,f2,22,38         cmpw  R38,[Rf2+22]                                       # 8E7C - HRESUM - Input VSCCS input range, counts.
5f55: db,04               jgeu  5f5b             if (R38 > HRESUM)  {
5f57: 91,08,b5            orb   Rb5,8            RESUM_BUT = 1;                    # set RB5 bit 3 RESUME BUTTON
5f5a: f0                  ret                    return; } }
#
5f5b: 8b,f2,24,38         cmpw  R38,[Rf2+24]                                       # 8E7E - LOHOLD - Input VSCCS input range, counts.
5f5f: d1,09               jleu  5f6a             if ((uns) R38 > LOHOLD )  {
5f61: 8b,f2,26,38         cmpw  R38,[Rf2+26]                                       # 8E80 - HIHOLD - Input VSCCS input range, counts.
5f65: db,03               jgeu  5f6a             if (R38 > HIHOLD)  {
5f67: 11,b5               clrb  Rb5              Vsc_switches = 0;                 # clr all bits in RB5
5f69: f0                  ret                    return; } }
#
5f6a: 91,02,b5            orb   Rb5,2            VSCCS_ERROR = 1;                  # set RB5 bit 1 button voltage range error
5f6d: 71,7f,a0            an2b  Ra0,7f           ON_STATE = 0;                     # clr RA0 bit 7 clr ON state
5f70: f0                  ret                    return;

################################################################
#
# Called from Upd_VSC
#
  Sub32:
5f71: 30,2a,0a            jnb   B0,R2a,5f7e      if (VSCDT == 1)  {                # jump if not VIP mode flag : VSCDT
5f74: a0,ae,3c            ldw   R3c,Rae          R3c = N;
5f77: 09,02,3c            shlw  R3c,2            R3c *= 4;                         # x4
5f7a: c3,74,2e,3c         stw   R3c,[R74+2e]     MPH = R3c; }                      # SCCS vehicle speed in MPH filtered 2
#
5f7e: a3,74,2e,3c         ldw   R3c,[R74+2e]     R3c = MPH;                        # SCCS vehicle speed in MPH filtered 2
5f82: 37,a0,03            jnb   B7,Ra0,5f88      if (ON_STATE == 0) goto 5f88;     # VSC on state
5f85: 37,b5,07            jnb   B7,Rb5,5f8f      if (OFF_BUT == 1)  {              # SCCS OFF button pressed, or not equipped w/ VSC
#
5f88: 11,a0               clrb  Ra0              Vsc_states = 0;
5f8a: c3,74,30,00         stw   R0,[R74+30]      RES_SPEED = 0;
5f8e: f0                  ret                    return; }
#
5f8f: 38,2a,50            jb    B0,R2a,5fe2      if (VSCDT == 1) goto 5fe2;        # jump if VIP mode flag : VSCDT
5f92: a3,f2,32,38         ldw   R38,[Rf2+32]     R38 = MINVSP;
5f96: 88,38,3c            cmpw  R3c,R38          
5f99: db,03               jgeu  5f9e             if (R3c > R38)  {
5f9b: 91,20,c4            orb   Rc4,20           Vscq1 = 1; }
5f9e: 67,f2,3a,38         ad2w  R38,[Rf2+3a]     R38 += MPHH;
5fa2: db,08               jc    5fac             if (R38 > 0)  {
5fa4: 88,38,3c            cmpw  R3c,R38          
5fa7: d1,03               jleu  5fac             if ((uns) R3c > R38 )  {
5fa9: 71,df,c4            an2b  Rc4,df           Vscq1 = 0; } }
5fac: 31,b5,03            jnb   B1,Rb5,5fb2      if (VSCCS_ERROR == 1)  {          # SCCS Button voltage range error
5faf: 91,20,c4            orb   Rc4,20           Vscq1 = 1; }
5fb2: a3,f2,36,38         ldw   R38,[Rf2+36]     R38 = VSNMAX;
5fb6: 88,ae,38            cmpw  R38,Rae          
5fb9: db,03               jgeu  5fbe             if (R38 > N)  {
5fbb: 91,20,c4            orb   Rc4,20           Vscq1 = 1; }
5fbe: 3d,c4,1d            jb    B5,Rc4,5fde      if (Vscq1 == 1) goto 5fde;
5fc1: a3,f2,34,38         ldw   R38,[Rf2+34]     R38 = MAXVSP;
5fc5: 88,38,3c            cmpw  R3c,R38          
5fc8: d1,03               jleu  5fcd             if ((uns) R3c > R38 )  {
5fca: 91,10,c4            orb   Rc4,10           Vscq2 = 1; }
5fcd: 6b,f2,3a,38         sb2w  R38,[Rf2+3a]     R38 -= MPHH;
5fd1: d3,08               jltu  5fdb             if ((uns) R38 >= 0)  {
5fd3: 88,38,3c            cmpw  R3c,R38          
5fd6: db,03               jgeu  5fdb             if (R3c > R38)  {
5fd8: 71,ef,c4            an2b  Rc4,ef           Vscq2 = 0; } }
5fdb: 34,c4,07            jnb   B4,Rc4,5fe5      if (Vscq2 == 0) goto 5fe5;
5fde: 71,a0,a0            an2b  Ra0,a0           VSC_PULSE = 0;
                                                 ACC_REQ = 0;
                                                 HOLD_STATE = 0;
                                                 RESUM_STATE = 0;
                                                 ACCEL_STATE = 0;
                                                 COAST_STATE = 0;
5fe1: f0                  ret                    return;
#
# Come here in KOER self test mode
5fe2: 31,ea,19            jnb   B1,Rea,5ffe      if (BIFLG == 1)  {                # BIFLG = If equal to 1, Brake is on.
5fe5: 39,ea,09            jb    B1,Rea,5ff1      if (BIFLG == 1) goto 5ff1;        # BIFLG = If equal to 1, Brake is on.
5fe8: 3f,e7,13            jb    B7,Re7,5ffe      if (NDSFLG == 0)  {
5feb: 9b,fe,02,00         cmpb  R0,[Rfe+2]                                         # 9E5C
5fef: df,0d               je    5ffe             if (0 != TRLOAD)  {
5ff1: b1,a0,a0            ldb   Ra0,a0           Vsc_states = a0;
5ff4: 51,38,b5,00         an3b  R0,Rb5,38                                          # ck SCCS buttons: RESUME, COAST, ACCEL
5ff8: df,03               je    5ffd             if (Vsc_switches & 38 == 0) return;
5ffa: 91,02,b5            orb   Rb5,2            VSCCS_ERROR = 1; }                # set SCCS button Range error
5ffd: f0                  ret                    return; } } }
#
5ffe: 35,b5,05            jnb   B5,Rb5,6006      if (COAST_BUT == 1)  {            # SCCS COAST button
6001: b1,c0,a0            ldb   Ra0,c0           Vsc_states = c0;
6004: 20,06               sjmp  600c             goto 600c; }
#
6006: 36,a0,0c            jnb   B6,Ra0,6015      if (COAST_STATE == 1)  {
6009: b1,85,a0            ldb   Ra0,85           Vsc_states = 85;
600c: c3,74,32,3c         stw   R3c,[R74+32]     SET_SPEED = R3c;
6010: c3,74,30,3c         stw   R3c,[R74+30]     RES_SPEED = R3c;
6014: f0                  ret                    return; }
#
6015: 34,b5,0c            jnb   B4,Rb5,6024      if (ACCEL_BUT == 1)  {            # SCCS ACCEL button
6018: 3c,a0,04            jb    B4,Ra0,601f      if (ACCEL_STATE == 0)  {
601b: c3,74,32,3c         stw   R3c,[R74+32]     SET_SPEED = R3c; }
#
601f: b1,91,a0            ldb   Ra0,91           Vsc_states = 91;
6022: 20,0a               sjmp  602e             goto 602e; }
#
6024: 34,a0,0c            jnb   B4,Ra0,6033      if (ACCEL_STATE == 1)  {
6027: b1,85,a0            ldb   Ra0,85           Vsc_states = 85;
602a: c3,74,32,3c         stw   R3c,[R74+32]     SET_SPEED = R3c;
602e: c3,74,30,3c         stw   R3c,[R74+30]     RES_SPEED = R3c;
6032: f0                  ret                    return; }
#
6033: 3b,a0,1b            jb    B3,Ra0,6051      if (RESUM_STATE == 0)  {
6036: 3d,d9,10            jb    B5,Rd9,6049      if (Vvsfl1 == 1) goto 6049;
6039: 33,b5,15            jnb   B3,Rb5,6051      if (RESUM_BUT == 1)  {            # SCCS RESUME button
603c: 35,a0,12            jnb   B5,Ra0,6051      if (BRAKE_STATE == 1)  {
603f: a3,74,30,38         ldw   R38,[R74+30]     R38 = RES_SPEED;
6043: 8b,f2,32,38         cmpw  R38,[Rf2+32]     
6047: d1,08               jleu  6051             if ((uns) R38 > MINVSP )  {
#
6049: b1,89,a0            ldb   Ra0,89           Vsc_states = 89;
604c: c3,74,32,3c         stw   R3c,[R74+32]     SET_SPEED = R3c;
6050: f0                  ret                    return; } } } }
#
6051: 33,a0,0a            jnb   B3,Ra0,605e      if (RESUM_STATE == 1)  {
6054: 8b,74,30,3c         cmpw  R3c,[R74+30]     
6058: db,04               jgeu  605e             if (R3c > RES_SPEED)  {
605a: b1,8b,a0            ldb   Ra0,8b           Vsc_states = 8b;
605d: f0                  ret                    return; } }
#
605e: 33,a0,0c            jnb   B3,Ra0,606d      if (RESUM_STATE == 1)  {
6061: b1,85,a0            ldb   Ra0,85           Vsc_states = 85;
6064: a3,74,30,38         ldw   R38,[R74+30]     R38 = RES_SPEED;
6068: c3,74,32,38         stw   R38,[R74+32]     SET_SPEED = R38;
606c: f0                  ret                    return; }
#
606d: 32,a0,16            jnb   B2,Ra0,6086      if (HOLD_STATE == 1)  {
6070: a3,74,32,38         ldw   R38,[R74+32]     R38 = SET_SPEED;
6074: 68,3c,38            sb2w  R38,R3c          R38 -= R3c;
6077: d3,06               jltu  607f             if ((uns) R38 < 0) goto 607f;
6079: 8b,f2,38,38         cmpw  R38,[Rf2+38]     
607d: d9,04               jgtu  6083             if ((uns) R38 <= MPHDED)  {
#
607f: 91,01,a0            orb   Ra0,1            VSC_PULSE = 1;
6082: f0                  ret                    return; }
#
6083: b1,a0,a0            ldb   Ra0,a0           Vsc_states = a0; }
#
6086: f0                  ret                    return;


#
# Called from Upd_VSC
#
  Sub33:
6087: 3c,b5,03            jb    B4,Rb5,608d      if (ACCEL_BUT == 1) goto 608d;    # SCCS ACCEL button
608a: 31,a0,3d            jnb   B1,Ra0,60ca      if (ACC_REQ == 1)  {
#
608d: 4b,f2,3c,3c,32      sb3w  R32,R3c,[Rf2+3c] R32 = R3c - ACLDED;
6092: db,03               jc    6097             if (R32 > 0)  {
6094: a0,00,32            ldw   R32,R0           R32 = 0; }
#
6097: 8b,74,32,32         cmpw  R32,[R74+32]     
609b: d1,06               jleu  60a3             if ((uns) R32 > SET_SPEED )  {
609d: c3,74,32,3c         stw   R3c,[R74+32]     SET_SPEED = R3c;
60a1: 20,27               sjmp  60ca             goto 60ca; }
#
60a3: 4b,74,2c,06,38      sb3w  R38,R6,[R74+2c]  R38 = IO_Timer - Ltime;
60a8: 30,2a,07            jnb   B0,R2a,60b2      if (VSCDT == 1)  {                 # jump if not VIP mode flag : VSCDT
60ab: a3,f3,64,01,30      ldw   R30,[Rf2+164]    R30 = Vacrr;
60b0: 20,04               sjmp  60b6             goto 60b6; }
#
60b2: a3,f2,3e,30         ldw   R30,[Rf2+3e]     R30 = ACLINC;
#
60b6: 6d,44,28,38         ml2w  R38,2844         R3b:R38 = R39:R38 * 0x2844;
60ba: 6c,3a,30            ml2w  R30,R3a          R33:R30 = ACLINC * R3b:R3a;
60bd: 67,74,32,32         ad2w  R32,[R74+32]     R32 += SET_SPEED;
60c1: d3,03               jnc   60c6             if ((uns) R32 >= 0)  {
60c3: bd,ff,32            ldsbw R32,ff           R32 = 0xffff; }
#
60c6: c3,74,32,32         stw   R32,[R74+32]     SET_SPEED = R32; }
#
60ca: c3,74,2c,06         stw   R6,[R74+2c]      Ltime = IO_Timer;
60ce: f0                  ret                    return;

#
# Called from Upd_VSC
#
  Sub34:
60cf: 30,2a,1d            jnb   B0,R2a,60ef      if (VSCDT == 1)  {                 # jump if not VIP mode flag : VSCDT
60d2: 3d,d9,04            jb    B5,Rd9,60d9      if (Vvsfl1 == 0)  {
60d5: b1,ff,9b            ldb   R9b,ff           Vsc_count = ff;
60d8: f0                  ret                    return; }
#
60d9: a3,f3,5a,01,14      ldw   R14,[Rf2+15a]    R14 = Vstgn;
60de: a3,f3,5c,01,18      ldw   R18,[Rf2+15c]    R18 = Vvhgn;
60e3: a3,f3,5e,01,38      ldw   R38,[Rf2+15e]    R38 = Vtpgn;
60e8: a3,f3,70,01,42      ldw   R42,[Rf2+170]    R42 = Vdcbia;
60ed: 20,10               sjmp  60ff             goto 60ff; }
#
# Normal running
60ef: a3,f2,2a,14         ldw   R14,[Rf2+2a]     R14 = SETGN;
60f3: a3,f2,2c,18         ldw   R18,[Rf2+2c]     R18 = VEHGN;
60f7: a3,f2,2e,38         ldw   R38,[Rf2+2e]     R38 = TAPGN;
60fb: a3,f2,28,42         ldw   R42,[Rf2+28]     R42 = DCBIAS;
#
60ff: 30,a0,21            jnb   B0,Ra0,6123      if (VSC_PULSE == 0) goto 6123;
6102: 6f,74,32,14         ml2w  R14,[R74+32]     R17:R14 = R15:R14 * SET_SPEED;
6106: 64,42,16            ad2w  R16,R42          R16 += R42;
6109: 6f,74,2e,18         ml2w  R18,[R74+2e]     R1b:R18 = R19:R18 * MPH;          # SCCS vehicle speed in MPH filtered 2
610d: 68,1a,16            sb2w  R16,R1a          R16 -= R1a;
6110: d3,11               jltu  6123             if ((uns) R16 < 0) goto 6123;
6112: 4b,72,a6,aa,18      sb3w  R18,Raa,[R72+a6] R18 = TP - RATCH;                 # RAA is Throttle position, 126 - RATCH=Closed TP
6117: db,02               jc    611b             if (R18 > 0)  {
6119: 01,18               clrw  R18              R18 = 0; }
#
611b: 6c,38,18            ml2w  R18,R38          R1b:R18 = R19:R18 * R39:R38;
611e: 68,1a,16            sb2w  R16,R1a          R16 -= R1a;
6121: db,02               jc    6125             if (R16 > 0)  {
# Jump here from 60ff, 6110
6123: 01,16               clrw  R16              R16 = 0; }
#
6125: a0,16,14            ldw   R14,R16          R14 = R16;
6128: 08,01,16            shrw  R16,1            R16 /= 2;
612b: c3,74,38,16         stw   R16,[R74+38]     VSC_ERROR = R16;
612f: 11,16               clrb  R16              R16 = 0;
6131: 6b,f2,40,14         sb2w  R14,[Rf2+40]     R14 -= HLDREF;
6135: d9,04               jgtu  613b             if ((uns) R14 <= 0)  {
6137: 03,14               negw  R14              R14 = -R14;
6139: 17,16               incb  R16              R16++; }
#
613b: 89,80,00,14         cmpw  R14,80           
613f: d1,03               jleu  6144             if ((uns) R14 > 80 )  {
6141: b1,80,14            ldb   R14,80           R14 = 80; }
#
6144: 9b,f2,44,14         cmpb  R14,[Rf2+44]     
6148: d9,02               jgtu  614c             if ((uns) R14 <= HLDRNG)  {
614a: 11,14               clrb  R14              R14 = 0; }
#
614c: c7,74,3c,14         stb   R14,[R74+3c]     Vsc_dc = R14;                     # set 2BB - timer?
6150: a1,d0,07,38         ldw   R38,7d0          R38 = 7d0;
6154: 9f,f2,46,38         divb  R38,[Rf2+46]     R38 /= VSCFRQ;
6158: 5c,38,14,18         ml3b  R18,R14,R38      R18 = R14 * R38;
615c: 65,80,00,18         ad2w  R18,80           R18 += 80;
6160: 30,38,02            jnb   B0,R38,6165      if (B0_R38 == 1)  {
6163: 17,38               incb  R38              R38++; }
#
6165: 18,01,38            shrb  R38,1            R38 /= 2;
6168: fa                  di                     disable ints;
6169: ff                  nop                    
616a: 30,16,05            jnb   B0,R16,6172      if (Vsc_flg1 == 0) goto 6172;
616d: 3e,c4,05            jb    B6,Rc4,6175      if (Vsc_vac_active == 1) goto 6175;
6170: 20,12               sjmp  6184             goto 6184;
#
6172: 3e,c4,0f            jb    B6,Rc4,6184      if (Vsc_vac_active == 0)  {
#
6175: 95,40,c4            xorb  Rc4,40           Vsc_vac_active ^= 1;
6178: 71,fe,46            an2b  R46,fe           SCVAC = 0;                        # LSO output line 0 OFF (Speed Control Vacuum)
617b: 91,10,46            orb   R46,10           SCVNT = 1;                        # LSO output line 4 ON (Speed Control Vent)
617e: 71,f7,c4            an2b  Rc4,f7           Vsc_state = 0;
6181: b1,01,9b            ldb   R9b,1            Vsc_count = 1; }
#
6184: c7,74,3b,19         stb   R19,[R74+3b]     VSC_ON_COUNT = R19;
6188: 78,19,38            sb2b  R38,R19          R38 -= R19;
618b: c7,74,3a,38         stb   R38,[R74+3a]     VSC_OFF_COUNT = R38;
618f: fb                  ei                     enable ints;
6190: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 3A
# Thermactor logic
# GUFB pp. 12-7
#################################################################

  Upd_air_mgt:
#
# Universal CHKAIR logic
# GUFB p. 12-7
#
6191: b3,f6,17,38         ldb   R38,[Rf6+17]     R38 = CTBYS;
6195: b3,f6,16,39         ldb   R39,[Rf6+16]     R39 = ATBYS;
6199: 98,38,b0            cmpb  Rb0,R38          
619c: da,0a               jle   61a8             if ((uns) ECT > CTBYS)  {
619e: 98,39,b1            cmpb  Rb1,R39                                            # RB1 = ACT (ACT = RB1 * 4)
61a1: da,05               jle   61a8             if ((uns) ACT > ATBYS)  {
61a3: 91,08,29            orb   R29,8            Taq1 = 1;                         # Set ECT/ACT flag
61a6: 20,1f               sjmp  61c7             goto 61c7; } }
# 
61a8: 7b,f6,18,38         sb2b  R38,[Rf6+18]     R38 -= CTBYSH;
61ac: d5,03               jnv   61b1             if (OVF == 1)  {
61ae: b1,80,38            ldb   R38,80           R38 = 80; }
#
61b1: 98,38,b0            cmpb  Rb0,R38          
61b4: de,0e               jlt   61c4             if (ECT < CTBYS - CTBYSH) goto 61c4;
61b6: 7b,f6,18,39         sb2b  R39,[Rf6+18]     R39 -= CTBYSH;
61ba: d5,03               jnv   61bf             if (OVF == 1)  {
61bc: b1,80,39            ldb   R39,80           R39 = 80; }
61bf: 98,39,b1            cmpb  Rb1,R39                                            # RB1 = ACT (ACT = RB1 * 4)
61c2: d6,03               jge   61c7             if (ACT < ATBYS - CTBYSH)  {
#
61c4: 71,f7,29            an2b  R29,f7           Taq1 = 0; }                       # Clear ECT/ACT flag
#
61c7: 91,80,25            orb   R25,80           Chkair_flag = 1;                  # Don't force open loop fuel (yet)
61ca: 3b,29,1f            jb    B3,R29,61ec      if (Taq1 == 1) goto 61ec;
61cd: 31,ed,11            jnb   B1,Red,61e1      if (LEGOFG1 == 0) goto 61e1;
61d0: b3,fe,16,30         ldb   R30,[Rfe+16]     R30 = NUMEGO;                     # 9E70 no of HEGOs
61d4: 99,01,30            cmpb  R30,1            
61d7: df,13               je    61ec             if (R30 == 1) goto 61ec;
61d9: 99,02,30            cmpb  R30,2            
61dc: d7,03               jne   61e1             if (R30 != 2) goto 61e1;
61de: 38,ed,0b            jb    B0,Red,61ec      if (LEGOFG2 == 1) goto 61ec;
#
61e1: 99,01,d0            cmpb  Rd0,1            
61e4: d7,09               jne   61ef             if (APT == 1)  {                  # WOT
61e6: 9b,f6,15,cb         cmpb  Rcb,[Rf6+15]                                       # AWOTMR
61ea: d3,03               jltu  61ef             if ((uns) AWOTMR >= BYPWOT)  {
#
61ec: 71,7f,25            an2b  R25,7f           Chkair_flag = 0; } }              # Force open loop fuel
#
# Thermactor Air Control logic
# GUFB p. 12-8
#
61ef: b3,fe,0b,30         ldb   R30,[Rfe+b]      R30 = THRMHP;
61f3: 99,01,30            cmpb  R30,1            
61f6: df,0c               je    6204             if (R30 != 1)  {                  # No thermactor present
#
61f8: 91,40,25            orb   R25,40           CHKAIR = 1;                       # CHKAIR = Chkair_flag
61fb: 3f,25,03            jb    B7,R25,6201      if (Chkair_flag == 0)  {
61fe: 71,bf,25            an2b  R25,bf           CHKAIR = 0; }
6201: e7,b0,00            jump  62b4             return; }
#
# THRMHP = 1 Thermactor present
#
6204: 71,7f,ca            an2b  Rca,7f           USAFLG = 0;
6207: 51,b8,c5,30         an3b  R30,Rc5,b8       R30 = Fmem_flags & b8;            # test bits 7 (CFMFLG), 5 (AFMFLG), 4 (TFMFLG), 3 (MFMFLG)
620b: df,08               je    6215             if (R30 != 0)  {
# Some sensor(s) failed - bypass air
620d: 71,ef,47            an2b  R47,ef           TAD = 0;                          # R47 bit 4 OFF (Air Management 2)
6210: 71,f7,47            an2b  R47,f7           TAB = 0;                         # R47 bit 3 OFF (Air Management 1)
6213: 27,e3               sjmp  61f8             goto 61f8; }
#
6215: a3,f6,2c,38         ldw   R38,[Rf6+2c]     R38 = DNLOD;
6219: 4b,f6,2e,38,3a      sb3w  R3a,R38,[Rf6+2e] R3a = R38 - DNLODH;
621e: db,02               jc    6222             if (R3a > 0)  {
6220: 01,3a               clrw  R3a              R3a = 0; }                        # underflow - wrap to 0
#
6222: 8b,74,de,3a         cmpw  R3a,[R74+de]                                       # engine load (VE)
6226: d1,05               jleu  622d             if ((uns) DNLOD - DNLODH > LOAD)  {
6228: 91,02,29            orb   R29,2            Taq6 = 1;
622b: 20,09               sjmp  6236             goto 6236; }
#
622d: 8b,74,de,38         cmpw  R38,[R74+de]                                       # engine load (VE)
6231: db,03               jgeu  6236             if (DNLOD >= LOAD)  {
6233: 71,fd,29            an2b  R29,fd           Taq6 = 0; }
#
6236: 3f,a1,10            jb    B7,Ra1,6249      if (CRKFLG == 1) goto 6249;
6239: 37,25,0d            jnb   B7,R25,6249      if (Chkair_flag == 0) goto 6249;
#
# Thermactor Air "A" Logic
# GUFB p. 12-9
#
623c: 45,0e,00,f6,30      ad3w  R30,Rf6,e        R30 = &BYSTM3;
6241: ef,0b,d5            call  374f             Check_Timers();
6244: db,03               jc    6249             if ((uns) R30 >= 0) goto 6249;
6246: 32,e7,0b            jnb   B2,Re7,6254      if (HSPFLG == 1)  {
# Force open loop fuel
6249: 71,bf,25            an2b  R25,bf           CHKAIR = 0;
# Bypass air
624c: 71,ef,47            an2b  R47,ef           TAD = 0;                          # R47 bit 4 OFF (Air Management 2)
624f: 71,f7,47            an2b  R47,f7           TAB = 0;                          # R47 bit 3 OFF (Air Management 1)
6252: 20,60               sjmp  62b4             return; }
#
# Thermactor Air "B" Logic
# GUFB p. 12-9
#
6254: 45,26,00,f6,30      ad3w  R30,Rf6,26       R30 = &UPSTM3;
6259: ef,f3,d4            call  374f             Check_Timers();
625c: db,4a               jc    62a8             if (early) goto 62a8;            # upstream air 
625e: 9b,f6,1f,c8         cmpb  Rc8,[Rf6+1f]     
6262: d9,0b               jgtu  626f             if ((uns) ATMR1 > HMSTM) goto 626f;
6264: 99,01,d0            cmpb  Rd0,1            
6267: d7,06               jne   626f             if (APT != 1) goto 626f;         # jmp if not WOT
6269: 9b,f6,2b,cb         cmpb  Rcb,[Rf6+2b]
626d: d3,39               jltu  62a8             if ((uns) AWOTMR < UPSWOT) goto 62a8; # upstream air
#
626f: 33,eb,0a            jnb   B3,Reb,627c      if (CTAFLG == 0) goto 627c;
6272: b3,72,b8,38         ldb   R38,[R72+b8]     R38 = CTATMR;
6276: 9b,f6,1e,38         cmpb  R38,[Rf6+1e]     
627a: db,2c               jgeu  62a8             if ((uns) CTATMR >= CTARTM) goto 62a8; # upstream air
#
627c: 32,eb,10            jnb   B2,Reb,628f      if (HMTMR_On == 0) goto 628f;
627f: b3,72,b7,38         ldb   R38,[R72+b7]     R38 = HMTMR;
6283: 9b,f6,20,38         cmpb  R38,[Rf6+20]     
6287: d9,06               jgtu  628f             if ((uns) R38 > HMCTM) goto 628f;
6289: 9b,f6,1f,c8         cmpb  Rc8,[Rf6+1f]     
628d: d1,19               jleu  62a8             if ((uns) ATMR1 <= HMSTM) goto 62a8; # upstream air
#
628f: 91,40,25            orb   R25,40           CHKAIR = 1;
6292: 9b,f6,37,ce         cmpb  Rce,[Rf6+37]
6296: d9,b4               jgtu  624c             if ((uns) MFATMR > DMPDLY) goto 624c;
6298: 39,29,08            jb    B1,R29,62a3      if (Taq6 == 0)  {
629b: 9b,f6,30,cd         cmpb  Rcd,[Rf6+30]
629f: d1,02               jleu  62a3             if ((uns) NACTMR <= DNSTMI) goto 62a3;
62a1: 27,a9               sjmp  624c             goto 624c; }
# Downstream air
62a3: 71,ef,47            an2b  R47,ef           TAD = 0;                          # R47 bit 4 OFF (Air Management 2)
62a6: 20,09               sjmp  62b1             goto 62b1;
# Upstream air
62a8: 91,80,ca            orb   Rca,80           USAFLG = 1;
62ab: 71,bf,25            an2b  R25,bf           CHKAIR = 0;                       # Force open loop fuel
62ae: 91,10,47            orb   R47,10           TAD = 1;                          # R47 bit 4 ON (Air Management 2)
#
62b1: 91,08,47            orb   R47,8            TAB = 1;                          # R47 bit 3 ON (Air Management 1)
62b4: f0                  ret                    return;


#################################################################
# Tasklist Routine at 2151, routine offset 3C
#################################################################

  Upd_HiFan:
62b5: 9b,f6,39,00         cmpb  R0,[Rf6+39]                                        # 93E1 - ECADHP
62b9: df,79               je    6334             if (0 != EcadHP)  {               # return if h/w not present
62bb: 9b,f6,3a,b0         cmpb  Rb0,[Rf6+3a]                                       # ROM 93E2 - ECADECT
62bf: d6,05               jge   62c6             if (ECT < ECADECT)  {
62c1: 91,40,ca            orb   Rca,40           Ecadq1 = 1;                       # set ECADQ1
62c4: 20,09               sjmp  62cf             goto 62cf; }

62c6: 9b,f6,3d,b0         cmpb  Rb0,[Rf6+3d]                                       # ROM 93E5 - EDETHYS
62ca: da,03               jle   62cf             if ((uns) ECT < EDETHYS)  {
62cc: 71,bf,ca            an2b  Rca,bf           Ecadq1 = 0; }                     # clr ECADQ1

62cf: b3,74,21,42         ldb   R42,[R74+21]     R42 = N_BYTE;                     # 29F - N BYTE
62d3: 9b,f6,3b,42         cmpb  R42,[Rf6+3b]                                       # 93E3 - ECADN
62d7: d1,05               jleu  62de             if ((uns) N_BYTE > ECADN )  {
62d9: 91,20,ca            orb   Rca,20           Ecadq2 = 1;                       # set ECADQ2
62dc: 20,09               sjmp  62e7             goto 62e7; }

62de: 9b,f6,3e,42         cmpb  R42,[Rf6+3e]                                       # 93E6 - EDNHYS
62e2: db,03               jgeu  62e7             if ((uns) N_BYTE < EDNHYS)  {
62e4: 71,df,ca            an2b  Rca,df           Ecadq2 = 0; }                     # clr ECADQ2

62e7: b3,74,3f,30         ldb   R30,[R74+3f]     R30 = VSBAR_H;                    # 2BD - vehicle speed filtered(1) (MPH) 2BC is 8.8 format
62eb: 9b,f6,3c,30         cmpb  R30,[Rf6+3c]                                       # 93E4 - ECADVS
62ef: d1,05               jleu  62f6             if ((uns) VSBAR_H > ECADVS )  {
62f1: 91,10,ca            orb   Rca,10           Ecadq3 = 1;                       # set ECADQ3
62f4: 20,09               sjmp  62ff             goto 62ff; }

62f6: 9b,f6,3f,30         cmpb  R30,[Rf6+3f]                                       # 93E7 - EDVSHYS
62fa: db,03               jgeu  62ff             if ((uns) VSBAR < EDVSHYS)  {
62fc: 71,ef,ca            an2b  Rca,ef           Ecadq3 = 0; }                     # clr ECADQ3

62ff: 51,b8,c5,42         an3b  R42,Rc5,b8       R42 = Fmem_flags & b8;
6303: d7,2c               jne   6331             if (R42 == 0)  {
6305: b3,fe,0b,42         ldb   R42,[Rfe+b]      R42 = THRMHP;                     # 9E65 thermactor present switch = 1.0
6309: 99,01,42            cmpb  R42,1            
630c: d7,03               jne   6311             if (THRMHP != 1) goto 6311;       # jmp if no Thermactor present
630e: 37,ca,0f            jnb   B7,Rca,6320      if (USAFLG == 0) goto 6320;       # jmp if not USAFLG

# ECAD TIME/TEMP DELAY ("A" logic)
# GUFB p. 17-5
6311: 45,40,00,f6,30      ad3w  R30,Rf6,40       R30 = EDTM3;                      # 93E8 - EDTM3
6316: ef,36,d4            call  374f             Check_Timers();
6319: d3,16               jnc   6331             if ((uns) R30 >= 0)  {

631b: 98,42,00            cmpb  R0,R42           
631e: d7,11               jne   6331             if (0 == R42)  {
6320: 32,df,0e            jnb   B2,Rdf,6331      if (ECADI == 1)  {                 # jmp if not ECADI
6323: 36,ca,0b            jnb   B6,Rca,6331      if (Ecadq1 == 1)  {                # jmp if not ECADQ1
6326: 35,ca,08            jnb   B5,Rca,6331      if (Ecadq2 == 1)  {                # jmp if not ECADQ2
6329: 34,ca,05            jnb   B4,Rca,6331      if (Ecadq3 == 1)  {                # jmp if not ECADQ3
632c: 71,bf,47            an2b  R47,bf           Hi_fan = 0;                       # R47 bit 6 OFF (Fan)HI FAN
632f: 20,03               sjmp  6334             return; } } } } } } }

6331: 91,40,47            orb   R47,40           Hi_fan = 1; }                     # R47 bit 6 ON (Fan)HI FAN
6334: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 3E
# Update Canister Purge timing
# GUFB p. 11-5
#################################################################


  Upd_canpTm:
6335: b3,f6,45,14         ldb   R14,[Rf6+45]     R14 = CTPRG;
6339: 98,14,b0            cmpb  Rb0,R14          
633c: da,03               jle   6341             if ((uns) ECT < R14)  {
633e: 71,f7,ed            an2b  Red,f7           Hvq1 = 0; }
#
6341: 7b,f6,46,14         sb2b  R14,[Rf6+46]     R14 -= CTPRGH;
6345: 98,14,b0            cmpb  Rb0,R14          
6348: d6,03               jge   634d             if (ECT < R14)  {
634a: 91,08,ed            orb   Red,8            Hvq1 = 1; }
#
634d: 71,bf,e9            an2b  Re9,bf           CanPurgeOK = 0;
6350: 45,4e,00,f6,30      ad3w  R30,Rf6,4e       R30 = PRGTD3;                       # Canister purge hot startup delay time.
6355: ef,f7,d3            call  374f             Check_Timers();
6358: d3,02               jnc   635c             if ((uns) R30 < 0) goto 635c;
635a: 20,59               sjmp  63b5             goto 63b5;
#
635c: 33,ed,56            jnb   B3,Red,63b5      if (Hvq1 == 1)  {
635f: 9b,f6,48,cd         cmpb  Rcd,[Rf6+48]                                       # timer?
6363: d3,50               jltu  63b5             if ((uns) NACTMR >= EVTDOT)  {
6365: 32,ee,06            jnb   B2,Ree,636e      if (OLFLG == 0) goto 636e;
6368: 9b,f6,47,00         cmpb  R0,[Rf6+47]      
636c: df,47               je    63b5             if (0 != PURGSW)  {
#
636e: 45,ca,02,fa,32      ad3w  R32,Rfa,2ca      R32 = FN605A;                     # Canister Purge DC vs. AM, X -input = AM, Y -output = Purge Duty Cycle.
6373: a0,a2,34            ldw   R34,Ra2          R34 = AM;
6376: 09,01,34            shlw  R34,1            R34 *= 2;
6379: d3,03               jnc   637e             if ((uns) R34 >= 0)  {
637b: b1,ff,35            ldb   R35,ff           R35 = ff; }
#
637e: b0,35,34            ldb   R34,R35          R34 = R35;
6381: ef,33,d2            call  35b7             UUbyteLu();
6384: 98,38,00            cmpb  R0,R38           
6387: df,2c               je    63b5             if (0 != R38)  {
6389: b0,38,40            ldb   R40,R38          R40 = R38;
638c: 45,b2,02,fa,32      ad3w  R32,Rfa,2b2      R32 = FN600;                      # Canister Purge Duty Cycle Multiplier, X -input = PRGTMR.
                                                                                   #  Y -output = Duty Cycle Multiplier.
6391: b3,72,c9,34         ldb   R34,[R72+c9]     R34 = PRGTMR;                     # Canister Purge Timer - cannister purge accumulation time in seconds
6395: ef,1f,d2            call  35b7             UUbyteLu();
6398: 7c,38,40            ml2b  R40,R38          R40 *= R38;
639b: 09,01,40            shlw  R40,1            R40 *= 2;
639e: 45,be,02,fa,32      ad3w  R32,Rfa,2be      R32 = FN602;                      # Canister Purge DC Multiplier, X -input = CPRGTMR,
                                                                                   #  Y -output = Duty Cycle Multiplier.
63a3: b3,72,ca,34         ldb   R34,[R72+ca]     R34 = CPRGTMR;                    # Current purge on time
63a7: ef,0d,d2            call  35b7             UUbyteLu();
63aa: 7c,41,38            ml2b  R38,R41          R38 *= R41;
63ad: 08,07,38            shrw  R38,7            R38 /= 80;
63b0: 91,40,ef            orb   Ref,40           Prgflg = 1;
63b3: 20,09               sjmp  63be             goto 63be; } } } }

63b5: 11,38               clrb  R38              R38 = 0;
63b7: 71,bf,ef            an2b  Ref,bf           Prgflg = 0;
63ba: c7,72,ca,00         stb   R0,[R72+ca]      CPRGTMR = 0;                      # Clear Current Purge on time.
63be: c7,72,ac,38         stb   R38,[R72+ac]     PURGDC = R38;
63c2: 98,00,38            cmpb  R38,R0           
63c5: df,03               je    63ca             if (R38 != 0)  {
63c7: 91,40,e9            orb   Re9,40           CanPurgeOK = 1; }

#################################################################
# Tasklist Routine at 2151, routine offset 70 Fall thru?
# Update Canister Purge
################################################################# 


  Upd_canP:
63ca: b1,a3,38            ldb   R38,a3           R38 = a3;
63cd: c7,72,ae,38         stb   R38,[R72+ae]     Purge_period = R38;               # 12E - PURGE PERIOD
63d1: 7f,72,ac,38         ml2b  R38,[R72+ac]     R38 *= PURGDC;                    # 12C - PURGDC - Canister Purge Duty Cycle.
63d5: 09,01,38            shlw  R38,1            R38 *= 2;
63d8: c7,72,ad,39         stb   R39,[R72+ad]     Purg_on_time = R39;               # 12D - PURG ON TIME
63dc: f0                  ret                    return;


#################################################################
# Tasklist Routine at 2151, routine offset 16
# A/C Clutch Control Logic
# GUFB p. 10-7 
#################################################################

  Update_AC:
63dd: b3,f6,5a,42         ldb   R42,[Rf6+5a]     R42 = CTAC;
63e1: 98,b0,42            cmpb  R42,Rb0          
63e4: d6,05               jge   63eb             if (CTAC < ECT)  {
63e6: 91,40,eb            orb   Reb,40           Acect_flg = 1;                    # ECT too high
63e9: 20,26               sjmp  6411             goto 6411; }
#
63eb: 7b,f6,5b,42         sb2b  R42,[Rf6+5b]     R42 -= CTACH;
63ef: 98,b0,42            cmpb  R42,Rb0          
63f2: da,03               jle   63f7             if ((uns) R42 < ECT)  {
63f4: 71,bf,eb            an2b  Reb,bf           Acect_flg = 0; }                  # ECT below threshold, AC clutch engagement permitted
#
63f7: a3,f6,5c,42         ldw   R42,[Rf6+5c]     R42 = ACOFFN;
63fb: 88,ae,42            cmpw  R42,Rae          
63fe: d1,05               jleu  6405             if (ACOFFN > N )  {
6400: 91,20,eb            orb   Reb,20           Acn_flg = 1;                      # RPM too low
6403: 20,0c               sjmp  6411             goto 6411; }
#
6405: 67,f6,5e,42         ad2w  R42,[Rf6+5e]     R42 += ACOFFH;
6409: 88,ae,42            cmpw  R42,Rae          
640c: db,03               jgeu  6411             if (ACOFFN + ACOFFH > N)  {
640e: 71,df,eb            an2b  Reb,df           Acn_flg = 0; }                    # RPM above threshold, AC clutch engagement permitted
#
# Jump here from 63e9, 6403, 640c
6411: 37,ee,3a            jnb   B7,Ree,644e      if (A3C == 0) goto 644e;          # jump if AC pressure switch is off
6414: 3e,eb,03            jb    B6,Reb,641a      if (Acect_flg == 1) goto 641a;    # jump if ECT too high
6417: 35,eb,02            jnb   B5,Reb,641c      if (Acn_flg == 0) goto 641c;      # 
#
641a: 20,25               sjmp  6441             goto 6441;
#
# A3C = 1, Acect_flg = 0, Acn_flg = 0
# Check timers
#
641c: 9b,f6,53,c8         cmpb  Rc8,[Rf6+53]     
6420: db,02               jgeu  6424             if ((uns) ATMR1 >= ACSTRD) goto 6424;
6422: 20,1d               sjmp  6441             goto 6441;
#
6424: b3,f6,54,42         ldb   R42,[Rf6+54]     R42 = BRKCOT;
6428: 31,ea,08            jnb   B1,Rea,6433      if (BIFLG == 1)  {                # BIFLG = If equal to 1, Brake is on.
642b: 9b,74,95,42         cmpb  R42,[R74+95]                                       # 213 - A/C Clutch Brake Timer (sec)
642f: d1,02               jleu  6433             if ((uns) BRKCOT <= ACBTMR) goto 6433;
6431: 20,0e               sjmp  6441             goto 6441; }
#
6433: b3,f6,55,42         ldb   R42,[Rf6+55]     R42 = ACWDLY;
6437: 9b,74,97,42         cmpb  R42,[R74+97]                                       # 215 - A/C Clutch WOT Cutout Timer (1/8 sec)
643b: d1,02               jleu  643f             if ((uns) ACWDLY <= WCOTMR) goto 643f;
643d: 20,02               sjmp  6441             goto 6441;
#
643f: 20,18               sjmp  6459             goto 6459;
#
# Jump here from 641a, 6442, 6431, 643d
# 
6441: a3,f6,64,42         ldw   R42,[Rf6+64]     R42 = ACMNET;
6445: 33,ea,06            jnb   B3,Rea,644e      if (ACCFLG == 0) goto 644e;
6448: 8b,74,98,42         cmpw  R42,[R74+98]                                       # 216 - A/C CLUTCH TRANSITION TIMER
644c: d9,0b               jgtu  6459             if ((uns) ACMNET <= ACCTMR)  {
#
# Jump here from 6411, 6445
644e: 91,40,46            orb   R46,40           WOT_AC = 1;                       # LSO output line 6 setting bit turns ON relay which turns AC OFF
6451: 71,f7,ea            an2b  Rea,f7           ACCFLG = 0;                       # Disengage A/C clutch
6454: 71,fb,ea            an2b  Rea,fb           ACIFLG = 0;                       # Return to normal idle speed
6457: 20,32               sjmp  648b             return; }
#
# Jump here from 643f, 644c
6459: a3,f6,0a,42         ldw   R42,[Rf6+a]      R42 = ACRT;
645d: 8b,76,2e,42         cmpw  R42,[R76+2e]                                       #
6461: db,28               jgeu  648b             if (ACRT >= A3CTMR) return;       # Heated windshield is on
6463: a3,f6,56,42         ldw   R42,[Rf6+56]     R42 = ACMNDT;
6467: 8b,74,98,42         cmpw  R42,[R74+98]                                       # 216 - A/C CLUTCH TRANSITION TIMER
646b: d9,1e               jgtu  648b             if ((uns) ACMNDT > ACCTMR ) return;
646d: 37,d0,0a            jnb   B7,Rd0,647a      if (Cl_thrtl == 0) goto 647a;
6470: a3,f6,58,42         ldw   R42,[Rf6+58]     R42 = IDLCOT;
6474: 8b,74,9a,42         cmpw  R42,[R74+9a]                                       # 218 - A/C CLUTCH TURN -ON DELAY TIMER (msec resolution)
6478: d9,0b               jgtu  6485             if ((uns) IDLCOT <= ACITMR)  {
647a: 71,bf,46            an2b  R46,bf           WOT_AC = 0;                       # LSO output line 6 clearing bit turns OFF relay which turns AC ON
647d: 91,08,ea            orb   Rea,8            ACCFLG = 1;                       # Engage A/C clutch
6480: 71,fb,ea            an2b  Rea,fb           ACIFLG = 0;                       # 
6483: 20,06               sjmp  648b             return; }
#
6485: 3b,ea,03            jb    B3,Rea,648b      if (ACCFLG == 1) return;          # jmp if ACCFLG
6488: 91,04,ea            orb   Rea,4            ACIFLG = 1;                       # set ACIFLG - A/C engagement impending flag;
                                                                                   #  1 = A/C about to engage - adjust airflow and fuel immediately
#
648b: f0                  ret                    return;


#################################################################
# Tasklist Routine at 2151, routine offset 38
# update electric cooling fans
# GUFB p. 13-5
#################################################################

  Update_fans:
648c: 9b,f6,74,00         cmpb  R0,EDFHP                                           # 941C fan control enable
6490: d7,01               jne   6493             if (0 == EDFHP)  
6492: f0                  ret                    return;
#
6493: 37,a1,02            jnb   B7,Ra1,6498      if (CRKFLG == 0) goto 6498;
6496: 20,c1               sjmp  6559             goto 6559;

6498: 71,df,e9            an2b  Re9,df           HSFFLG = 0;
649b: 9b,f6,77,b0         cmpb  Rb0,[Rf6+77]                                       #  ROM 941F fan high speed temp 2(242DegF)
649f: d6,24               jge   64c5             if (ECT >= Ect_hs2) goto 64c5;
64a1: 9b,f6,76,b0         cmpb  Rb0,[Rf6+76]                                       #  ROM 941E fan high speed temp 1(234DegF)
64a5: de,21               jlt   64c8             if (ECT >= Ect_hs1)  {
64a7: b3,74,21,42         ldb   R42,[R74+21]     R42 = N_BYTE;
64ab: 9b,f6,78,42         cmpb  R42,[Rf6+78]     
64af: d3,17               jltu  64c8             if ((uns) R42 >= HSFRPM)  {
64b1: a3,74,de,42         ldw   R42,[R74+de]     R42 = LOAD;                       # engine load (VE)
64b5: 8b,f6,7a,42         cmpw  R42,[Rf6+7a]     
64b9: d3,0d               jltu  64c8             if ((uns) R42 >= HSFLOD)  {
64bb: b3,74,3f,42         ldb   R42,[R74+3f]     R42 = VSBAR_H;                    # 2BD - vehicle speed filtered(1) (MPH) 2BC is 8.8 format
64bf: 9b,f6,79,42         cmpb  R42,[Rf6+79]     
64c3: d9,03               jgtu  64c8             if ((uns) R42 <= HFSVS)  {
64c5: 91,20,e9            orb   Re9,20           HSFFLG = 1; } } } }
64c8: 35,e9,0d            jnb   B5,Re9,64d8      if (HSFFLG == 1)  {
64cb: b3,f6,71,40         ldb   R40,[Rf6+71]     R40 = EDFTM;
64cf: 9b,72,ce,40         cmpb  R40,[R72+ce]                                       # timer?
64d3: d9,03               jgtu  64d8             if ((uns) R40 <= EDFTMR)  {
64d5: 91,08,e9            orb   Re9,8            Hispd = 1; } }
64d8: b3,f6,76,42         ldb   R42,[Rf6+76]     R42 = Ect_hs1;                    # 941E fan high speed temp 1(234DegF)
64dc: 7b,f6,6d,42         sb2b  R42,[Rf6+6d]     R42 -= HSFHYS;
64e0: 98,b0,42            cmpb  R42,Rb0          
64e3: da,03               jle   64e8             if ((uns) R42 < ECT)  {
64e5: 71,f7,e9            an2b  Re9,f7           Hispd = 0; }
64e8: 9b,f6,6c,b0         cmpb  Rb0,[Rf6+6c]                                       #  ROM 9414 fan low speed temp (220DegF)
64ec: da,03               jle   64f1             if ((uns) ECT < Fan_temp)  {
64ee: 91,04,e9            orb   Re9,4            Lospd_ect = 1; }
64f1: b3,f6,6c,42         ldb   R42,[Rf6+6c]     R42 = Fan_temp;                   # 9414 fan low speed temp (220DegF)
64f5: 7b,f6,6e,42         sb2b  R42,[Rf6+6e]     R42 -= LSFHYS;
64f9: 98,b0,42            cmpb  R42,Rb0          
64fc: da,03               jle   6501             if ((uns) R42 < ECT)  {
64fe: 71,fb,e9            an2b  Re9,fb           Lospd_ect = 0; }
6501: 33,e9,09            jnb   B3,Re9,650d      if (Hispd == 0) goto 650d;
6504: b3,f6,75,40         ldb   R40,[Rf6+75]     R40 = HEDFHP;                     # 941D fan high speed enable
6508: 99,01,40            cmpb  R40,1            
650b: df,44               je    6551             if (R40 == 1) goto 6551;
650d: b3,f6,6f,42         ldb   R42,[Rf6+6f]     R42 = LSFVS;
6511: 7b,f6,70,42         sb2b  R42,[Rf6+70]     R42 -= LSFVSH;
6515: 9b,74,3f,42         cmpb  R42,[R74+3f]                                       # 2BD - vehicle speed filtered(1) (MPH) 2BC is 8.8 format
6519: d1,05               jleu  6520             if ((uns) R42 > VSBAR_H )  {
651b: 33,ea,02            jnb   B3,Rea,6520      if (ACCFLG == 0) goto 6520;
651e: 20,06               sjmp  6526             goto 6526; }

6520: 3a,e9,03            jb    B2,Re9,6526      if (Lospd_ect == 1) goto 6526;
6523: 37,c5,04            jnb   B7,Rc5,652a      if (CFMFLG == 1)  {
6526: 71,9f,47            an2b  R47,9f           Fan = 0;
                                                 Hi_fan = 0;                       # R47 bits 5 and 6 OFF (Fans? )
6529: f0                  ret                    return; }

652a: 3b,ea,0c            jb    B3,Rea,6539      if (ACCFLG == 0)  {
652d: a3,f6,72,40         ldw   R40,[Rf6+72]     R40 = ACMNFT;
6531: 8b,74,98,40         cmpw  R40,[R74+98]                                       # 216 - timer?
6535: d9,02               jgtu  6539             if ((uns) R40 > ACCTMR ) goto 6539;
6537: 20,14               sjmp  654d             goto 654d; }

6539: b3,f6,55,40         ldb   R40,[Rf6+55]     R40 = ACWDLY;
653d: 9b,74,97,40         cmpb  R40,[R74+97]                                       # 215 timer?
6541: d9,0a               jgtu  654d             if ((uns) R40 > WCOTMR ) goto 654d;
6543: b3,f6,6f,40         ldb   R40,[Rf6+6f]     R40 = LSFVS;
6547: 9b,74,3f,40         cmpb  R40,[R74+3f]                                       # 2BD - vehicle speed filtered(1) (MPH) 2BC is 8.8 format
654b: db,02               jgeu  654f             if ((uns) R40 >= VSBAR_H) goto 654f;
654d: 20,10               sjmp  655f             goto 655f;

654f: 20,07               sjmp  6558             goto 6558;

6551: 71,df,47            an2b  R47,df           Fan = 0;                          # R47 bit 5 OFF (Fan? )
6554: 91,40,47            orb   R47,40           Hi_fan = 1;                       # R47 bit 6 ON (Fan? )
6557: f0                  ret                    return;

6558: f0                  ret                    return;

6559: 71,f7,e9            an2b  Re9,f7           Hispd = 0;
655c: 71,fb,e9            an2b  Re9,fb           Lospd_ect = 0;
655f: 91,20,47            orb   R47,20           Fan = 1;                          # R47 bit 5 ON (Fan? )
6562: 71,bf,47            an2b  R47,bf           Hi_fan = 0;                       # R47 bit 6 OFF (Fan? )
6565: f0                  ret                    return;


#################################################################
# Tasklist Routine at 2151, routine offset 40
# Supercharger Bypass Solenoid Strategy
# GUFB p. 12-11
#################################################################

  Upd_Suprchrgr_Byp:
6566: b3,fe,0b,30         ldb   R30,[Rfe+b]      R30 = THRMHP;
656a: 99,02,30            cmpb  R30,2            
656d: d7,31               jne   65a0             if (R30 = 2)  {                   # thermactor present must be 2
# Supercharger Bypass Solenoid Strategy
656f: 3c,c5,2b            jb    B4,Rc5,659d      if (TFMFLG == 0)  {
6572: 3f,a1,28            jb    B7,Ra1,659d      if (CRKFLG == 0)  {
6575: 3a,a1,25            jb    B2,Ra1,659d      if (UNDSP == 0)  {
6578: a3,f2,0a,30         ldw   R30,[Rf2+a]      R30 = THBPSC;
657c: 67,72,a6,30         ad2w  R30,[R72+a6]     R30 += RATCH;                     # 126 - RATCH=Closed TP
6580: d3,04               jnc   6586             if ((uns) R30 >= 0)  {
6582: a1,c0,ff,30         ldw   R30,ffc0         R30 = ffc0; }
6586: 88,30,aa            cmpw  Raa,R30                                            # RAA is Throttle position
6589: d1,05               jleu  6590             if ((uns) TP > R30 )  {
658b: 91,08,47            orb   R47,8            TAB = 1;                          # R47 bit 3 ON (Air management1)
658e: 20,10               sjmp  65a0             return; }

6590: 6b,f2,0c,30         sb2w  R30,[Rf2+c]      R30 -= THBPSH;
6594: db,02               jc    6598             if (R30 > 0)  {
6596: 01,30               clrw  R30              R30 = 0; }
6598: 88,30,aa            cmpw  Raa,R30                                            # RAA is Throttle position
659b: db,03               jgeu  65a0             if ((uns) TP >= R30) return; } } }
659d: 71,f7,47            an2b  R47,f7           TAB = 0; }                        # R47 bit 3 OFF (Air management1)
#
65a0: f0                  ret                    return;


#################################################################
# Tasklist Routine at 2151, routine offset 4A
# Update Air Management
# GUFB p. 12-10
#################################################################

  Upd_Iacflg:
65a1: b3,fe,0b,30         ldb   R30,[Rfe+b]      R30 = THRMHP;                     # 9E65 thermactor present switch = 1.0
65a5: 99,03,30            cmpb  R30,3            
65a8: d7,29               jne   65d3             if (R30 = 3)  {
65aa: a3,f2,0e,30         ldw   R30,[Rf2+e]      R30 = NIAC;                       # 8E68 - NIAC
65ae: 88,30,ae            cmpw  Rae,R30          
65b1: d1,05               jleu  65b8             if ((uns) N > R30 )  {
65b3: 91,10,29            orb   R29,10           Iacflg = 1;                       # set IACFLG
65b6: 20,10               sjmp  65c8             goto 65c8; }
#
65b8: 6b,f2,10,30         sb2w  R30,[Rf2+10]     R30 -= NIACH;                     # 8E6A - NIACH
65bc: db,02               jc    65c0             if (R30 > 0)  {
65be: 01,30               clrw  R30              R30 = 0; }
65c0: 88,30,ae            cmpw  Rae,R30          
65c3: db,03               jgeu  65c8             if (N > R30)  {
65c5: 71,ef,29            an2b  R29,ef           Iacflg = 0; }                     # clr IACFLG
#
65c8: 3c,29,05            jb    B4,R29,65d0      if (Iacflg == 0)  {
65cb: 71,ef,47            an2b  R47,ef           TAD = 0;                          # R47 bit 4 OFF (Air management2)
65ce: 20,03               sjmp  65d3             return; }
#
65d0: 91,10,47            orb   R47,10           TAD = 1; }                        # R47 bit 4 ON (Air management2)
#
65d3: f0                  ret                    return;


#################################################################
# Tasklist Routine at 2151, routine offset 18
# 
#################################################################

  Set_Timers:
65d4: 3d,2b,04            jb    B5,R2b,65db      if (STIFLG == 0)  {
65d7: c7,72,48,00         stb   R0,[R72+48]      TSSTIL = 0; }                     # STI input line low timer
#
65db: 37,a1,1e            jnb   B7,Ra1,65fc      if (CRKFLG == 1)  {
#
# CRANKING - Clear and disable these timers
65de: 11,c8               clrb  Rc8              ATMR1 = 0;                        # Cranking, clear timers
65e0: 71,bf,24            an2b  R24,bf           ATMR2_On = 0;
65e3: 11,c9               clrb  Rc9              ATMR2 = 0;
65e5: 71,df,24            an2b  R24,df           NACTMR_On = 0;
65e8: 11,cd               clrb  Rcd              NACTMR = 0;
65ea: 71,fb,24            an2b  R24,fb           AWOTMR_On = 0;
65ed: 11,cb               clrb  Rcb              AWOTMR = 0;
65ef: 71,df,a1            an2b  Ra1,df           Purging = 0;
65f2: c7,72,c9,00         stb   R0,[R72+c9]      PRGTMR = 0;
65f6: c7,72,ce,00         stb   R0,[R72+ce]      EDFTMR = 0;
65fa: 22,c4               sjmp  68c0             goto 68c0; }
#
# Not cranking
65fc: 37,d0,0a            jnb   B7,Rd0,6609      if (APT < 0)  {                   # Not cranking, but closed Throttle
#
# CLOSED THROTTLE
65ff: 91,40,a1            orb   Ra1,40           CTTMR_On = 1;
6602: 71,df,24            an2b  R24,df           NACTMR_On = 0;
6605: 11,cd               clrb  Rcd              NACTMR = 0;
6607: 20,0a               sjmp  6613             goto 6613; }
#
# Part throttle or WOT
6609: 91,20,24            orb   R24,20           NACTMR_On = 1;                    # Not crank, not closed Throttle
660c: 71,bf,a1            an2b  Ra1,bf           CTTMR_On = 0;
660f: c7,72,aa,00         stb   R0,[R72+aa]      CTTMR = 0;
#
6613: 30,24,0d            jnb   B0,R24,6623      if (Wot == 1)  {                  # At Wide Open Throttle ?
#
# WOT
6616: 91,04,24            orb   R24,4            AWOTMR_On = 1;
6619: 99,fe,cb            cmpb  Rcb,fe           
661c: d3,03               jltu  6621             if ((uns) AWOTMR >= fe)  {
661e: 71,fb,24            an2b  R24,fb           AWOTMR_On = 0; }                  # Clip AWOTMR at 255
#
6621: 20,05               sjmp  6628             goto 6628; }
#
# Not WOT
6623: 71,fb,24            an2b  R24,fb           AWOTMR_On = 0;                    # closed or part throttle
6626: 11,cb               clrb  Rcb              AWOTMR = 0;                       # disable and clear AWOTMR
#
6628: 9b,fe,06,b0         cmpb  Rb0,[Rfe+6]      
662c: da,08               jle   6636             if ((uns) ECT < TEMPFB)  {        # = Min ECT to start ATMR2
662e: 3e,24,05            jb    B6,R24,6636      if (ATMR2_On == 0)  {
6631: 91,40,24            orb   R24,40           ATMR2_On = 1;
6634: 11,c9               clrb  Rc9              ATMR2 = 0; } }                    # 
#
6636: 35,47,04            jnb   B5,R47,663d      if (Fan == 1)  {                  # Always 0 on A9L
6639: c7,72,ce,00         stb   R0,[R72+ce]      EDFTMR = 0; }                     
#
# IDLFLG logic (GUFB p. 20-19)
#
663d: a3,fc,38,38         ldw   R38,[Rfc+38]     R38 = IDLRPM;
6641: 88,38,ae            cmpw  Rae,R38          
6644: db,05               jgeu  664b             if (N > IDLRPM)  {
6646: 91,02,a1            orb   Ra1,2            Idleq = 1;
6649: 20,0c               sjmp  6657             goto 6657; }
#
664b: 67,fc,3a,38         ad2w  R38,[Rfc+3a]     R38 += IDRPMH;
664f: 88,38,ae            cmpw  Rae,R38          
6652: d1,03               jleu  6657             if ((uns) N > IDLRPM + IDRPMH )  {
6654: 71,fd,a1            an2b  Ra1,fd           Idleq = 0; }
#
6657: 71,f7,ef            an2b  Ref,f7           IDLFLG = 0;
#
665a: 36,26,09            jnb   B6,R26,6666      if (DNDSUP == 1)  {
665d: 37,d0,06            jnb   B7,Rd0,6666      if (APT < 0)  {
6660: 31,a1,03            jnb   B1,Ra1,6666      if (Idleq == 1)  {
6663: 91,08,ef            orb   Ref,8            IDLFLG = 1; } } }
#
# CTNTMR logic - GUFB p. 20-14
#
6666: b3,72,c4,34         ldb   R34,[R72+c4]     R34 = CTNTMR;
666a: 45,2a,01,f8,32      ad3w  R32,Rf8,12a      R32 = FN880;                      # ISC Neutral RPM adder
666f: ef,45,cf            call  35b7             UUbyteLu();
6672: 09,05,38            shlw  R38,5            R38 *= 20;
6675: 67,f6,32,38         ad2w  R38,[Rf6+32]     R38 += INLRPM;
6679: 88,38,ae            cmpw  Rae,R38          
667c: db,05               jgeu  6683             if (N > R38)  {
667e: 91,02,24            orb   R24,2            Ctnq = 1;
6681: 20,0c               sjmp  668f             goto 668f; }
#
6683: 67,f6,34,38         ad2w  R38,[Rf6+34]     R38 += INLRPH;
6687: 88,38,ae            cmpw  Rae,R38          
668a: d1,03               jleu  668f             if ((uns) N > R38 )  {
668c: 71,fd,24            an2b  R24,fd           Ctnq = 0; }
#
668f: 71,fb,e8            an2b  Re8,fb           CTNFLG = 0;                       # Default condition
6692: 71,fd,e8            an2b  Re8,fd           Ctntmr_up = 0;
6695: 91,01,e8            orb   Re8,1            Ctntmr_dwn = 1;
6698: 9b,fe,04,b0         cmpb  Rb0,[Rfe+4]      
669c: da,2c               jle   66ca             if ((uns) ECT < CTHIGH)  {
669e: 37,d0,29            jnb   B7,Rd0,66ca      if (APT < 0)  {
66a1: 3f,e7,26            jb    B7,Re7,66ca      if (NDSFLG == 0)  {
66a4: 31,24,23            jnb   B1,R24,66ca      if (Ctnq == 1)  {
66a7: 91,04,e8            orb   Re8,4            CTNFLG = 1;
66aa: 91,02,e8            orb   Re8,2            Ctntmr_up = 1;
66ad: 71,fe,e8            an2b  Re8,fe           Ctntmr_dwn = 0;
66b0: b3,f4,72,38         ldb   R38,[Rf4+72]     R38 = NIOLD;
66b4: 77,f4,73,38         ad2b  R38,[Rf4+73]     R38 += NIHYS;
66b8: d3,03               jnc   66bd             if ((uns) R38 >= 0)  {
66ba: b1,ff,38            ldb   R38,ff           R38 = ff; }                       # Clip CTNTMR to 255
#
66bd: 9b,72,c4,38         cmpb  R38,[R72+c4]     
66c1: d9,07               jgtu  66ca             if ((uns) R38 <= CTNTMR)  {
66c3: c7,72,c4,38         stb   R38,[R72+c4]     CTNTMR = R38;
66c7: 71,fd,e8            an2b  Re8,fd           Ctntmr_up = 0; } } } } }
#
# HMTMR logic - GUFB p. 20-18
#
66ca: a3,74,e2,3a         ldw   R3a,[R74+e2]     R3a = PERLOAD;                    # Relative Volumetric Efficiency
66ce: a3,f6,22,38         ldw   R38,[Rf6+22]     R38 = UPLOD;
66d2: 47,f6,24,38,3c      ad3w  R3c,R38,[Rf6+24] R3c = UPLOD + UPLODH;
66d7: d3,03               jnc   66dc             if ((uns) R3c >= 0)  {            # add overflowed?
66d9: bd,ff,3c            ldsbw R3c,ff           R3c = 0xffff; }                   # clip word to FFFF
#
66dc: 88,3a,3c            cmpw  R3c,R3a          
66df: d3,0e               jltu  66ef             if ((uns) UPLOD + UPLODH < PERLOAD) goto 66ef;
66e1: 88,3a,38            cmpw  R38,R3a          
66e4: d1,0c               jleu  66f2             if ((uns) UPLOD > PERLOAD)  {
#
# Load below threshold - Disable HMTMR
66e6: c7,72,b7,00         stb   R0,[R72+b7]      HMTMR = 0;                        # zero 137 timer?
66ea: 71,fb,eb            an2b  Reb,fb           HMTMR_On = 0;
66ed: 20,03               sjmp  66f2             goto 66f2;
#
# Load above threshold + hyst - Enable HMTMR
66ef: 91,04,eb            orb   Reb,4            HMTMR_On = 1; }                   # Start (keep) counting HMTMR
#
# Startup delay logic for Managed Fuel Air Timer
# GUFB p. 20-21
#
66f2: 71,7f,ec            an2b  Rec,7f           SWTFLG = 0;                       #
66f5: 45,02,00,f4,30      ad3w  R30,Rf4,2        R30 = &MFATM3;                    # "A" logic bottom of p. 20-21
66fa: ef,52,d0            call  374f             Check_Timers();
66fd: db,56               jc    6755             if (too early) goto 6755;
# Top of p. 20-21 - "A" true
66ff: 38,d0,53            jb    B0,Rd0,6755      if (APT != 0) goto 6755;          # Not at part throttle         
6702: 3a,ee,50            jb    B2,Ree,6755      if (OLFLG == 1) goto 6755;        # Not closed loop
6705: 8b,f4,0e,ae         cmpw  Rae,[Rf4+e]      
6709: d1,4a               jleu  6755             if ((uns) N <= MFANLO) goto 6755; # RPM too low
670b: 8b,f4,10,ae         cmpw  Rae,[Rf4+10]     
670f: db,44               jgeu  6755             if ((uns) N >= MFANHI) goto 6755; # RPM too high
6711: 4b,74,fe,ae,38      sb3w  R38,Rae,[R74+fe] R38 = N - NDBAR;                  # 027c - filtered(2) RPM
6716: db,02               jgeu  671a             if (R38 > 0)  {                   # Absolute value of difference
6718: 03,38               negw  R38              R38 = -R38; }
#
671a: 8b,f4,12,38         cmpw  R38,[Rf4+12]     
671e: db,35               jgeu  6755             if ((uns) R38 >= MFASN) goto 6755; # RPM not steady
6720: 8b,f4,14,3a         cmpw  R3a,[Rf4+14]     
6724: db,2f               jgeu  6755             if ((uns) R3a >= MFALH) goto 6755; # PERLOAD too high
6726: 37,e7,2c            jnb   B7,Re7,6755      if (NDSFLG == 0) goto 6755;       # Not in Drive
6729: b3,f4,20,38         ldb   R38,[Rf4+20]     R38 = MPMNBP;
672d: 77,f4,21,38         ad2b  R38,[Rf4+21]     R38 += MPNBPH;
6731: d3,03               jnc   6736             if ((uns) R38 >= 0)  {            # Add overflowed
6733: b1,ff,38            ldb   R38,ff           R38 = ff; }                       # Clip to 255
#
6736: 9b,74,80,38         cmpb  R38,[R74+80]                                       # BP - barometric pressure
673a: d9,19               jgtu  6755             if ((uns) MPMNBP + MPNBPH > BP ) goto 6755; # BP too low
673c: 9b,f2,47,00         cmpb  R0,[Rf2+47]      
6740: df,16               je    6758             if (0 == VSTYPE) goto 6758;       # VSTYPE = 1 on A9L
6742: b3,f2,42,38         ldb   R38,[Rf2+42]     R38 = VSMPG;
6746: 77,f2,43,38         ad2b  R38,[Rf2+43]     R38 += VSMPGH;
674a: d3,03               jnc   674f             if ((uns) R38 >= 0)  {            # Add overflowed
674c: b1,ff,38            ldb   R38,ff           R38 = ff; }                       # Clip to 255
#
674f: 9b,74,3f,38         cmpb  R38,[R74+3f]                                       # 2BD - vehicle speed filtered(1) (MPH) 2BC is 8.8 format
6753: d1,03               jleu  6758             if ((uns) VSMPG + VSMPGH <= VSBAR_H) goto 6758;
#
6755: 30,ec,03            jnb   B0,Rec,675b      if (MFAFLG == 1)  {
# Set SWTFLG
6758: 91,80,ec            orb   Rec,80           SWTFLG = 1; }
#
# MFACTR logic for Managed Fuel Air Timer MFATMR
# GUFB p. 20-21 (middle)
#
675b: b3,72,c8,38         ldb   R38,[R72+c8]     R38 = MFACTR;
675f: 30,ee,02            jnb   B0,Ree,6764      if (SWTFL == 1)  {
6762: 17,38               incb  R38              R38++; }
#
6764: 3f,ec,02            jb    B7,Rec,6769      if (SWTFLG == 0)  {
6767: 11,38               clrb  R38              R38 = 0; }
#
6769: c7,72,c8,38         stb   R38,[R72+c8]     MFACTR = R38;
#
# MFATMR logic
# GUFB p. 20-20
# 
676d: 9b,f4,16,38         cmpb  R38,[Rf4+16]     
6771: d3,03               jltu  6776             if ((uns) MFACTR >= SWTCNT)  {
6773: 91,01,ec            orb   Rec,1            MFAFLG = 1; }
#
6776: 38,24,55            jb    B0,R24,67ce      if (WOT == 1) goto 67ce;
6779: a3,f4,10,38         ldw   R38,[Rf4+10]     R38 = MFANHI;
677d: 67,f4,18,38         ad2w  R38,[Rf4+18]     R38 += MFANHH;
6781: 88,38,ae            cmpw  Rae,R38          
6784: d9,48               jgtu  67ce             if ((uns) N > MFANHI + MFANHH) goto 67ce;
6786: a3,f4,0e,38         ldw   R38,[Rf4+e]      R38 = MFANLO;
678a: 6b,f4,1a,38         sb2w  R38,[Rf4+1a]     R38 -= MFANLH;
678e: 88,38,ae            cmpw  Rae,R38          
6791: d3,3b               jltu  67ce             if ((uns) N < MFANLO - MFANLH) goto 67ce;
# N.B. R3A is PERLOAD, fetched above at 66CA
6793: 8b,f4,1c,3a         cmpw  R3a,[Rf4+1c]     
6797: d3,35               jltu  67ce             if ((uns) PERLOAD < MFALL) goto 67ce;
6799: a3,f4,14,38         ldw   R38,[Rf4+14]     R38 = MFALH;
679d: 67,f4,1e,38         ad2w  R38,[Rf4+1e]     R38 += MFALHH;
67a1: d3,03               jnc   67a6             if ((uns) R38 >= 0)  {            # add overflowed
67a3: bd,ff,38            ldsbw R38,ff           R38 = 0xffff; }                   # clip to 255
#
67a6: 88,38,3a            cmpw  R3a,R38          
67a9: d9,23               jgtu  67ce             if ((uns) PERLOAD > MFALH + MFALHH) goto 67ce;
67ab: 37,e7,20            jnb   B7,Re7,67ce      if (NDSFLG == 0) goto 67ce;
67ae: 51,a8,c5,34         an3b  R34,Rc5,a8       R34 = Fmem_flags & a8;            # mask for CFMFLG, AFMFLG, MFMFLG
67b2: d7,1a               jne   67ce             if (R34 != 0) goto 67ce;
67b4: b3,74,80,40         ldb   R40,[R74+80]     R40 = BP;                         # BP - barometric pressure
67b8: 9b,f4,20,40         cmpb  R40,[Rf4+20]     
67bc: d3,10               jltu  67ce             if ((uns) R40 < MPMNBP) goto 67ce;
67be: 9b,f2,47,00         cmpb  R0,[Rf2+47]      
67c2: df,10               je    67d4             if (0 != VSTYPE)  {               # VSTYPE = 1 on A9L
67c4: b3,f2,42,38         ldb   R38,[Rf2+42]     R38 = VSMPG;
67c8: 9b,74,3f,38         cmpb  R38,[R74+3f]                                       # 2BD - vehicle speed filtered(1) (MPH) 2BC is 8.8 format
67cc: d1,06               jleu  67d4             if ((uns) VSMPG > VSBAR_H)  {
#
67ce: c4,ce,00            stb   R0,Rce           MFATMR = 0;                       # zero RCE timer?
67d1: 71,fe,ec            an2b  Rec,fe           MFAFLG = 0; } }
#
# NFLG logic
# GUFB p. 6-12
#
67d4: 71,fb,26            an2b  R26,fb           NFLG = 0;
67d7: 37,d0,06            jnb   B7,Rd0,67e0      if (APT < 0)  {                   # throttle closed
67da: 3f,e7,03            jb    B7,Re7,67e0      if (NDSFLG == 0)  {               # in neutral
67dd: 91,04,26            orb   R26,4            NFLG = 1; } }
#
# MFAMUL logic
# GUFB p. 6-20
#
67e0: 11,38               clrb  R38              R38 = 0;
67e2: 30,ec,12            jnb   B0,Rec,67f7      if (MFAFLG == 1)  {
67e5: b3,f4,22,38         ldb   R38,[Rf4+22]     R38 = MFARMP;
67e9: 77,74,f4,38         ad2b  R38,[R74+f4]     R38 += MFAMUL;
67ed: db,05               jc    67f4             if ((uns)  >= 0) goto 67f4;       # jmp on overflow
67ef: 99,80,38            cmpb  R38,80                                            
67f2: d1,03               jleu  67f7             if ((uns) R38 > 80 )  {
#
67f4: b1,80,38            ldb   R38,80           R38 = 80; } }                     # Clip to 1.0 max
#
67f7: c7,74,f4,38         stb   R38,[R74+f4]     MFAMUL = R38;
#
# HLTMR logic
# GUFB p. 20-18
#
67fb: 30,29,04            jnb   B0,R29,6802      if (HLTMR_Off == 1)  {
67fe: c7,72,cc,00         stb   R0,[R72+cc]      HLTMR = 0; }                      # High load timer - 1/8 seconds under high load so far
#
# LESTMRn, LEGOFGn logic
# GUFB p. 20-19
#
6802: 3a,ee,08            jb    B2,Ree,680d      if (OLFLG == 0)  {
6805: 3b,27,05            jb    B3,R27,680d      if (SWTFL1 == 0)  {
6808: 91,80,27            orb   R27,80           LESTMR1_On = 1;
680b: 20,07               sjmp  6814             goto 6814; } }
#
680d: 71,7f,27            an2b  R27,7f           LESTMR1_On = 0;                   # EGO #1 switch detected, disable and
6810: c7,74,e8,00         stb   R0,[R74+e8]      LESTMR1 = 0;                      # clear timer
6814: 3a,ee,08            jb    B2,Ree,681f      if (OLFLG == 0)  {
6817: 38,27,05            jb    B0,R27,681f      if (SWTFL2 == 0)  {
681a: 91,40,27            orb   R27,40           LESTMR2_On = 1;
681d: 20,07               sjmp  6826             goto 6826; } }
#
681f: 71,bf,27            an2b  R27,bf           LESTMR2_On = 0;                   # EGO #2 switch detected, disable and
6822: c7,74,e9,00         stb   R0,[R74+e9]      LESTMR2 = 0;                      # clear timer
#
6826: b3,74,e8,14         ldb   R14,[R74+e8]     R14 = LESTMR1;                    # timer?
682a: 9b,f6,36,14         cmpb  R14,[Rf6+36]     
682e: d3,03               jltu  6833             if ((uns) LESTMR1 >= BYPLES)  {
6830: 91,02,ed            orb   Red,2            LEGOFG1 = 1; }
#
6833: b3,74,e9,14         ldb   R14,[R74+e9]     R14 = LESTMR2;                    # timer?
6837: 9b,f6,36,14         cmpb  R14,[Rf6+36]     
683b: d3,03               jltu  6840             if ((uns) LESTMR2 >= BYPLES)  {
683d: 91,01,ed            orb   Red,1            LEGOFG2 = 1; }
#
6840: b3,f6,38,14         ldb   R14,[Rf6+38]     R14 = LOESSW;
6844: 98,00,14            cmpb  R14,R0           
6847: df,0c               je    6855             if (LOESSW != 0)  {               # Clear LEGOFGn if switch detected
6849: 33,27,03            jnb   B3,R27,684f      if (SWTFL1 == 1)  {
684c: 71,fd,ed            an2b  Red,fd           LEGOFG1 = 0; }
#
684f: 30,27,03            jnb   B0,R27,6855      if (SWTFL2 == 1)  {
6852: 71,fe,ed            an2b  Red,fe           LEGOFG2 = 0; } }
#
# ACCTMR logic
# GUFB p. 20-10
#
6855: 33,ea,05            jnb   B3,Rea,685d      if (ACCFLG == 1)  {
6858: 38,ea,02            jb    B0,Rea,685d      if (Paccflg == 1) goto 685d;
685b: 20,06               sjmp  6863             goto 6863; }
#
685d: 3b,ea,0a            jb    B3,Rea,686a      if (ACCFLG == 0)  {
6860: 30,ea,07            jnb   B0,Rea,686a      if (Paccflg == 1)  {
# ACCFLG had a transition
6863: c3,74,98,00         stw   R0,[R74+98]      ACCTMR = 0;                       # clear timer to delay A/C cycling
6867: 95,01,ea            xorb  Rea,1            Paccflg ^= 1; } }                 # save last ACCFLG value
#
# ACWTMR logic
# GUFB p. 20-11
#
686a: a3,72,a6,36         ldw   R36,[R72+a6]     R36 = RATCH;                      # 126 - RATCH=Closed TP
686e: 47,f6,60,36,42      ad3w  R42,R36,[Rf6+60] R42 = RATCH + THBP4;
6873: 88,aa,42            cmpw  R42,Raa                                            # RAA is Throttle position
6876: db,03               jgeu  687b             if (RATCH + THBP4 > TP)  {
6878: 91,80,eb            orb   Reb,80           Acwflg = 1; }
#
687b: 6b,f6,62,42         sb2w  R42,[Rf6+62]     R42 -= THBP4H;
687f: 88,aa,42            cmpw  R42,Raa                                            # RAA is Throttle position
6882: d1,03               jleu  6887             if ((uns) RATCH + THBP4 - THBP4H > TP )  {
6884: 71,7f,eb            an2b  Reb,7f           Acwflg = 0; }
#
6887: 3f,eb,06            jb    B7,Reb,6890      if (Acwflg == 0)  {
688a: c7,74,96,00         stb   R0,[R74+96]      ACWTMR = 0;                       # zero 214 - A/C WOT timer
688e: 20,0f               sjmp  689f             goto 689f; }
# Clip ACWTMR to 254 max
6890: b3,74,96,42         ldb   R42,[R74+96]     R42 = ACWTMR;
6894: 99,ff,42            cmpb  R42,ff           
6897: d7,06               jne   689f             if (R42 = ff)  {                  # Clip to 254
6899: 15,42               decb  R42              R42--;
689b: c7,74,96,42         stb   R42,[R74+96]     ACWTMR = R42; }
#
# WCOTMR logic
# GUFB p. 20-23
#
# R36 = RATCH, loaded at 686A above
689f: 48,36,aa,34         sb3w  R34,Raa,R36      R34 = TP - RATCH;                 # RAA is Throttle position
68a3: db,02               jc    68a7             if (R34 > 0)  {                   # Clip relative TP to 0
68a5: 01,34               clrw  R34              R34 = 0; }
#
68a7: 45,56,01,f0,32      ad3w  R32,Rf0,156      R32 = FN087;                      # A/C time delay vs TP
68ac: ef,5d,cd            call  360c             UUWordLu();
68af: 9b,74,96,38         cmpb  R38,[R74+96]                                       # 
68b3: d1,04               jleu  68b9             if ((uns) FN087(TP-RATCH) > ACWTMR )  {
68b5: c7,74,97,00         stb   R0,[R74+97]      WCOTMR = 0; }                     # Clear WCOTMR
#
# NWOTMR logic
# GUFB p. 20-22
#
68b9: 30,24,04            jnb   B0,R24,68c0      if (Wot == 1)  {
68bc: c7,74,a2,00         stb   R0,[R74+a2]      NWOTMR = 0; }
#
# Jump here from 0x65fa, 0x68b9
#
# CTATMR logic
# GUFB p. 20-14
#
68c0: a3,f6,1c,32         ldw   R32,[Rf6+1c]     R32 = UPRPM2;
68c4: 67,f6,1a,32         ad2w  R32,[Rf6+1a]     R32 += UPRPMH;
68c8: 88,32,ae            cmpw  Rae,R32          
68cb: d1,05               jleu  68d2             if ((uns) UPRPM2 + UPRPMH > R32 )  {
68cd: 91,10,eb            orb   Reb,10           Ctupr_flg = 1;
68d0: 20,09               sjmp  68db             goto 68db; }
#
68d2: 8b,f6,1c,ae         cmpw  Rae,[Rf6+1c]     
68d6: db,03               jgeu  68db             if (N > UPRPM2)  {
68d8: 71,ef,eb            an2b  Reb,ef           Ctupr_flg = 0; }
#
68db: 37,d0,08            jnb   B7,Rd0,68e6      if (APT < 0)  {
68de: 34,eb,05            jnb   B4,Reb,68e6      if (Ctupr_flg == 1)  {
68e1: 91,08,eb            orb   Reb,8            CTAFLG = 1;                       # Enable counting CTATMR
68e4: 20,07               sjmp  68ed             goto 68ed; } }
#
68e6: c7,72,b8,00         stb   R0,[R72+b8]      CTATMR = 0;                       # Clear closed throttle upstream air timer
68ea: 71,f7,eb            an2b  Reb,f7           CTAFLG = 0;                       # and disable
#
# CRKTMR logic
# GUFB p. 20-13
# 
68ed: 88,00,ae            cmpw  Rae,R0           
68f0: d7,04               jne   68f6             if (N == 0)  {
68f2: c7,72,cf,00         stb   R0,[R72+cf]      CRKTMR = 0; }                     # zero 14F timer?
#
# ACITMR logic
# GUFB p. 20-10
#
68f6: 3a,ea,04            jb    B2,Rea,68fd      if (ACIFLG == 1) return;
68f9: c3,74,9a,00         stw   R0,[R74+9a]      ACITMR = 0; }                     # zero 218 - timer?
#
68fd: f0                  ret                    return;


#################################################################
# Background Task - Update Timers
# see timer table below this subroutine.
# routine has 1 mS (1/1204) resolution.
# keeps remainders of IOTIMER so that it stays in sync
#################################################################

  Update_timers:
68fe: a3,72,c0,3c         ldw   R3c,[R72+c0]     R3c = Eighths_ext;                # 1/8s remainder (in mSec)
6902: a1,b1,69,30         ldw   R30,69b1         R30 = &Timer_list;
6906: a0,06,36            ldw   R36,R6           R36 = IO_Timer;
6909: 4b,72,c2,36,38      sb3w  R38,R36,[R72+c2] R38 = R36 - Loop_time;            # IOTIMER delta time since last mSec
690e: 01,3a               clrw  R3a              R3a = 0;
6910: 0d,07,38            shldw R38,7            R3b:R38 = R38 * 0x80; 
6913: 8d,73,cb,38         divw  R38,cb73         R39:R38 = R3b:R38 / 0xcb73;       # *128/52083 = 1 mSec
                                                 R3b:R3a = R3b:R38 % 0xcb73;       # remainder
6917: 88,00,38            cmpw  R38,R0           
691a: d7,02               jne   691e             if (R38 != 0) goto 691e;
691c: 20,92               sjmp  69b0             return;                           # < 1 mS passed - return
#
# At least 1 ms has passed since last update
# R30 -> first timer options byte
# R36 = IO_Timer value at entry
# R38 = interval since last update, in ms
# R3A = IO timer delta since last ms, in IO timer ticks times 0x80 (??)
# R3C = Eighths_ext
#
691e: c7,74,5e,38         stb   R38,[R74+5e]     Bg_timer = R38;                   # time since last timer update (mSecs)
6922: 65,40,00,3a         ad2w  R3a,40           R3a += 40;                        # (remainder IO times*128) + 64 (rounding)
6926: 08,07,3a            shrw  R3a,7            R3a /= 80;                        # return to IOTIMES remainder
6929: 48,3a,36,32         sb3w  R32,R36,R3a      R32 = R36 - R3a;                  # effective time of this update (IOTIME-remainder)
692d: b1,20,3e            ldb   R3e,20           R3e = 20;                         # set Lmillisecs, = "new mS"
6930: 74,38,3c            ad2b  R3c,R38          R3c += R38;                       # add new mSs to current mS count
6933: 59,80,3c,3f         sb3b  R3f,R3c,80       R3f = R3c - 80;                   # R3f +ve if new 1/8 sec
6937: d3,0f               jltu  6948             if ((uns) R3f >= 0)  {
6939: b0,3f,3c            ldb   R3c,R3f          R3c = R3f;                        # remainder =- 1/8 sec (in mS)
693c: 91,40,3e            orb   R3e,40           Leighths = 1;                     # = "New 1/8 Sec"
693f: e0,3d,06            djnz  R3d,6948         R3d--;
                                                 if (R3d != 0) goto 6948;          # 1 Sec remainder (in 1/8 secs)
6942: 91,80,3e            orb   R3e,80           Lseconds = 1;                     # set "New second" (when R3d == 0)
6945: b1,08,3d            ldb   R3d,8            R3d = 8; } }                      # reset 1 sec remainder (= 8/8, counts down)
#
6948: c3,72,c0,3c         stw   R3c,[R72+c0]     Eighths_ext = R3c;                # store 1/8 sec remainder (in mSec)
694c: c3,72,c2,32         stw   R32,[R72+c2]     Loop_time = R32;                  # save IOTIME of last timer update (at true mS)
#
# Process one timer
# R30 -> timer options byte
# R3E = B7 set = update second; B6 set = update 1/8 second, B5 set = update ms
#
  Tmr_upd_loop:
6950: b2,31,3c            ldb   R3c,[R30++]      R3c = [R30++];                    # Check flag byte of timer entry
6953: 98,00,3c            cmpb  R3c,R0           
6956: df,58               je    69b0             if (R3c == 0) return;             # Hit end of table - return (exit)
#
6958: ae,31,32            ldzbw R32,[R30++]      R32 = (uns)[R30++];
695b: b2,31,33            ldb   R33,[R30++]      R33 = [R30++];                    # R32 = 16 bit address of timer
695e: 30,3c,12            jnb   B0,R3c,6973      if (Free_run == 0) goto 6973;     # short entry? Go to update
#
# Check timer enable flag
# R30 -> timer flag mask
# R32 -> timer (word or byte)
# R3C = timer options: B7 - seconds, B6 - 1/8 sec, B5 - ms, B3 - update on flag clear, B2 - count down, B1 - word timer, B0 - check flag
# R3E = B7 set = update second; B6 set = update 1/8 second, B5 set = update ms
#
6961: b2,31,3d            ldb   R3d,[R30++]      R3d = [R30++];                    # load mask from timer entry
6964: ae,31,34            ldzbw R34,[R30++]      R34 = (uns)[R30++];               # create 16 bit address for flags
6967: 72,34,3d            an2b  R3d,[R34]        R3d &= [R34];                     # AND flags data with entry mask
696a: 33,3c,04            jnb   B3,R3c,6971      if (Inverse == 0) goto 6971;      # flag on or off required ?
696d: df,04               je    6973             if (R3d == 0) goto 6973;          # Inverse - if flag zero, GO timer
696f: 27,df               sjmp  6950             goto Tmr_upd_loop;                # (flags set) skip this timer, loop to next entry
#
6971: df,dd               je    6950             if (R3d == 0) goto Tmr_upd_loop;  # (flags clr) skip this timer, loop to next entry
#
# Update the timer
# R30 -> options byte of next timer
# R32 -> timer (word or byte)
# R3C = timer options: B7 - seconds, B6 - 1/8 sec, B5 - ms, B3 - update on flag clear, B2 - count down, B1 - word timer, B0 - check flag
# R3E = B7 set = update second; B6 set = update 1/8 second, B5 set = update ms
#
6973: 50,3c,3e,00         an3b  R0,R3e,R3c       if (R3e & R3c == 0)               # time flags - has requested time increment passed?
6977: df,d7               je    6950               goto Tmr_upd_loop;              # no, loop to next entry
6979: 31,3c,05            jnb   B1,R3c,6981      if (Word_tmr == 1)  {             # Byte or Word timer
# Word timer
697c: a2,32,36            ldw   R36,[R32]        R36 = [R32];                      # read current Word value
697f: 20,03               sjmp  6984             goto 6984; }
# Byte timer
6981: be,32,36            ldsbw R36,[R32]        R36 = (int)[R32];                 # read current Byte value, sign extended
#
# R36 = current value of timer (sign extended if byte)
# R3C = timer options: B7 - seconds, B6 - 1/8 sec, B5 - ms, B3 - update on flag clear, B2 - count down, B1 - word timer, B0 - check flag
# R38 = msec since last updates
#
6984: 32,3c,04            jnb   B2,R3c,698b      if (Decrement == 0) goto 698b;    # OK - update. Up or Down
6987: 03,36               negw  R36              R36 = -R36;                       # negate value
6989: df,18               je    69a3             if (R36 == 0) goto 69a3;          # if zero jump straight to save
#
698b: 3d,3c,04            jb    B5,R3c,6992      if (Millisecs == 0)  {
698e: 07,36               incw  R36              R36++;                            # Not mSecs, increment timer
6990: 20,03               sjmp  6995             goto 6995; }

6992: 64,38,36            ad2w  R36,R38          R36 += R38;                       # add mSecs to timer
#
6995: d3,07               jnc   699e             if ((uns) R36 < 0) goto 699e;
6997: 01,36               clrw  R36              R36 = 0;                          # overflow, wrap to zero
6999: 3a,3c,07            jb    B2,R3c,69a3      if (Decrement == 0)  {             # down - jmp straight to save
699c: 05,36               decw  R36              R36--;                            # up, set -1 ?
699e: 32,3c,02            jnb   B2,R3c,69a3      if (Decrement == 1)  {             # jmp to save word/byte
69a1: 03,36               negw  R36              R36 = -R36; } } }
#
# Save new value
# R32 -> timer
# R36 = value
# R3C = timer options
#
  Tmr_save:
69a3: 31,3c,05            jnb   B1,R3c,69ab      if (Word_tmr == 1)  {
69a6: c2,32,36            stw   R36,[R32]        [R32] = R36;                      # save Word timer
69a9: 27,a5               sjmp  6950             goto Tmr_upd_loop; }
#
69ab: c6,32,36            stb   R36,[R32]        [R32] = R36;                      # save Byte timer
69ae: 27,a0               sjmp  6950             goto Tmr_upd_loop;
#
69b0: f0                  ret                    return;


###################################### 
# TIMERS Table 
# 3 or 5 byte entries
#
# byte 0 - options:
#  bit 0: 0 always update (3 byte entry), 1 conditional update (5 byte entry)
#  bit 1: 0 = 8 bit timer 1 = 16 bit timer
#  bit 2: 0 = count up 1 = count down
#  bit 3: 0 = count if flag set 1 = count if flag clear
#  (bit 4 not used)
#  bit 5: update every 1/1024 second (~msec)
#  bit 6: update every 1/8 second
#  bit 7: update every second
#
# byte 2-3 WORD = timer address
#
# if conditional (byte 0 odd): timer controlled by bit flags
# byte 4 = flag mask
# byte 5 = flag address
######################################

  Timer_list:
69b1: 20,36,01            struct 20, BAPTMR,                                       # Byte, mSecs, Up. Time since last BP pulse
69b4: 89,c8,00,80,a1      struct 89, ATMR1, CRKFLG,                                # Byte, Secs, Up. Time since CRKFLG = 0
69b9: 81,c9,00,40,24      struct 81, ATMR2, ATMR2_On,                              # Byte, Secs, Up. Time since ECT > TEMPFB
69be: 89,4d,01,04,a1      struct 89, ATMR3, UNDSP,                                 # Byte, Secs, Up. Time since entering RUN mode
69c3: 81,66,02,80,27      struct 81, LESTMR1, LESTMR1_On,                          # Byte, Secs, Up. Time since LESTMR1_On = 1(EGO)
69c8: 81,67,02,40,27      struct 81, LESTMR2, LESTMR2_On,                          # Byte, Secs, Up. Time since LESTMR2_On = 1(EGO)
69cd: 81,cb,00,04,24      struct 81, AWOTMR, AWOTMR_On,                            # Byte, Secs, Up. Time since AWOTMR_On = 1
69d2: 81,cd,00,20,24      struct 81, NACTMR, NACTMR_On,                            # Byte, Secs, Up. Time since NACTMR_On = 1(Not At Closed Throttle)
69d7: 83,3a,01,01,a1      struct 83, ADPTMR, ADPTMR_On,                            # Word, Secs, Up. Time since ADPTMR_On = 1(Adaptive Fuel)
69dc: 41,45,01,80,ed      struct 41, LUGTMR, LUGTMR_up,                            # Byte, 1/8s, Up. Time since LUGTMR_up = 1
69e1: 45,45,01,40,ed      struct 45, LUGTMR, LUGTMR_dwn,                           # Byte, 1/8s, Down. Time since LUGTMR_dwn = 1
69e6: 80,4e,01            struct 80, EDFTMR,                                       # Byte, Secs, Up.                         (Electric fan, not in A9L)
69e9: 40,ca,01            struct 40, VIPTMR,                                       # Byte, 1/8s, Up.                         (Self test)
69ec: 42,c0,01            struct 42, MILTMR,                                       # Word, 1/8s, Up.                         (Check Engine light)
69ef: 22,34,01            struct 22, PUTMR,                                        # Word, mSecs, Up.                        (Time since EEC power-up)
69f2: 41,c8,01,20,2b      struct 41, TSSTIL, STIFLG,                               # Byte, 1/8s, Up. Time since STIFLG = 1   (KOEO self test)
69f7: 83,c2,01,40,2a      struct 83, OUTTMR, No_start,                             # Word, Secs, Up. Time since No_start = 1 (KOEO self test)
69fc: 22,3e,01            struct 22, TSLPIP,                                       # Word, mSecs, Up.                        (Time Since Last PIP)
69ff: 22,c4,01            struct 22, TSLIDM,                                       # Word, mSecs, Up.                        (Continuous test)
6a02: 81,37,01,04,eb      struct 81, HMTMR, HMTMR_On,                              # Byte, Secs, Up. Time since HMTMR_On = 1 (Thermactor)
6a07: 49,4c,01,01,29      struct 49, HLTMR, HLTMR_Off,                             # Byte, 1/8s, Up. Time since HLTMR_Off = 0(High Load)
6a0c: 80,38,01            struct 80, CTATMR,                                       # Byte, 1/8s, Up.                         (Thermactor)
6a0f: 41,2a,01,40,a1      struct 41, CTTMR, CTTMR_On,                              # Byte, 1/8s, Up. Time since APT = -1     (Closed throttle) 
6a14: 81,44,01,02,e8      struct 81, CTNTMR, Ctntmr_up,                            # Byte, Secs, Up. Time since Ctntmr_up = 1
6a19: 85,44,01,01,e8      struct 85, CTNTMR, Ctntmr_dwn,                           # Byte, Secs, Down. Time since Ctntmr_dwn = 1
6a1e: 89,20,02,01,24      struct 89, NWOTMR, Wot,                                  # Byte, Secs, Up. Time since Wot = 0 (Not WOT)
6a23: 81,ce,00,01,ec      struct 81, MFATMR, MFAFLG,                               # Byte, Secs, Up. Time since MFAFLG = 1   (Managed Fuel Air)
6a28: 81,64,02,80,24      struct 81, TSEGRE, TSEGRE_On,                            # Byte, Secs, Up. Time since TSEGRE_On = 1(EGR)
6a2d: 23,1e,02,40,4f      struct 23, TSLADV, KNOCK_ENABLED,                        # Word, mSecs, Up. Time since KNOCK_ENABLED = 1 (Not used in A9L)
6a32: 80,46,01            struct 80, ISCTMR,                                       # Byte, Secs, Up.                         (ISC logic)
6a35: 20,47,01            struct 20, MULTMR,                                       # Byte, mSecs, Up. 
6a38: 40,cc,00            struct 40, NDDTIM,                                       # Byte, 1/8s, Up.                         (Neutral/drive transition)
6a3b: 42,16,02            struct 42, ACCTMR,                                       # Word, 1/8s, Up.                         (A/C clutch) 
6a3e: 80,14,02            struct 80, ACWTMR,                                       # Byte, Secs, Up.                         (A/C clutch, WOT)
6a41: 40,15,02            struct 40, WCOTMR,                                       # Byte, 1/8s, Up.                         (A/C clutch, WOT)
6a44: 23,18,02,04,ea      struct 23, ACITMR, ACIFLG,                               # Word, mSecs, Up. Time since ACIFLG = 1  (A/C clutch)
6a49: 41,13,02,02,ea      struct 41, ACBTMR, BIFLG,                                # Byte, 1/8s, Up. Time since BIFLG = 1    (A/C clutch)
6a4e: 41,39,01,40,ec      struct 41, SLTMR, SLTMR_flg,                             # Byte, mSecs, Up. Time since SLTMR_flg = 1
6a53: 26,a8,02            struct 26, DEBTMR,                                       # Word, mSecs, Down.                      (SCCS debounce)
6a56: 20,bb,02            struct 20, TSLMPH,                                       # Byte, mSecs, Up.
6a59: 40,4f,01            struct 40, CRKTMR,                                       # Byte, 1/8s, Up.                         (Cranking fuel)
6a5c: 81,49,01,40,ef      struct 81, PRGTMR, Prgflg,                               # Byte, Secs, Up. Time since Prgflg = 1   (Canister purge)
6a61: 41,4a,01,40,ef      struct 41, CPRGTMR, Prgflg,                              # Byte, 1/8s, Up. Time since Prgflg = 1
6a66: 21,50,01,08,a1      struct 21, DLTMR, DMFLG,                                 # Byte, mSecs, Up. Time since DMFLG = 1
6a6b: 22,32,01            struct 22, FFMTMR,                                       # Word, mSecs, Up.                        (Filtered Air Mode)
6a6e: 40,c9,01            struct 40, VSSTMR,                                       # Byte, 1/8s, Up. 
6a71: 40,c6,01            struct 40, VIP_FPMTMR,                                   # Byte, 1/8s, Up. 
6a74: 22,aa,03            struct 22, HWTMR,                                        # Word, mSecs, Up.                        (Heated w/s)
6a77: 22,a8,03            struct 22, A3CTMR,                                       # Word, mSecs, Up.                        (A/C clutch, heated w/s)
6a7a: 00                  byte 0                                                   # END OF TIMER TABLE


#################################################################
# Tasklist Routine at 2151, routine offset 46
# Update shift light (not present on A9L)
# GUFB pp. 18-3, 18-4
#################################################################

  Upd_ShiftL:
6a7b: b3,fe,03,30         ldb   R30,[Rfe+3]      R30 = TSTRAT;                     # 9E5D=0(Manual trans) - TSTRAT - transmission stratagey
6a7f: 99,01,30            cmpb  R30,1                                              # 1 = SIL (Shift Indicator Light) present
6a82: d7,55               jne   6ad9             if (TSTRAT == 1)  {               # not present on A9L
6a84: 38,d0,2d            jb    B0,Rd0,6ab4      if (APT == 0)  {                  # jmp if not @ part throttle
6a87: 45,34,00,f0,32      ad3w  R32,Rf0,34       R32 = Fn651;                      # Table 8C34 - Incremental Indicated RPM shift point as a function of ECT
6a8c: bc,b0,34            ldsbw R34,Rb0          R34 = (int)ECT;
6a8f: ef,6f,cb            call  3601             SUWordLU();
6a92: c0,14,38            stw   R38,R14          R14 = R38;
6a95: 45,50,00,f0,32      ad3w  R32,Rf0,50       R32 = Fn652A;                     # Table 8C50 - Indicated RPM shift point as a function of LOAD.
6a9a: a3,74,de,34         ldw   R34,[R74+de]     R34 = LOAD;                       # engine load (VE)
6a9e: ef,6b,cb            call  360c             UUWordLu();
6aa1: 64,38,14            ad2w  R14,R38          R14 += R38;                       # add RPM shift points
6aa4: 8b,f0,0c,ae         cmpw  Rae,[Rf0+c]                                        # ROM 8C0C - SPTRPM
6aa8: d9,05               jgtu  6aaf             if ((uns) N > SPTRPM) goto 6aaf;
6aaa: 88,14,ae            cmpw  Rae,R14          
6aad: d1,05               jleu  6ab4             if ((uns) N > FN651(ECT) + FN652A(LOAD))  {
#
6aaf: 91,40,ec            orb   Rec,40           SLTMR_flg = 1;                    # enable SLTMR
6ab2: 20,07               sjmp  6abb             goto 6abb; } }
#
6ab4: 71,bf,ec            an2b  Rec,bf           SLTMR_flg = 0;                    # disable timer
6ab7: c7,72,b9,00         stb   R0,[R72+b9]      SLTMR = 0;                        # and clear it
6abb: 3f,a1,1b            jb    B7,Ra1,6ad9      if (CRKFLG == 0)  {
6abe: 8b,f0,0e,ae         cmpw  Rae,[Rf0+e]      
6ac2: d9,10               jgtu  6ad4             if ((uns) N > SHIRPM) goto 6ad4; # turn on light irrespective of timer
6ac4: b3,72,b9,30         ldb   R30,[R72+b9]     R30 = SLTMR;                      # 139 Shift Light Timer
6ac8: 9b,f0,10,30         cmpb  R30,[Rf0+10]     

6acc: d1,0b               jleu  6ad9             if ((uns) R30 > SLTIM1)  {
6ace: 9b,f0,11,30         cmpb  R30,[Rf0+11]     
6ad2: d9,05               jgtu  6ad9             if ((uns) R30 <= SLTIM2)  {
6ad4: 91,04,47            orb   R47,4            ShLight_On = 1;                   # R47 bit 2 ON Shift Light
6ad7: 20,03               sjmp  6adc             return; } } } }
# Jump to here if no shift light
6ad9: 71,fb,47            an2b  R47,fb           ShLight_On = 0;                   # R47 bit 2 OFF Shift Light
6adc: f0                  ret                    return;


#################################################################
# Tasklist Routine at 2151, routine offset 48
#################################################################

  Upd_Adj_Shocks:
6add: 9b,f6,66,00         cmpb  R0,[Rf6+66]                                        # 940E - HPACL
6ae1: df,25               je    6b08             if (0 != HPACL)  {                # return if no adjustable shocks present
6ae3: 3f,a1,0a            jb    B7,Ra1,6af0      if (CRKFLG == 1) goto 6af0;
6ae6: a3,74,d4,30         ldw   R30,[R74+d4]     R30 = ARCHG;
6aea: 8b,f6,68,30         cmpw  R30,[Rf6+68]     
6aee: db,10               jgeu  6b00             if ((uns) R30 >= SHKCHG) goto 6b00;
#
6af0: a3,01,26,01,30      ldw   R30,[R0+126]     R30 = RATCH;                      # 126 - Filtered TP
6af5: 67,f6,6a,30         ad2w  R30,[Rf6+6a]     R30 += SHKTP;                     # 9412 - SHKTP
6af9: db,0a               jc    6b05             if (R30 > 0)  {                   # jump if overflow
6afb: 88,30,aa            cmpw  Raa,R30                                            # RAA is Throttle position
6afe: d3,05               jltu  6b05             if ((uns) TP >= RATCH + SHKTP)  {
#
6b00: 91,10,47            orb   R47,10           TAD = 1;                          # R47 bit 4 ON (Air management2)
6b03: 20,03               sjmp  6b08             return; } }
#
6b05: 71,ef,47            an2b  R47,ef           TAD = 0; }                        # R47 bit 4 OFF (Air management2)
6b08: f0                  ret                    return;

#
# SIGKAL and MKAY calculations - GUFB p. 7-19
#
# Called only from PIP high handler, i.e. in interrupt context
# Only for non HIDRES equipped engines (e.g. A9L)
#
# RBC:RBA: DT12S (# of ticks since last PIP high)
#
  Sub36:
6b09: 31,eb,03            jnb   B1,Reb,6b0f      if (SIGPIP == 0) goto 6b0f;       # Skip SIGKAL calculation if !SIGPIP (not a signature PIP period)
6b0c: 3e,2e,02            jb    B6,R2e,6b11      if (SYNFLG == 1) goto 6b11;       #  or !SYNFLG (not yet sync'd)
#
6b0f: 20,7d               sjmp  6b8e             goto 6b8e;
#
# Signature Kay calculation is done after every Signature PIP
#
# DTSIG = Last Signature PIP period
# SIGKAL = Signature PIP half period multiplier (fraction, 0x8000 = 1.0; 1 < SIGKAL < 2)
# 
6b11: 4b,76,c6,ba,50      sb3w  R50,Rba,[R76+c6] R50 = DT12S - DTSIG;
6b16: db,02               jc    6b1a             if (R50 < 0)  {
6b18: 03,50               negw  R50              R50 = -R50; }                     # Take absolute value
#
6b1a: c3,76,c6,ba         stw   Rba,[R76+c6]     DTSIG = DT12S;
6b1e: a3,f0,0a,54         ldw   R54,[Rf0+a]      R54 = SSFCTR;                     # Steady State Factor
6b22: 6c,ba,54            ml2w  R54,Rba          R57:R54 = SSFCTR * DT12S;         # 
6b25: 88,56,50            cmpw  R50,R56                                            # 
6b28: db,64               jgeu  6b8e             if (R50 < R56)  {                 # Jump if |DT12S - DTSIG| = SSFCTR * DT12S
6b2a: 4b,76,ba,ba,50      sb3w  R50,Rba,[R76+ba] R50 = DT12S - DT23S;              # 
6b2f: db,02               jgeu  6b33             if (R50 > 0)  {
6b31: 03,50               negw  R50              R50 = -R50; }                     # Take absolute value
#
6b33: 88,56,50            cmpw  R50,R56          
6b36: db,56               jgeu  6b8e             if (R50 > R56)  {                 # Jump if |DT12S - DT23S| >= SSFCTR * DT12S
6b38: a3,76,c2,50         ldw   R50,[R76+c2]     R50 = SIGDLT;                     # Uncorrected signature PIP half period
6b3c: c0,54,50            stw   R50,R54          R54 = R50;
6b3f: c0,58,50            stw   R50,R58          R58 = R50;
6b42: 6b,76,c4,50         sb2w  R50,[R76+c4]     R50 = SIGDLT - PSGDLT;            # PSGDLT = previous value of SIGDLT
6b46: db,02               jc    6b4a             if (R50 > 0)  {
6b48: 03,50               negw  R50              R50 = -R50; }                     # Take absolute value
#
6b4a: a3,f0,0a,56         ldw   R56,[Rf0+a]      R56 = SSFCTR;
6b4e: 6c,56,54            ml2w  R54,R56          R57:R54 = SIGDLT * SSFCTR;
6b51: 88,56,50            cmpw  R50,R56          
6b54: db,38               jgeu  6b8e             if (R50 > R56)  {                 # Jump if |SIGDLT - PSGDLT| >= SSFCTR * SIGDLT
#
# R58 (word) = SIGDLT
#
6b56: a0,ba,56            ldw   R56,Rba          R56 = DT12S;
6b59: 01,54               clrw  R54              R54 = 0;
6b5b: 0c,02,54            shrdw R54,2            R57:R54 /= 4;
6b5e: 8c,58,54            divw  R54,R58          R55:R54 = R57:R54 / R59:R58;      # sigkal' = DT12S/(SIGDLT * 2)
6b61: dd,2b               jv    6b8e             if (OVF == 0)  {                  # Jump if division overflkowed
#
# R54 (word) = sigkal'; scaled so that 0x8000 = 1
#
6b63: a3,f2,04,50         ldw   R50,[Rf2+4]      R50 = FKSKAY;                     # Filter constant for SIGKAL updates (unsigned fraction)
6b67: 6c,50,54            ml2w  R54,R50          R57:R54 = sigkal' * FKSKAY;       # R56 = FKSKAY * sigkal'
6b6a: 03,50               negw  R50              R50 = 1 - R50;
6b6c: a3,76,c0,52         ldw   R52,[R76+c0]     R52 = SIGKAL;                     #
6b70: 6c,52,50            ml2w  R50,R52          R53:R50 = (1 - FKSKAY) * SIGKAL;  # R52 = (1 - FKSKAY) * SIGKAL
6b73: 64,52,56            ad2w  R56,R52          R56 += R52;                       # R56 = (FKSKAY * sigkal') + ((1 - FKSKAY) * SIGKAL)
6b76: 8b,f2,06,56         cmpw  R56,[Rf2+6]      
6b7a: db,04               jgeu  6b80             if (R56 < SIGKLL)  {
6b7c: a3,f2,06,56         ldw   R56,[Rf2+6]      R56 = SIGKLL; }                   # Clip to SIGKLL (= 1.25)
#
6b80: 8b,f2,08,56         cmpw  R56,[Rf2+8]      
6b84: d1,04               jleu  6b8a             if ((uns) R56 > SIGKLU )  {
6b86: a3,f2,08,56         ldw   R56,[Rf2+8]      R56 = SIGKLU; }                   # Clip to SIGKLU (= 1.6666)
#
6b8a: c3,76,c0,56         stw   R56,[R76+c0]     SIGKAL = R56; } } } }             # Save as SIGKAL
#
# Calculate MKAY - 
#
# Jump here from:
#  6b0f (!SIGPIP || !SYNFLG)                    i.e. not a signature PIP period or not in sync
#  6b28 (|DT12S - DTSIG| = SSFCTR * DT12S)      i.e. not steady state (engine speed changed too much since 2 revolutions ago)
#  6b36 (|DT12S - DT23S| >= SSFCTR * DT12S)     i.e. not steady state (engine speed changed too much between subsequent cylinders)
#  6b54 (|SIGDLT - PSGDLT| >= SSFCTR * SIGDLT)  i.e. not steady state (observed delta not consistent enough)
#  6b61 (sigkal' division overflowed)
#
# KAYCTR = update counter - initialized to 0 at EEC startup, max value ENGCYL + 1
#
# MKAY is updated roughly every other engine revolution, but never on a Signature PIP period.
# 
6b8e: 9b,fe,07,bd         cmpb  Rbd,[Rfe+7]      
6b92: d1,0c               jleu  6ba0             if ((uns) KAYCTR > ENGCYL)  {
#
6b94: b1,01,bd            ldb   Rbd,1            KAYCTR = 1;
6b97: c3,74,22,ba         stw   Rba,[R74+22]     DTPCYC = DT12S;
6b9b: c3,74,24,be         stw   Rbe,[R74+24]     HFPCYC = HFDLTA;
6b9f: f0                  ret                    return; }
#
# KAYCTR <= ENGCYL
#
6ba0: 17,bd               incb  Rbd              KAYCTR++;
6ba2: 9b,fe,07,bd         cmpb  Rbd,[Rfe+7]      
6ba6: d1,6b               jleu  6c13             if ((uns) KAYCTR <= ENGCYL) return;
#
# KAYCTR == ENGCYL at entry
#
6ba8: 39,eb,68            jb    B1,Reb,6c13      if (SIGPIP == 1) return;
#
6bab: 4b,74,22,ba,50      sb3w  R50,Rba,[R74+22] R50 = DT12S - DTPCYC;
6bb0: db,02               jc    6bb4             if (R50 > 0)  {
6bb2: 03,50               negw  R50              R50 = -R50; }                     # take absolute value
#
6bb4: a3,f0,0a,52         ldw   R52,[Rf0+a]      R52 = SSFCTR;
6bb8: 4c,52,ba,54         ml3w  R54,Rba,R52      R57:R54 = DT12S * SSFCTR;
6bbc: 88,56,50            cmpw  R50,R56          
6bbf: d9,52               jgtu  6c13             if ((uns) R50 > R56 ) return;     # Jump if |DT12S - DTPCYC| > DT12S * SSFCTR
#
6bc1: 4b,74,24,be,50      sb3w  R50,Rbe,[R74+24] R50 = HFDLTA - HFPCYC;
6bc6: db,02               jc    6bca             if (R50 > 0)  {
6bc8: 03,50               negw  R50              R50 = -R50; }                     # take absolute value
#
6bca: 4c,52,be,54         ml3w  R54,Rbe,R52      R57:R54 = HFDLTA * SSFCTR;
6bce: 88,56,50            cmpw  R50,R56          
6bd1: d9,40               jgtu  6c13             if ((uns) R50 > R56 ) return;     # Jump if |HFDLTA - HFPCYC| > HFDLTA * SSFCTR
6bd3: 01,54               clrw  R54              R54 = 0;
6bd5: 47,74,22,ba,56      ad3w  R56,Rba,[R74+22] R56 = DT12S + DTPCYC;
6bda: db,37               jc    6c13             if (unsigned overflow) return;    # Jump on unsigned overflow
6bdc: 0c,02,54            shrdw R54,2            R57:R54 /= 4;
6bdf: 47,74,24,be,50      ad3w  R50,Rbe,[R74+24] R50 = HFDLTA + HFPCYC;
6be4: db,2d               jc    6c13             if (unsigned overflow) return;    # Jump on unsigned overflow
6be6: 8c,50,54            divw  R54,R50          R55:R54 = (DT12S + DTPCYC) / ((HFDLTA + HFPCYC) * 2);
6be9: dd,28               jv    6c13             if (OVF == 1) return;       
6beb: 89,99,99,54         cmpw  R54,9999         
6bef: db,22               jgeu  6c13             if (mkay' >= 1.25) return;        # 0x9999 = 1.249... (unsigned fraction)
6bf1: 4d,00,e0,c0,50      ml3w  R50,Rc0,e000     R53:R50 = MKAY * 0xe000;          # 0xe000 = 0.875 = 1 - FKMKAY
6bf6: 6d,00,20,54         ml2w  R54,2000         R57:R54 = R55:R54 * 0x2000;       # 0x2000 = 0.125 = FKMKAY
6bfa: 44,52,56,c0         ad3w  Rc0,R56,R52      MKAY = R56 + R52;                 # MKAY = (FKMKAY * mkay') + ((1 - FKMKAY) * MKAY)
6bfe: 89,33,73,c0         cmpw  Rc0,7333                                           # = KLLIM = 0.9 (unsigned fraction)
6c02: db,05               jgeu  6c09             if (MKAY < 7333)  {
6c04: a1,33,73,c0         ldw   Rc0,7333         MKAY = 7333;                      # Clip to KLLIM
6c08: f0                  ret                    return; }
#
6c09: 89,cd,8c,c0         cmpw  Rc0,8ccd                                           # = KULIM = 1.1 (unsigned fraction)
6c0d: d1,04               jleu  6c13             if ((uns) MKAY <= 8ccd) return;
6c0f: a1,cd,8c,c0         ldw   Rc0,8ccd         MKAY = 8ccd; }                    # Clip to KULIM
#
# Jump here from:
#  6ba6 (KAYCTR <= ENGCYL)
#  6ba8 (SIGPIP == 1)
#  6bbf (|DT12S - DTPCYC| > DT12S * SSFCTR)     i.e. not steady state
#  6bd1 (|HFDLTA - HFPCYC| > HFDLTA * SSFCTR)   i.e. not steady state
#  6bda (DT12S + DTPCYC > 65535)                
#  6be4 (HFDLTA + HFPCYC > 65535)
#  6be9 (Division overflowed)
#  6bef (mkay' >= 1.25)
#  6c0d (0.9 < MKAY < 1.1)
6c13: f0                  ret                    return;


#
# Part of Transient Spark Compensation Logic
# Called from PIP up-edge handler (i.e. in interrupt context)
# GUFB p. 7-27
#
  Sub37:
6c14: a0,be,54            ldw   R54,Rbe          R54 = HFDLTA;                     # # of ticks between previous PIP up edge and following down edge
6c17: 6c,c0,54            ml2w  R54,Rc0          R57:R54 = R55:R54 * MKAY;         # MKAY scaled so that 0x8000 = 1; see above
6c1a: 99,40,57            cmpb  R57,40           
6c1d: d3,02               jltu  6c21             if ((uns) R57 < 40) goto 6c21;
#
# HFDLTA * MKAY >= 0x4000, i.e. SHLDW immediately below would overflow, so return
6c1f: 20,6d               sjmp  6c8e             return;
#
6c21: 0d,02,54            shldw R54,2            R57:R54 *= 4;                     # R56 (word) = 2 * HFDLTA * MKAY
6c24: 48,56,ba,50         sb3w  R50,Rba,R56      R50 = DT12S - R56;                # PIP time lo 16 bits with correction
6c28: db,02               jc    6c2c             if (R50 > 0)  {
6c2a: 03,50               negw  R50              R50 = -R50; }                     # Take absolute value
#
# R50 (word): DIFF0
#
6c2c: a3,76,ba,54         ldw   R54,[R76+ba]     R54 = DT23S;
6c30: 6b,76,bc,54         sb2w  R54,[R76+bc]     R54 -= PHFDLT;
6c34: 6c,be,54            ml2w  R54,Rbe          R57:R54 = R55:R54 * HFDLTA;       # 
6c37: 8f,76,bc,54         divw  R54,[R76+bc]     R55:R54 = R57:R54 / PHFDLT;       # R54 (word) = HFDLTA * (DT23S - PHFDLT) / PHFDLT
6c3b: dd,51               jv    6c8e             if (OVF == 1) return;
6c3d: 64,be,54            ad2w  R54,Rbe          R54 += HFDLTA;
6c40: db,4c               jc    6c8e             if (unsigned overflow) return;    # Addition overflowed
6c42: 48,54,ba,52         sb3w  R52,Rba,R54      R52 = DT12S - R54;
6c46: db,02               jc    6c4a             if (R52 > 0)  {
6c48: 03,52               negw  R52              R52 = -R52; }                     # Take absolute value
#
# R50 (word): DIFF0
# R52 (word): DIFF1
#
6c4a: b3,76,be,54         ldb   R54,[R76+be]     R54 = TL0FLG;
6c4e: 11,56               clrb  R56              R56 = 0;
6c50: 88,52,50            cmpw  R50,R52          
6c53: d9,1b               jgtu  6c70             if ((uns) DIFF0 <= DIFF1)  {
#
6c55: 37,54,0a            jnb   B7,R54,6c62      if (B7_R54 == 1)  {               # (MSB of) TL0FLG set
6c58: b3,76,bf,56         ldb   R56,[R76+bf]     R56 = DIFCTR;
6c5c: 17,56               incb  R56              R56++;
6c5e: d3,02               jnc   6c62             if ((uns) R56 >= 0)  {
6c60: 15,56               decb  R56              R56--; } }                        # Clip DIFCTR to 255
#
# Jump here from:
#  6c55 (!TL0FLG)
#  6c5e (DIFCTR <= 255)
#
6c62: c7,76,bf,56         stb   R56,[R76+bf]     DIFCTR = R56;
6c66: 9b,fe,14,56         cmpb  R56,[Rfe+14]     
6c6a: d3,22               jltu  6c8e             if ((uns) DIFCTR < DFMIN0) return;
6c6c: 11,54               clrb  R54              R54 = 0;                          # Clear TL0FLG
6c6e: 20,1a               sjmp  6c8a             goto 6c8a; }
#
# Jump here from:
#  6c53 (DIFF0 > DIFF1)
#
6c70: 3f,54,0a            jb    B7,R54,6c7d      if (B7_R54 == 0)  {
6c73: b3,76,bf,56         ldb   R56,[R76+bf]     R56 = DIFCTR;
6c77: 17,56               incb  R56              R56++;
6c79: d3,02               jnc   6c7d             if ((uns) R56 >= 0)  {
6c7b: 15,56               decb  R56              R56--; } }                        # Clip DIFCTR to 255
#
# Jump here from:
#  6c70 (!TL0FLG)
#
6c7d: c7,76,bf,56         stb   R56,[R76+bf]     DIFCTR = R56;
6c81: 9b,fe,15,56         cmpb  R56,[Rfe+15]     
6c85: d3,07               jltu  6c8e             if ((uns) R56 < DFMIN1) return;
6c87: b1,80,54            ldb   R54,80           R54 = 80;                         # Set (MSB of) TL0FLG
#
# Jump here from:
#  6c6e (DIFCTR >= DFMIN0)
#
# R54 = new value for TL0FLG, either 0 or 80
#
6c8a: c7,76,be,54         stb   R54,[R76+be]     TL0FLG = R54;
#
# Jump here from:
#  6c1f: HFDLTA * MKAY > 0x4000
#  6c3b: Division overflowed
#  6c40: Addition overflowed
#  6c6a: DIFCTR < DFMIN0
#  6c85: DIFCTR < DFMIN1
#  
6c8e: f0                  ret                    return;

#################################################################
# handle HSI line 1 data - Knock sensor
# check for Knock if reqd
# N.B. Not used in A9L
# *** CALLED IN INTERRUPT HANDLER CONTEXT ***
#################################################################
  Knk_inth:
6c8f: 71,fd,87            an2b  R87,fd           Knk_irq = 0;                      # mask HSI data
6c92: 9b,f8,4a,00         cmpb  R0,[Rf8+4a]                                        # 947A KIHP = 00 ( is there a knock sensor )
6c96: df,06               je    6c9e             if (0 != KIHP)  {                 # jump if line data = 0
6c98: 91,08,4f            orb   R4f,8            KNOCK_DETECTED = 1;               # set KNOCK DETECTED
6c9b: 91,08,d9            orb   Rd9,8            Vip_knock = 1; }                  # set VIP KNOCK
6c9e: f0                  ret                    return;

#
# Knock Detection Logic
# GUFB p. 7-38
#
  Sub38:
6c9f: 9b,f8,4a,00         cmpb  R0,[Rf8+4a]                                        # KIHP - Knock Sensor Hardware Present (0 on A9L)
6ca3: d7,01               jne   6ca6             if (0 == KIHP)  {
6ca5: f0                  ret                    return; }
#
6ca6: 8b,f8,44,ae         cmpw  Rae,[Rf8+44]                                       # ROM 9474 - RPMCNL
6caa: d1,12               jleu  6cbe             if ((uns) N > RPMCNL )  {         # jmp if N <= RPMCNL
6cac: 9b,f8,49,dd         cmpb  Rdd,[Rf8+49]                                       # KWCTR : ROM 9479 - WINCLD
6cb0: db,0c               jgeu  6cbe             if (KWCTR > WINCLD)  {            # jmp if KWCTR >= WINCLD
6cb2: 33,4f,03            jnb   B3,R4f,6cb8      if (KNOCK_DETECTED == 1)  {       # jmp if not KNOCK DETECTED
6cb5: 17,dd               incb  Rdd              KWCTR++;                          # KWCTR
6cb7: f0                  ret                    return; }
#
6cb8: 31,eb,03            jnb   B1,Reb,6cbe      if (SIGPIP == 1)  {               # SIGPIP
6cbb: 17,dd               incb  Rdd              KWCTR++;                          # KWCTR
6cbd: f0                  ret                    return; } } }
#
6cbe: 11,dd               clrb  Rdd              KWCTR = 0;                        # KWCTR
6cc0: a1,22,03,7e         ldw   R7e,322          Rtab = Q9;                        # QUEUE 9
6cc4: 9b,7e,01,00         cmpb  R0,[R7e+1]                                         # 323
6cc8: df,04               je    6cce             if (0 != [Rtab+1])  {
6cca: 91,02,4e            orb   R4e,2            Kts_pending = 1;
# 2284 proc address
6ccd: f0                  ret                    return; }

6cce: 28,15               scall 6ce5             Sub39();
6cd0: a1,86,22,92         ldw   R92,2286         TPtr = 2286;
6cd4: ef,22,b8            call  24f9             Do_CmdN();
6cd7: f0                  ret                    return;

#
# Called from HSO table handler for KTS off
# Not used in A9L
#
  Add_H_Beta:
6cd8: 39,4e,07            jb    B1,R4e,6ce2      if (Kts_pending == 0)  {
6cdb: c7,7e,01,00         stb   R0,[R7e+1]       [Rtab+1] = 0;
6cdf: cc,00               pop   R0               R0 = pop();
6ce1: f0                  ret                    return; }

6ce2: 71,fd,4e            an2b  R4e,fd           Kts_pending = 0;                  # clr R4E bit 1

  Sub39:
6ce5: 4c,c0,be,50         ml3w  R50,Rbe,Rc0      R53:R50 = HFDLTA * MKAY;
6ce9: 99,40,53            cmpb  R53,40           
6cec: db,12               jgeu  6d00             if (R53 > 40)  {
6cee: 0d,02,50            shldw R50,2            R53:R50 *= 4;
6cf1: a0,52,50            ldw   R50,R52          R50 = R52;
6cf4: 6f,74,a8,50         ml2w  R50,[R74+a8]     R53:R50 = R51:R50 * Htime_beta;
6cf8: 3f,53,05            jb    B7,R53,6d00      if (B7_R53 == 0)  {
6cfb: 0d,01,50            shldw R50,1            R53:R50 *= 2;
6cfe: 20,03               sjmp  6d03             goto 6d03; } }
#
6d00: bd,ff,52            ldsbw R52,ff           R52 = 0xffff;
#
6d03: 47,74,50,52,80      ad3w  R80,R52,[R74+50] HSO_time = R52 + Prev_PIP_time;   # last saved PIP event time (24 bits)
6d08: b3,74,52,82         ldb   R82,[R74+52]     HSO_timeH = Prev_PIP_timeH;
# Jump here from 6d15
6d0c: b4,00,82            adcb  R82,R0           HSO_timeH += CY;
6d0f: f8                  clc                    CY = 0
6d10: f0                  ret                    return;

#################################################################
# Knock sensor HSO logic
# Called from HSO KTS On handler
# Not used in A9L
#################################################################

  Add_H_Delta:
6d11: 67,74,aa,80         ad2w  R80,[R74+aa]     HSO_time += Htime_delta;
6d15: 27,f5               sjmp  6d0c             goto 6d0c;

#################################################################
# Background Tasklist Routine at 2151, routine offset 36
#################################################################

  UPd_KnkRet:
6d17: 3f,4e,02            jb    B7,R4e,6d1c      if (New_pip == 1) goto 6d1c;       # New PIP received flag
6d1a: 20,8e               sjmp  6daa             goto UPd_TipRet;
#
# Calculate Knock Threshold Sense factors
# GUFB p. 7-37
#
6d1c: 45,62,03,f8,32      ad3w  R32,Rf8,362      R32 = FN145;                      # 
6d21: a0,ae,34            ldw   R34,Rae          R34 = N;
6d24: 08,07,34            shrw  R34,7            R34 /= 80;                        # = RPM / 128
6d27: ef,8d,c8            call  35b7             UUbyteLu();
6d2a: 09,07,38            shlw  R38,7            R38 *= 80;                        # Table output * 128
6d2d: 67,f8,40,38         ad2w  R38,[Rf8+40]     R38 += WOPEN;                     # += WOPEN
6d31: c3,74,a8,38         stw   R38,[R74+a8]     Htime_beta = R38;                 # Knock sensor open offset
6d35: 45,54,03,f8,32      ad3w  R32,Rf8,354      R32 = FN144;                      # output is fraction of PIP Period.
6d3a: a0,ae,34            ldw   R34,Rae          R34 = N;
6d3d: 08,07,34            shrw  R34,7            R34 /= 80;                        # Table output * 128
6d40: ef,74,c8            call  35b7             UUbyteLu();
6d43: 6c,ba,38            ml2w  R38,Rba          R3B:R38 = R39:R38 *= DT12S;       # RBA - PIP time lo 16 bits
6d46: 0d,06,38            shldw R38,6            R3B:R38 *= 40;                    # multiply by 64
6d49: 67,f8,42,3a         ad2w  R3a,[Rf8+42]     R3a += WINLEN;                    # 9472 - WINLEN
6d4d: c3,74,aa,3a         stw   R3a,[R74+aa]     Htime_delta = R3a;                # Knock sensor open width
#
# Calculate Knock Spark Retard increment
# GUFB p. 7-40
#
6d51: 45,48,03,f8,32      ad3w  R32,Rf8,348      R32 = FN143A;                     # Retard increment versus RPM, deg.
6d56: a0,ae,34            ldw   R34,Rae          R34 = N;
6d59: 08,07,34            shrw  R34,7            R34 /= 80;                        # Table output * 128
6d5c: ef,58,c8            call  35b7             UUbyteLu();
6d5f: c4,e2,38            stb   R38,Re2          RETINC = FN143A(N);               # Retard ramp-out increment
#
# Knock Spark Advance Logic
# GUFB p. 7-43
#
6d62: 36,4f,45            jnb   B6,R4f,6daa      if (KNOCK_ENABLED == 1)  {        # always 0 in A9L
6d65: 45,6c,03,f8,32      ad3w  R32,Rf8,36c      R32 = FN146B;                     # Spark Advance Rate vs RPM
6d6a: a0,ae,34            ldw   R34,Rae          R34 = N;
6d6d: 08,07,34            shrw  R34,7            R34 /= 80;                        # RPM / 128
6d70: ef,44,c8            call  35b7             UUbyteLu();
6d73: 09,04,38            shlw  R38,4            R38 *= 10;                        # adv * 16
6d76: 8b,74,a0,38         cmpw  R38,[R74+a0]     
6d7a: d9,2e               jgtu  6daa             if ((uns) R38 <= TSLADV)  {
6d7c: a3,74,a0,3c         ldw   R3c,[R74+a0]     R3c = TSLADV;
6d80: 68,38,3c            sb2w  R3c,R38          R3c -= R38;
6d83: c3,74,a0,3c         stw   R3c,[R74+a0]     TSLADV = R3c;
#
# Advance all cyls 1/4 degree of spark
#
6d87: fa                  di                     disable ints;
6d88: ff                  nop                    
6d89: b1,01,40            ldb   R40,1            R40 = 1;                          # add 1/4 degree of advance to each cyl
6d8c: ad,08,42            ldzbw R42,8            R42 = (uns)8;
# Loop through cylinders from 8 to 1
6d8f: 57,43,2b,02,40,30   ad3b  R30,R40,[R42+22b] R30 = R40 + [R42+SPKADn];        # 22B - SparkAdvance[ cyl 1 -8 ]
6d95: dd,06               jv    6d9d             if (OVF == 1) goto 6d9d;          # Clip to ADVLIM
6d97: 9b,f8,31,30         cmpb  R30,[Rf8+31]     
6d9b: da,04               jle   6da1             if ((uns) R30 < ADVLIM)  {
#
6d9d: b3,f8,31,30         ldb   R30,[Rf8+31]     R30 = ADVLIM; }                   # Advance Limit
#
6da1: c7,43,2b,02,30      stb   R30,[R42+22b]    [R42+SPKADn] = R30;               # 22B - SparkAdvance[ cyl 1 -8 ] new advance for this cyl
6da6: e0,42,e6            djnz  R42,6d8f         R42--;
                                                 if (R42 != 0) goto 6d8f;
6da9: fb                  ei                     enable ints; } }
#
# Jump here from 0x6D17 (!New_pip), 6d62 (!KNOCK_ENABLED)
#
# Tip-in Retard Logic
# GUFB pp. 7-41, 7-42
#
UPd_TipRet:
6daa: ef,a7,c8            call  3654             Urolav_3Arg(TBART,TP,TCTPT);         # Filter Throttle Posn
6dad: 2a,02,aa,00,5e,d0   #args  
6db3: c3,74,ac,3e         stw   R3e,[R74+ac]     TBART = R3e;                      # filtered result
6db7: a3,74,ac,38         ldw   R38,[R74+ac]     R38 = TBART;
6dbb: a0,aa,3a            ldw   R3a,Raa          R3a = TP;
6dbe: 0c,01,38            shrdw R38,1            R3b:R38 /= 2;
6dc1: 68,38,3a            sb2w  R3a,R38          R3a -= R38;
6dc4: c3,74,00,3a         stw   R3a,[R74+0]      TCF = R3a;
6dc8: 98,d0,00            cmpb  R0,Rd0           
6dcb: da,0f               jle   6ddc             if ((uns) 0 < APT)  {
# At WOT (APT == 1)
6dcd: a3,f8,34,14         ldw   R14,[Rf8+34]     R14 = TIPLOD;
6dd1: 8b,74,de,14         cmpw  R14,[R74+de]     
6dd5: d1,05               jleu  6ddc             if ((uns) TIPLOD > LOAD )  {
6dd7: 91,20,2d            orb   R2d,20           CTFLG = 1;
6dda: 20,16               sjmp  6df2             goto 6df2; } }
#
6ddc: a3,f8,36,38         ldw   R38,[Rf8+36]     R38 = TIPHS;
6de0: 67,f8,34,38         ad2w  R38,[Rf8+34]     R38 += TIPLOD;
6de4: d3,03               jnc   6de9             if ((uns) R38 >= 0)  {
6de6: bd,ff,38            ldsbw R38,ff           R38 = 0xffff; }                   # Clip to 255
6de9: 8b,74,de,38         cmpw  R38,[R74+de]     
6ded: db,03               jgeu  6df2             if ((uns) TIPHS + TIPLOD > LOAD)  {
6def: 71,df,2d            an2b  R2d,df           CTFLG = 0; }
#
6df2: a3,f8,2e,14         ldw   R14,[Rf8+2e]     R14 = KACRAT;                     # KACRAT = 41.5 mV
6df6: 8b,74,00,14         cmpw  R14,[R74+0]      
6dfa: d2,11               jgt   6e0d             if (KACRAT <= TCF)  {
6dfc: 9b,f8,3d,b0         cmpb  Rb0,[Rf8+3d]     
6e00: da,0b               jle   6e0d             if (ECT < ECTIP)  {               # ECTIP = 120 F in A9L
6e02: 8b,f8,3e,ae         cmpw  Rae,[Rf8+3e]     
6e06: db,05               jgeu  6e0d             if (N < NTIP)  {                  # NTIP = 0 in A9L
6e08: 91,40,2d            orb   R2d,40           TIPFLG = 1;
6e0b: 20,03               sjmp  6e10             goto 6e10; } } }
#
6e0d: 71,bf,2d            an2b  R2d,bf           TIPFLG = 0;
#
# Knock Strategy Enable Logic
# GUFB p. 7-36
#
6e10: 9b,f8,3c,b0         cmpb  Rb0,[Rf8+3c]     
6e14: da,1d               jle   6e33             if (ECT > ECTNOK)  {
6e16: 8b,f8,38,ae         cmpw  Rae,[Rf8+38]     
6e1a: d1,17               jleu  6e33             if ((uns) N > RPMMIN)  {
6e1c: a3,f8,3a,14         ldw   R14,[Rf8+3a]     R14 = LODNOK;
6e20: b3,f8,4a,42         ldb   R42,[Rf8+4a]     R42 = KIHP;                       # is there a knock sensor? (not in A9L)
6e24: 8b,74,de,14         cmpw  R14,[R74+de]                                       # engine load (VE)
6e28: db,09               jgeu  6e33             if ((uns) LODNOK >= LOAD)  {
6e2a: 98,42,00            cmpb  R0,R42           
6e2d: db,04               jgeu  6e33             if (0 < KIHP)  {
6e2f: 91,40,4f            orb   R4f,40           KNOCK_ENABLED = 1;
6e32: f0                  ret                    return; } } } }
#
# Enablement conditions not met, or
# no knock detection hardware present
#
6e33: 36,4f,12            jnb   B6,R4f,6e48      if (KNOCK_ENABLED == 0) return;   # Always 0 in A9L
#
# Knock strategy transitioning to disabled, clear SPKAD table
#
6e36: 71,bf,4f            an2b  R4f,bf           KNOCK_ENABLED = 0;
6e39: ad,08,42            ldzbw R42,8            R42 = (uns)8;
6e3c: c7,43,2b,02,00      stb   R0,[R42+22b]     [R42+SPKADn] = 0;                 # clr SparkAdvance[ cyl 1 -8 ]
6e41: e0,42,f8            djnz  R42,6e3c         R42--;
#                                                if (R42 != 0) goto 6e3c;
6e44: c3,74,a0,00         stw   R0,[R74+a0]      TSLADV = 0; }
#
6e48: f0                  ret                    return;

#################################################################
# Tasklist Routine at 2151, routine offset 4E
# Key On Engine Off, Engine Running, Continuous tests
# There are 4 proc Tables BASE A - BASE D - how do these correspond to
# self test stuff
#################################################################


  Do_SelfTest:
6e49: 71,fe,d9            an2b  Rd9,fe           Vip_fp_override = 0;
6e4c: 2a,48               scall 7096             Set_EGRFlags();                   # Set up EGR flags
6e4e: 71,f7,2c            an2b  R2c,f7           Wigflg = 0;
6e51: 3a,2a,0c            jb    B2,R2a,6e60      if (Vip_enable == 0)  {           # jump if VIP enable is set
6e54: a3,72,b4,42         ldw   R42,[R72+b4]     R42 = PUTMR;                      # Time since CPU power up - mS
6e58: 99,10,43            cmpb  R43,10                                             # compare whole seconds 16
6e5b: d3,03               jltu  6e60             if ((uns) R43 >= 10)  {           # jmp if timer < 4096 msec (~ 4 secs)
6e5d: 91,04,2a            orb   R2a,4            Vip_enable = 1; } }
6e60: 36,2a,14            jnb   B6,R2a,6e77      if (No_start == 0) goto 6e77;
6e63: 35,2b,05            jnb   B5,R2b,6e6b      if (STIFLG == 0) goto 6e6b;       # jump if EEC reset
6e66: 37,a1,0b            jnb   B7,Ra1,6e74      if (CRKFLG == 0) goto 6e74;       # jump if not CRANKING - EEC reset
6e69: 20,a7               sjmp  6f12             goto 6f12;                        # Enter KOEO (Engine off test)

########## STI low - EEC reset
6e6b: 3b,d6,03            jb    B3,Rd6,6e71      if (Sto_working == 1) goto 6e71;
6e6e: 32,2b,03            jnb   B2,R2b,6e74      if (Sto_trigger == 1)  {
#
6e71: ef,2c,09            call  77a0             clear_KAM(); }
#
6e74: e7,c9,15            jump  8440             goto 8440;                        # Reboot system
#
6e77: 35,2a,1e            jnb   B5,R2a,6e98      if (RUNNING == 0) goto 6e98;      # normal strategy - not self test
#
# RUNNING == 1 - KOER self test
#
6e7a: 35,2b,f7            jnb   B5,R2b,6e74      if (STIFLG == 0) goto 6e74;       # STI input is low - EEC reset
6e7d: b3,fe,02,42         ldb   R42,[Rfe+2]      R42 = TRLOAD;                     # Transmission type
6e81: 99,03,42            cmpb  R42,3                                              # 3 = Manual Transmission, both clutch and gear switches.
6e84: d3,08               jltu  6e8e             if ((uns) R42 < 3) goto 6e8e;
6e86: 99,04,42            cmpb  R42,4                                              # 4 = Auto Transmission, non-electronic, neutral drive switch.
6e89: d9,03               jgtu  6e8e             if ((uns) R42 > 4 ) goto 6e8e;
6e8b: 3f,e7,e6            jb    B7,Re7,6e74      if (NDSFLG == 1) goto 6e74;       # Reset EEC if in gear
#
6e8e: 36,e6,05            jnb   B6,Re6,6e96      if (Pfehp_flg == 1)  {
# Pressure feedback EGR
6e91: ef,43,09            call  77d7             Urolav_T(Fiept);                   # filter at 00CA[R78] use blend 116(IEVP) to 380
6e94: 80,03               #args                  }
#
6e96: 20,6d               sjmp  6f05             goto 6f05;
#
# RUNNING == 0 - Normal run mode
#
6e98: 30,2a,1a            jnb   B0,R2a,6eb5      if (VSCDT == 0) goto 6eb5;
6e9b: 35,2b,12            jnb   B5,R2b,6eb0      if (STIFLG == 1)  {               # jump if STI input is low (self test requested)
6e9e: b3,73,3d,01,42      ldb   R42,[R72+13d]    R42 = VSBAR_H;                    # Vehicle speed, MPH
6ea3: 99,04,42            cmpb  R42,4            
6ea6: d9,08               jgtu  6eb0             if ((uns) R42 <= 4)  {            # Vehicle speed > 4 MPH
6ea8: 37,a0,05            jnb   B7,Ra0,6eb0      if (ON_STATE == 1)  {             # VSC on (Cruise Control)
6eab: 3d,a0,02            jb    B5,Ra0,6eb0      if (BRAKE_STATE == 1) goto 6eb0;  # VSC brake (cruise control)
6eae: 20,91               sjmp  6f41             goto 6f41; } } }                  # VSCDT? push proc D and execute it
#
6eb0: 91,20,2a            orb   R2a,20           RUNNING = 1;                      # *** Set KOER self test mode
6eb3: 27,bf               sjmp  6e74             goto 6e74;                        # EEC reset
#
6eb5: 31,2a,08            jnb   B1,R2a,6ec0      if (Vscst == 0) goto 6ec0;        # jump if not VIP mode flag : VSCST
6eb8: 3d,2b,b9            jb    B5,R2b,6e74      if (STIFLG == 1) goto 6e74;       # jump if STI input is high to EEC reset
6ebb: 37,a1,b6            jnb   B7,Ra1,6e74      if (CRKFLG == 0) goto 6e74;       # jump if not CRANKING to EEC reset
6ebe: 20,7a               sjmp  6f3a             goto 6f3a;                        # VSCST? push proc C and execute it(STI low and engine off or starting)
#
6ec0: 3f,a1,49            jb    B7,Ra1,6f0c      if (CRKFLG == 1) goto 6f0c;        # jump if CRANKING
6ec3: 3a,a1,03            jb    B2,Ra1,6ec9      if (UNDSP == 1) goto 6ec9;         # jump if underspeed/cranking 
6ec6: 3d,2b,02            jb    B5,R2b,6ecb      if (STIFLG == 1) goto 6ecb;        # jump if STI input is high
6ec9: 20,82               sjmp  6f4d             return;
#
6ecb: b3,72,48,42         ldb   R42,[R72+48]     R42 = TSSTIL;                     # 1C8 timer - STI input line low timer (1/8sec)
6ecf: 99,08,42            cmpb  R42,8                                              # 1 second
6ed2: d3,79               jltu  6f4d             if ((uns) R42 < 8) return;        # jmp if STI low timer < 1 second
6ed4: 32,2a,76            jnb   B2,R2a,6f4d      if (Vip_enable == 0) return;      # jump if not VIP mode flag : VIP enable
6ed7: a3,72,b4,42         ldw   R42,[R72+b4]     R42 = PUTMR;                      # 134 - PUTMR - Counts up after h/w reset
6edb: 99,18,43            cmpb  R43,18                                             # compare whole seconds 1800 msec (1/1024) = 6 seconds
6ede: d3,6d               jltu  6f4d             if ((uns) R43 < 18) return;       # jmp if timer < 6 sec
6ee0: b3,78,c7,42         ldb   R42,[R78+c7]     R42 = VSTYPE;
6ee4: 99,02,42            cmpb  R42,2            
6ee7: d7,16               jne   6eff             if (VSTYPE = 2)  {                # VSTYPE = 1 on A9L
6ee9: 37,a0,13            jnb   B7,Ra0,6eff      if (ON_STATE == 1)  {             # VSC on (Cruise Control)
6eec: 3f,2a,10            jb    B7,R2a,6eff      if (Disable_vscdt == 0)  {        # jump if VIP mode flag : disable VSCDT set
6eef: a3,72,b4,42         ldw   R42,[R72+b4]     R42 = PUTMR;                      # 134 - PUTMR - Counts up after h/w reset
6ef3: 9b,79,f2,00,43      cmpb  R43,[R78+f2]                                       # compare whole seconds
6ef8: db,05               jgeu  6eff             if (R43 < VVSCET)  {              # jmp if timer >= VVSCET?
6efa: 91,09,2a            orb   R2a,9            VSCDT = 1;
                                                 Disable_running = 1;              # VIP mode flag : set VSCDT and DISABLE RUNNING
6efd: 20,42               sjmp  6f41             goto 6f41; } } } }                # jmp to BASE D procs
#
6eff: 3b,2a,48            jb    B3,R2a,6f4a      if (Disable_running == 0)  {       # jump if VIP mode flag : disable running set

# ENTER DYNAMIC TEST
6f02: 91,a0,2a            orb   R2a,a0           RUNNING = 1;                      # Set KOER self test mode
                                                 Disable_vscdt = 1;                # Set VIP mode flag : disable no start and disable VSCDT
6f05: 28,47               scall 6f4e             Sub40();
6f07: cb,3b,7e,71         push  [R3a+717e]       push([R3a+717e]);                 # BASE A - computed jump
6f0b: f0                  ret                    return;

6f0c: 35,2b,0a            jnb   B5,R2b,6f19      if (STIFLG == 0) goto 6f19;       # jump if STI input is low
6f0f: 3c,2a,38            jb    B4,R2a,6f4a      if (Disable_nostart == 0)  {      # jump VIP mode flag : disable no start

# ENTER ENGINE OFF TEST?
6f12: 28,3a               scall 6f4e             Sub40();
6f14: cb,3b,68,71         push  [R3a+7168]       push([R3a+7168]);                 # BASE B - push self test function proc ?
6f18: f0                  ret                    return;                           # test code - KOEO self test and others?
#
6f19: b3,78,c7,42         ldb   R42,[R78+c7]     R42 = VSTYPE;                     # = 1 on A9L
6f1d: 99,02,42            cmpb  R42,2            
6f20: d7,2b               jne   6f4d             if (VSTYPE != 2) return;          # return
6f22: 37,a0,28            jnb   B7,Ra0,6f4d      if (ON_STATE == 0) return;        # if VSC ON state - return (exit if cruise control is ON)
6f25: a3,72,b4,42         ldw   R42,[R72+b4]     R42 = PUTMR;                      # 134 - PUTMR - Counts up after h/w reset (msec)
6f29: 99,28,43            cmpb  R43,28                                             # compare msec - 2800 * 1/1024 = 10 seconds
6f2c: db,1f               jgeu  6f4d             if ((uns) R43 >= 28) return;      # if Eng Runnung Timer >= 10seconds then return
6f2e: a3,72,be,42         ldw   R42,[R72+be]     R42 = TSLPIP;                     # 13E - timer? time since last PIP received (msec)
6f32: 99,04,43            cmpb  R43,4                                              # 0x400 msec(1/1024) seconds ~ 1 second
6f35: d1,16               jleu  6f4d             if ((uns) R43 <= 4) return;       # if time since PIP <= 1 sec then return
6f37: 91,02,2a            orb   R2a,2            Vscst = 1;                        # Set VIP mode flag : VSCST

##### ENGINE OFF VCS TEST?
6f3a: 28,12               scall 6f4e             Sub40();
6f3c: cb,3b,c8,71         push  [R3a+71c8]       push([R3a+71c8]);                 # BASE C - computed jump in 7000 area
6f40: f0                  ret                    return;                           # run the test routine

##### ENTER ENGINE RUNNING TEST

6f41: 28,0b               scall 6f4e             Sub40();
6f43: cb,3b,d6,71         push  [R3a+71d6]       push([R3a+71d6]);                 # BASE D - computed jump in 7000 area
6f47: f0                  ret                    return;                           # run the test routine

#### computed diagnostic calls return here

6f48: 21,2b               sjmp  7075             goto Save_diag_vals;              # Save diagnostic testing registers

6f4a: 91,08,2c            orb   R2c,8            Wigflg = 1;                       # Activate wiggle test mode
6f4d: f0                  ret                    return;


######################################
# gets jump function index into R3A
#######################################

  Sub40:
6f4e: 29,00               scall 7050             Get_diag_vals();                  # load diagnostic testing registers
6f50: ac,38,3a            ldzbw R3a,R38          R3a = (uns)R38;                   # function address index
6f53: 09,01,3a            shlw  R3a,1            R3a *= 2;                         # X 2 - make into word index
6f56: cc,42               pop   R42              R42 = pop();                      # original return address
6f58: c9,48,6f            push  6f48             push(6f48);                       # push extra address (save diag vals)
6f5b: 88,00,40            cmpw  R40,R0                                             # Zero 1st time only, This is return address of call x7026
6f5e: df,02               je    6f62             if (R40 == 0) goto 6f62;           # jump if first time thru here
6f60: 20,da               sjmp  703c             goto 703c;                        # return to 1st or 3rd caller
#
6f62: c8,42               push  R42              push(R42);                        # restore return address
6f64: f0                  ret                    return;

# Diagnostic Proc Table A


  Sub41:
6f65: a1,10,55,d4         ldw   Rd4,5510         Vip_code = 5510;                  # Diagnostic Proc Table A proc no 2
6f69: 7b,fe,07,d4         sb2b  Rd4,[Rfe+7]      Vip_code -= ENGCYL;               # PIPs/rev * 2
6f6d: 08,d4,d4            shrw  Rd4,Rd4          Vip_code >>= Vip_code;
6f70: 28,08               scall 6f7a             Sub44();
6f72: 20,6f               sjmp  6fe3             goto 6fe3;

  Sub42:
6f74: ad,02,d4            ldzbw Rd4,2            Vip_code = (uns)2;

  Sub43:
6f77: 91,02,d9            orb   Rd9,2            Goose = 1;

  Sub44:
6f7a: 91,04,d9            orb   Rd9,4            Onedigit_out = 1;
6f7d: 28,a7               scall 7026             Sub51();
6f7f: 71,fb,d9            an2b  Rd9,fb           Onedigit_out = 0;
6f82: f0                  ret                    return;

####################################################################
# Diagnostic proc Table A
# sensor error stack processing - dump out errors?
####################################################################


  Sub45:
6f83: b1,10,19            ldb   R19,10           R19 = 10;
6f86: 98,30,00            cmpb  R0,R30                                             # is error stack empty?
6f89: d7,04               jne   6f8f             if (0 == R30)  {
6f8b: ef,20,0c            call  7bae             SaveTCode1(11);
# E11 - System PASS
6f8e: 11                  #args                  }                                 # Trouble Code : System PASS (no errors)
6f8f: ef,1c,0c            call  7bae             SaveTCode1(0);                    # E 00 (end of errors? ) 
6f92: 00                  #args  
6f93: a1,42,03,30         ldw   R30,342          R30 = Serv_code_tab;              # Hard Trouble Code Error Table
6f97: ae,31,32            ldzbw R32,[R30++]      R32 = (uns)[R30++];               # load next trouble code byte into word R32
6f9a: 98,00,32            cmpb  R32,R0           
6f9d: df,08               je    6fa7             if (R32 == 0) goto 6fa7;          # zero is end of error codes?
6f9f: 28,45               scall 6fe6             Sub46();                          # call this for every error
6fa1: 89,55,03,30         cmpw  R30,355                                            # 342 + 13
6fa5: d3,f0               jltu  6f97             if ((uns) R30 < 355) goto 6f97;   # loop back small
# end of error codes stack
6fa7: 30,d6,15            jnb   B0,Rd6,6fbf      if (High_speed == 0) goto 6fbf;
6faa: 34,d9,05            jnb   B4,Rd9,6fb2      if (Kam_codes == 1)  {
6fad: b1,04,33            ldb   R33,4            R33 = 4;
6fb0: 21,06               sjmp  70b8             goto 70b8; }

6fb2: 28,67               scall 701b             Sub50();
6fb4: 71,fe,d6            an2b  Rd6,fe           High_speed = 0;
6fb7: 32,d6,24            jnb   B2,Rd6,6fde      if (Low_speed == 0) goto 6fde;
6fba: b1,08,19            ldb   R19,8            R19 = 8;
6fbd: 27,d4               sjmp  6f93             goto 6f93;                        # loop back big

6fbf: 32,d6,0e            jnb   B2,Rd6,6fd0      if (Low_speed == 0) goto 6fd0;
6fc2: 71,fb,d6            an2b  Rd6,fb           Low_speed = 0;
6fc5: 36,2a,03            jnb   B6,R2a,6fcb      if (No_start == 1)  {
6fc8: 91,10,d9            orb   Rd9,10           Kam_codes = 1; }
6fcb: 31,d6,10            jnb   B1,Rd6,6fde      if (Lowspeed_repeat == 0) goto 6fde;
6fce: 27,c3               sjmp  6f93             goto 6f93;                        # loop back big

6fd0: 31,d6,13            jnb   B1,Rd6,6fe6      if (Lowspeed_repeat == 0) goto 6fe6;
6fd3: 34,d9,08            jnb   B4,Rd9,6fde      if (Kam_codes == 1)  {
6fd6: 91,04,d6            orb   Rd6,4            Low_speed = 1;
6fd9: b1,0a,33            ldb   R33,a            R33 = a;
6fdc: 20,da               sjmp  70b8             goto 70b8; }

6fde: 71,fd,d6            an2b  Rd6,fd           Lowspeed_repeat = 0;
6fe1: 28,38               scall 701b             Sub50();
6fe3: e7,28,0f            jump  7f0e             goto 7f0e;

#######################################################
# ? DUMPS OUT HARD ERROR CODES?
# R32 byte has trouble code - called for every trouble code in 342 stack
#######################################################

  Sub46:
6fe6: 09,04,32            shlw  R32,4            R32 *= 10;                        # error code x 16 (left one hex digit)
6fe9: 17,33               incb  R33              R33++;
6feb: 20,04               sjmp  6ff1             goto 6ff1;

6fed: 28,20               scall 700f             Sub48();                          # execute this loop error code X 16 + 1? times
6fef: 28,21               scall 7012             Sub49();
6ff1: e0,33,f9            djnz  R33,6fed         R33--;
                                                 if (R33 != 0) goto 6fed;
6ff4: b1,03,33            ldb   R33,3            R33 = 3;
6ff7: 28,19               scall 7012             Sub49();
6ff9: e0,33,fb            djnz  R33,6ff7         R33--;
                                                 if (R33 != 0) goto 6ff7;
6ffc: 38,32,07            jb    B0,R32,7006      if (B0_R32 == 0)  {
6fff: 09,04,32            shlw  R32,4            R32 *= 10;                        # R32 << 4 (one hex digit)
7002: 17,32               incb  R32              R32++;
7004: 27,e3               sjmp  6fe9             goto 6fe9; }

7006: b1,04,33            ldb   R33,4            R33 = 4;

  Sub47:
7009: 28,07               scall 7012             Sub49();
700b: e0,33,fb            djnz  R33,7009         R33--;
                                                 if (R33 != 0) goto Sub47;
700e: f0                  ret                    return;
#######################################################
# entry point 1
# shift D4 right 16 times or until R19 == 0
#######################################################


  Sub48:
700f: 91,80,d5            orb   Rd5,80           Rd5 |= 80;

  Sub49:
7012: e0,19,02            djnz  R19,7017         R19--;
                                                 if (R19 != 0) goto 7017;
7015: 20,0f               sjmp  7026             goto Sub51;

7017: 08,01,d4            shrw  Rd4,1            Vip_code /= 2;
701a: f0                  ret                    return;

#######################################################


  Sub50:
701b: 3c,19,07            jb    B4,R19,7025      if (B4_R19 == 1) return;
701e: 15,19               decb  R19              R19--;
7020: 08,19,d4            shrw  Rd4,R19          Vip_code >>= R19;
7023: 28,01               scall 7026             Sub51(); }
7025: f0                  ret                    return;

#######################################################
# this proc can shortcut returns from stack - to grandcaller
#######################################################


  Sub51:
7026: cc,40               pop   R40              R40 = pop();                      # get & save caller
7028: cc,14               pop   R14              R14 = pop();                      # get & save grandcaller
702a: 71,ef,d6            an2b  Rd6,ef           Sto_fast = 0;                     # STO fast codes
702d: 30,d6,03            jnb   B0,Rd6,7033      if (High_speed == 1)  {            # jump if STO high speed
7030: 91,10,d6            orb   Rd6,10           Sto_fast = 1; }
7033: b1,10,19            ldb   R19,10           R19 = 10;
7036: 91,20,d6            orb   Rd6,20           Sto_code = 1;
7039: 91,04,2b            orb   R2b,4            Sto_trigger = 1;                  # Self Test Output trigger
703c: 3a,2b,10            jb    B2,R2b,704f      if (Sto_trigger == 1) return;
703f: 32,d9,03            jnb   B2,Rd9,7045      if (Onedigit_out == 1)  {
7042: 3b,d6,0a            jb    B3,Rd6,704f      if (Sto_working == 1) return; }    # return to grandcaller  # return to grandcaller 
7045: c8,14               push  R14              push(R14);                        # restore grandcaller
7047: c8,40               push  R40              push(R40);                        # restore caller
7049: 01,40               clrw  R40              R40 = 0;
704b: 28,28               scall 7075             Save_diag_vals();                 # Save diagnostic testing registers
704d: 01,d4               clrw  Rd4              Vip_code = 0; }
704f: f0                  ret                    return;

######################################################
# save and restore test values for self test
######################################################


  Get_diag_vals:
7050: a3,72,50,30         ldw   R30,[R72+50]     R30 = Code_cnt_ex;
7054: a3,72,5a,32         ldw   R32,[R72+5a]     R32 = Code_ones_ex;
7058: a3,72,62,34         ldw   R34,[R72+62]     R34 = Vip_nrm_ex;
705c: a3,72,64,36         ldw   R36,[R72+64]     R36 = Vip_nrm2_EX;
7060: b3,72,57,38         ldb   R38,[R72+57]     R38 = Vip_cnt_ex;
7064: a3,72,52,40         ldw   R40,[R72+52]     R40 = Vip_stack_ex;
7068: a3,72,54,14         ldw   R14,[R72+54]     R14 = Vip_stack_x2;
706c: b3,72,4a,18         ldb   R18,[R72+4a]     R18 = VIPTMR;
7070: b3,72,66,19         ldb   R19,[R72+66]     R19 = Shift_cnt_ex;
7074: f0                  ret                    return;


  Save_diag_vals:
7075: c3,72,50,30         stw   R30,[R72+50]     Code_cnt_ex = R30;
7079: c3,72,5a,32         stw   R32,[R72+5a]     Code_ones_ex = R32;
707d: c3,72,62,34         stw   R34,[R72+62]     Vip_nrm_ex = R34;
7081: c3,72,64,36         stw   R36,[R72+64]     Vip_nrm2_EX = R36;
7085: c7,72,57,38         stb   R38,[R72+57]     Vip_cnt_ex = R38;
7089: c3,72,52,40         stw   R40,[R72+52]     Vip_stack_ex = R40;
708d: c3,72,54,14         stw   R14,[R72+54]     Vip_stack_x2 = R14;
7091: c7,72,66,19         stb   R19,[R72+66]     Shift_cnt_ex = R19;
7095: f0                  ret                    return;

##########################################################


  Set_EGRFlags:
7096: 45,80,00,f2,78      ad3w  R78,Rf2,80       Cp = ECTMAX;                      # points to 0x8EDA
709b: a1,80,01,72         ldw   R72,180          Rp = INJDLY;                      # why does this REG need resetting
709f: b3,fa,31,42         ldb   R42,[Rfa+31]     R42 = PFEHP;                      # 0=sonic, 1=PFE, 2=none
70a3: 71,bf,d9            an2b  Rd9,bf           Vegrbp = 0;
70a6: 99,02,42            cmpb  R42,2            
70a9: d7,03               jne   70ae             if (R42 = 2)  {                   # branch ALWAYS in this ROM
70ab: 91,40,d9            orb   Rd9,40           Vegrbp = 1; }
70ae: 71,bf,e6            an2b  Re6,bf           Pfehp_flg = 0;
70b1: e0,42,03            djnz  R42,70b7         R42--;
                                                 if (R42 != 0) return;
70b4: 91,40,e6            orb   Re6,40           Pfehp_flg = 1; }                  # - never happens in this ROM
70b7: f0                  ret                    return;
##########################################################

70b8: 2f,4f               scall 7009             Sub47();
70ba: ad,10,32            ldzbw R32,10           R32 = (uns)10;
70bd: 2f,27               scall 6fe6             Sub46();                          # process? a trouble code?
70bf: 28,5c               scall 711d             Sub52();                          # set R30 to end of trouble code stack
70c1: 30,d6,3f            jnb   B0,Rd6,7103      if (High_speed == 1)  {            # Low Speed Repeat
70c4: ad,15,32            ldzbw R32,15           R32 = (uns)15;
70c7: c2,30,32            stw   R32,[R30]        [R30] = R32;                      # R30 = # 356 WORD
70ca: 3e,d8,36            jb    B6,Rd8,7103      if (Vip_kam == 0)  {
70cd: ad,11,32            ldzbw R32,11           R32 = (uns)11;
70d0: c2,30,32            stw   R32,[R30]        [R30] = R32;                      # save start code?
70d3: 01,1a               clrw  R1a              R1a = 0;
70d5: a1,c4,07,1c         ldw   R1c,7c4          R1c = Kam_indexl;                 # KAMINDEXLow
70d9: b1,08,1e            ldb   R1e,8            R1e = 8;
70dc: b2,1d,34            ldb   R34,[R1c++]      R34 = [R1c++];                    # take next value from 7C4 Table
70df: 07,1a               incw  R1a              R1a++;
70e1: 89,25,00,1a         cmpw  R1a,25                                             # loop for 25 entries (37)
70e5: d9,18               jgtu  70ff             if ((uns) R1a > 25 ) goto 70ff;
70e7: 19,01,34            shlb  R34,1            R34 *= 2;
70ea: d3,0e               jnc   70fa             if ((uns) R34 >= 0)  {            # was bit bit set?
70ec: 57,1b,42,71,00,1f   ad3b  R1f,R0,[R1a+7142] R1f = [R1a+7142];                # Table (index starts at 1 not zero)
70f2: df,06               je    70fa             if (R1f != 0)  {                  # skip zeros 
70f4: c6,31,1f            stb   R1f,[R30++]      [R30++] = R1f;                    # write to 356+

#############################################################
# Restore the registers used
# Save the registers used for testing
# If ROM 97D9(EGR Type) = 1 then set bit 6 in RE6 else clear the bit
# If ROM 97D9(EGR Type) = 2 then set bit 6 in RD9 else clear the bit
# Save diagnostic testing registers
# Set up EGR flags
# Since ROM does not change this proc ALWAYS clr both bit 6 flags
# Things like continious tests require preserving registers
# change flag bit 6 in RD9 and RE6 based on ROM 97D9(EGR Type) = egr type ( 0=sonic, 1=PFE, 2=none)
# load diagnostic testing registers
# resets R72 = 180 and sets R78 = 8EDA
#############################################################
70f7: c6,30,00            stb   R0,[R30]         [R30] = 0; } }                    # mark as end in case of exit?
70fa: e0,1e,e2            djnz  R1e,70df         R1e--;
                                                 if (R1e != 0) goto 70df;          # loop
70fd: 27,da               sjmp  70d9             goto 70d9;                        # loop

70ff: 28,1c               scall 711d             Sub52();                          # set ptr to code table
7101: 28,1f               scall 7122             Sub53(); } }                      # Bubble sort Table
7103: 56,31,00,32         ad3b  R32,R0,[R30++]   R32 = [R30++];
7107: df,04               je    710d             if (R32 != 0)  {
7109: 2e,db               scall 6fe6             Sub46();
710b: 27,f6               sjmp  7103             goto 7103; }

710d: 38,d6,08            jb    B0,Rd6,7118      if (High_speed == 0)  {
7110: 32,d6,05            jnb   B2,Rd6,7118      if (Low_speed == 1)  {
7113: 71,fb,d6            an2b  Rd6,fb           Low_speed = 0;
7116: 27,a7               sjmp  70bf             goto 70bf; } }

7118: 71,ef,d9            an2b  Rd9,ef           Kam_codes = 0;
711b: 26,95               sjmp  6fb2             goto 6fb2;


  Sub52:
711d: a1,56,03,30         ldw   R30,356          R30 = Cntn_code_tab;              # R30 = end of trouble code stack
7121: f0                  ret                    return;
# bubble sort


  Sub53:
7122: 56,31,00,1c         ad3b  R1c,R0,[R30++]   R1c = [R30++];                    # load ptr to ?
7126: df,f5               je    711d             if (R1c == 0) goto Sub52;          # exit and restore ptr
7128: a0,30,1a            ldw   R1a,R30          R1a = R30;
712b: 56,1b,00,1d         ad3b  R1d,R0,[R1a++]   R1d = [R1a++];
712f: df,f1               je    7122             if (R1d == 0) goto Sub53;
7131: 98,1c,1d            cmpb  R1d,R1c          
7134: db,f5               jgeu  712b             if ((uns) R1d >= R1c) goto 712b;
7136: c7,1a,ff,1c         stb   R1c,[R1a+ff]     [R1a-1] = R1c;
713a: b0,1d,1c            ldb   R1c,R1d          R1c = R1d;
713d: c7,30,ff,1c         stb   R1c,[R30+ff]     [R30-1] = R1c;
7141: 27,e8               sjmp  712b             goto 712b;

#############################################################
# Diagnostic, Trouble Codes ?  called as [7142+Reg] from 70ec
# so table must start at 1. 
##############################################################


7143: 51,54,61,64,53,00,63,87 ?? 
714b: 00,14,18,00,22,91,41,00 ?? 
7153: 31,32,33,34,35,00,00,00 ?? 
715b: 29,00,00,00,00,ff,ff,ff ?? 
7163: 95,96,56,66,67      ??    

#############################################################
# Self Test subroutine list KOEO.  ( From 6f14+x)
##############################################################

7168: 0d,78               vect  780d,            Do_KOEO
716a: 8c,80               vect  808c,            Sub102                            # Proc uses next word as a PARAM
716c: 08,00               word  8,               INT_Mask                          # PARAM - interrupt mask address
716e: 70,78               vect  7870,            Test1                             # ECT. BP, MAF sensor range tests
7170: d2,78               vect  78d2,            Test2                             # ACT, EGR, NPS, A/C on,PwrSteering,VCAL, TP sensor tests
7172: e4,79               vect  79e4,            Sub70                             # force LSO and HSO outputs off set STO on jmp to (R34)
7174: ad,79               vect  79ad,            Sub68                             # Thermactor Air System test
7176: ce,79               vect  79ce,            Sub69                             # Fuel Pump Secondary circuit test
7178: 83,6f               vect  6f83,            Sub45                             # dump out all 342 stack error codes to ?
717a: 01,7b               vect  7b01,            Sub75                             # incr R38 and set LSO and BiDI outputs?
717c: 1b,7b               vect  7b1b,            Sub76                             # proc with odd h/w xor

######## Self Test list 2 (from 6f07)################

717e: e0,7b               vect  7be0,            Sub77
7180: 65,6f               vect  6f65,            Sub41                             # clr STO, Hard Fault, ACT, ECT, TP, TPS ?
7182: 84,7c               vect  7c84,            Sub78                             # high RPM test (If Engine Running)
7184: a3,7c               vect  7ca3,            Sub79
7186: c9,7c               vect  7cc9,            Sub80
7188: e5,7c               vect  7ce5,            Sub81
718a: 11,7d               vect  7d11,            Sub82
718c: 4a,7d               vect  7d4a,            Sub83
718e: 68,7d               vect  7d68,            Sub84
7190: 91,7d               vect  7d91,            Sub85
7192: aa,7d               vect  7daa,            Sub86
7194: 85,80               vect  8085,            Sub101
7196: 5a,90               word  905a,            DNPPM                             # PARAM  - for proc 8085
7198: 4c,7e               vect  7e4c,            Sub89
719a: 8f,7e               vect  7e8f,            Sub90
719c: 15,7f               vect  7f15,            Sub91
719e: 24,7f               vect  7f24,            Sub92
71a0: 37,7f               vect  7f37,            Sub93
71a2: 55,7f               vect  7f55,            Sub94
71a4: 62,7f               vect  7f62,            Sub95
71a6: 7f,7f               vect  7f7f,            Sub96
71a8: b1,7f               vect  7fb1,            Sub97
71aa: c8,7f               vect  7fc8,            Sub98
71ac: 83,6f               vect  6f83,            Sub45                             # dump out all 342 stack error codes to ?
71ae: a6,80               vect  80a6,            Sub103
71b0: c4,80               vect  80c4,            Sub104
71b2: f2,80               vect  80f2,            Sub105
71b4: fe,80               vect  80fe,            Sub106
71b6: 21,81               vect  8121,            Sub107
71b8: 2d,81               vect  812d,            Sub108
71ba: 77,81               vect  8177,            Sub109
71bc: 8a,81               vect  818a,            Sub110
71be: ba,81               vect  81ba,            Sub111
71c0: 34,84               vect  8434,            Sub119                            # in all three Tables at end
71c2: 79,80               vect  8079,            Sub99                             # clr 1CA timer, incr R38 self test index, set bit flag and return
71c4: 83,6f               vect  6f83,            Sub45                             # dump out all 342 stack error codes to ?
71c6: 34,84               vect  8434,            Sub119                            # in all three Tables at end

######## Self Test list 3 (from 6f3c)################
71c8: 92,72               vect  7292,            Sub58                             # STO off and output to low, zero VIP timer, incr R38 test index
71ca: f4,71               vect  71f4,            Sub54                             # tweak flags
71cc: ff,71               vect  71ff,            Sub56                             # SCCS something
71ce: 73,72               vect  7273,            Sub57
71d0: 79,80               vect  8079,            Sub99                             # clr 1CA timer, incr R38 self test index, set bit flag and return
71d2: 83,6f               vect  6f83,            Sub45                             # dump out all 342 stack error codes to ?
71d4: 34,84               vect  8434,            Sub119                            # in all three Tables at end

######## Self Test list 4 (from 6f43)################

71d6: 92,72               vect  7292,            Sub58                             # STO off and output to low, zero VIP timer, incr R38 test index
71d8: fa,71               vect  71fa,            Sub55
71da: 7e,80               vect  807e,            Sub100
71dc: 69,91               word  9169,                                              # PARAM - for proc 807e
71de: a6,72               vect  72a6,            Sub59
71e0: cc,72               vect  72cc,            Sub60
71e2: 7e,80               vect  807e,            Sub100
71e4: 6a,91               word  916a,                                              # PARAM - for proc 807e
71e6: d6,72               vect  72d6,            Sub61
71e8: dc,72               vect  72dc,            Sub62
71ea: 00,73               vect  7300,            Sub63
71ec: 04,73               vect  7304,            Sub64                             # HEGO - A/F ratio test?
71ee: 79,80               vect  8079,            Sub99                             # clr 1CA timer, incr R38 self test index, set bit flag and return
71f0: 83,6f               vect  6f83,            Sub45                             # dump out all 342 stack error codes to ?
71f2: 34,84               vect  8434,            Sub119                            # in all three Tables at end

########## End of self test lists ####################


  Sub54:
71f4: 91,fb,d7            orb   Rd7,fb           Code_75 = 1;
                                                 Code_74 = 1;
                                                 Code_45_92 = 1;
                                                 Code_77_91 = 1;
                                                 Code_44_73 = 1;
                                                 Code_42_72 = 1;
                                                 Code_25_41 = 1;
71f7: 91,04,d7            orb   Rd7,4            Code_67_94 = 1;                   # set code flags for clearing later

  Sub55:
71fa: ef,77,fd            call  6f74             Sub42();
71fd: 20,98               sjmp  7297             goto 7297;

  Sub56:
71ff: 37,b5,03            jnb   B7,Rb5,7205      if (OFF_BUT == 1)  {
7202: 71,7f,d7            an2b  Rd7,7f           Code_25_41 = 0; }
7205: 35,b5,03            jnb   B5,Rb5,720b      if (COAST_BUT == 1)  {
7208: 71,bf,d7            an2b  Rd7,bf           Code_42_72 = 0; }
720b: 34,b5,03            jnb   B4,Rb5,7211      if (ACCEL_BUT == 1)  {
720e: 71,df,d7            an2b  Rd7,df           Code_44_73 = 0; }
7211: 33,b5,03            jnb   B3,Rb5,7217      if (RESUM_BUT == 1)  {
7214: 71,ef,d7            an2b  Rd7,ef           Code_77_91 = 0; }
7217: 91,08,d7            orb   Rd7,8            Code_45_92 = 1;
721a: 98,b5,00            cmpb  R0,Rb5           
721d: d7,03               jne   7222             if (0 == Vsc_switches)  {         # no SCCS buttons/mode
721f: 71,f7,d7            an2b  Rd7,f7           Code_45_92 = 0; }
7222: 31,ea,05            jnb   B1,Rea,722a      if (BIFLG == 1)  {
7225: 71,fd,d7            an2b  Rd7,fd           Code_74 = 0;                      # Brake is on.
7228: 20,03               sjmp  722d             goto 722d; }

722a: 71,fe,d7            an2b  Rd7,fe           Code_75 = 0;
722d: 3f,e7,03            jb    B7,Re7,7233      if (NDSFLG == 0)  {
7230: 71,fb,d7            an2b  Rd7,fb           Code_67_94 = 0; }
7233: 51,fb,d7,42         an3b  R42,Rd7,fb       R42 = Tc_flags & fb;
7237: d7,03               jne   723c             if (R42 != 0) goto 723c;
7239: 32,d7,20            jnb   B2,Rd7,725c      if (Code_67_94 == 1)  {
723c: ef,fc,0b            call  7e3b             GetWord(VIPT1);
723f: 66,91               #args
7241: 3b,d7,15            jb    B3,Rd7,7259      if (Code_45_92 == 1) goto 7259;
7244: 51,f0,d7,42         an3b  R42,Rd7,f0       R42 = Tc_flags & f0;
7248: df,12               je    725c             if (R42 != 0)  {
724a: 99,f0,42            cmpb  R42,f0           
724d: d7,05               jne   7254             if (R42 = f0)  {
724f: 28,52               scall 72a3             SaveTCode2(49);                   # E49 SPOUT signal defaulted or 1-2 shift error E40D
7251: 49                  #args  
7252: 20,08               sjmp  725c             goto 725c; }

7254: 28,4d               scall 72a3             SaveTCode2(Flags_47);             # E47 air flow low at base idle
7256: 47                  #args  
7257: 20,03               sjmp  725c             goto 725c;

7259: 28,48               scall 72a3             SaveTCode2(48);                   # E48 air flow high at base idle
725b: 48                  #args                  } }
725c: ef,e5,06            call  7944             Sub67();
725f: 32,d7,03            jnb   B2,Rd7,7265      if (Code_67_94 == 1)  {
7262: 28,3f               scall 72a3             SaveTCode2(67);                   # E67 A/C input high
7264: 67                  #args                  }
7265: 31,d7,03            jnb   B1,Rd7,726b      if (Code_74 == 1)  {
7268: 28,39               scall 72a3             SaveTCode2(Rp2);                  # E74 Brake circuit fail - not actuated
726a: 74                  #args                  }
726b: 30,d7,03            jnb   B0,Rd7,7271      if (Code_75 == 1)  {
726e: 28,33               scall 72a3             SaveTCode2(75);                   # E75 Brake circuit fail - always high
7270: 75                  #args                  }
7271: 20,24               sjmp  7297             goto 7297;

  Sub57:
7273: ef,79,08            call  7aef             Sub74();
7276: c9,7f,72            push  727f             push(727f);
7279: 28,12               scall 728d             OCC_chk1(681,4610);               # SCCS Output Circuit Check, pars = E81,limit,bit mask(=SCCS),IO
727b: 81,06,10,46         #args  
727f: 28,a4               scall 7325             Sub66();
7281: 91,10,46            orb   R46,10           SCVNT = 1;                        # LSO output line 4 ON (Speed Control Vent)
7284: c9,97,72            push  7297             push(7297);                       # return from 7A76 to this address
7287: 28,06               scall 728f             OCC_chk2(482,4601);               # DOL Output Circuit Check, E82,limit,bit mask(=DOL),IO
7289: 82,04,01,46         #args  

  OCC_chk1:
728d: 28,8a               scall 7319             Sub65();                          # SCCS controls off & stuff?

  OCC_chk2:
728f: e7,e4,07            jump  7a76             goto Test_IO;                     # Output Circuit Check function

############################################################
# STO off and output to low, zero VIP timer, incr R38 test index
# jump Table entry 71C8
############################################################

  Sub58:
7292: 01,30               clrw  R30              R30 = 0;
7294: ef,1d,05            call  77b4             Reset_STO();                      # set STO off flag, set STO output low, and set STO trigger
7297: c7,72,4a,00         stb   R0,[R72+4a]      VIPTMR = 0;                 # zero 1CA timer? VIP TIMER EX?
729b: 17,38               incb  R38              R38++;                            # incr test index
729d: f0                  ret                    return;

729e: ef,0b,05            call  77ac             Set_STO();                        # tweak flags, set STO on and return
72a1: 27,f4               sjmp  7297             goto 7297;                        # 91 - Air/Fuel mixture not within Self test range (HEGO switching error)

  SaveTCode2:
72a3: e7,08,09            jump  7bae             goto SaveTCode1;                  # JUMP TO (use caller data) E 91 -> err stack

  Sub59:
72a6: 91,20,d9            orb   Rd9,20           Vvsfl1 = 1;                       # From Diagnostic Proc Table D
72a9: a3,79,e2,00,42      ldw   R42,[R78+e2]     R42 = Vrss;
72ae: c3,73,2e,01,42      stw   R42,[R72+12e]    RES_SPEED = R42;
72b3: 6b,79,e0,00,42      sb2w  R42,[R78+e0]     R42 -= Vrsh;
72b8: 8b,73,2c,01,42      cmpw  R42,[R72+12c]    
72bd: d1,dc               jleu  729b             if ((uns) R42 <= MPH) goto 729b;
72bf: ef,79,0b            call  7e3b             GetWord(VIPT2);
72c2: 67,91               #args  
72c4: 2f,dd               scall 72a3             SaveTCode2(36);
72c6: 36                  #args  
72c7: b1,0c,38            ldb   R38,c            R38 = c;
72ca: 20,4d               sjmp  7319             goto Sub65;

  Sub60:
72cc: b1,80,a0            ldb   Ra0,80           Vsc_states = 80;                  # From Diagnostic Proc Table D
72cf: 28,48               scall 7319             Sub65();                          # From Diagnostic Proc Table D
72d1: 91,10,46            orb   R46,10           SCVNT = 1;                        # LSO output line 4 ON (Speed Control Vent)
72d4: 27,c1               sjmp  7297             goto 7297;

  Sub61:
72d6: c3,72,70,aa         stw   Raa,[R72+70]     Tpsav = TP;                       # From Diagnostic Proc Table D
72da: 27,bb               sjmp  7297             goto 7297;

  Sub62:
72dc: 4b,72,70,aa,42      sb3w  R42,Raa,[R72+70] R42 = TP - Tpsav;
72e1: 8b,79,ee,00,42      cmpw  R42,[R78+ee]     
72e6: da,05               jle   72ed             if ((uns) R42 < Vtplu)  {
72e8: 2f,b9               scall 72a3             SaveTCode2(Flags_28);
72ea: 28                  #args  
72eb: 27,da               sjmp  72c7             goto 72c7; }

72ed: 03,42               negw  R42              R42 = -R42;
72ef: 8b,79,ec,00,42      cmpw  R42,[R78+ec]     
72f4: da,05               jle   72fb             if ((uns) R42 < Vtpld)  {
72f6: 2f,ab               scall 72a3             SaveTCode2(Flags_27);
72f8: 27                  #args  
72f9: 27,cc               sjmp  72c7             goto 72c7; }

72fb: ef,3d,0b            call  7e3b             GetWord(VIPT3);
72fe: 68,91               #args  

  Sub63:
7300: 28,17               scall 7319             Sub65();
7302: 27,93               sjmp  7297             goto 7297;

# Diagnostic Proc Table D

  Sub64:
7304: a3,fa,62,42         ldw   R42,[Rfa+62]     R42 = VMLO;
7308: 8b,73,2c,01,42      cmpw  R42,[R72+12c]    
730d: d9,08               jgtu  7317             if ((uns) R42 <= MPH)  {
730f: ef,29,0b            call  7e3b             GetWord(980c);
7312: 64,d0               #args  
7314: 2f,8d               scall 72a3             SaveTCode2(37);
7316: 37                  #args                  }
7317: 17,38               incb  R38              R38++;                            # incr test index

# Diagnostic Proc Table D

  Sub65:
7319: 71,df,d9            an2b  Rd9,df           Vvsfl1 = 0;                       # clr RD9 bit 5 VVS flag1?
731c: 28,07               scall 7325             Sub66();
731e: 71,ef,46            an2b  R46,ef           SCVNT = 0;                        # LSO output line 4 OFF (Speed Control Vent)
7321: 71,fe,46            an2b  R46,fe           SCVAC = 0;                        # LSO output line 0 OFF (Speed Control Vacuum)
7324: f0                  ret                    return;


  Sub66:
7325: b1,ff,42            ldb   R42,ff           R42 = ff;
7328: c7,73,1b,ff,42      stb   R42,[R72+ff1b]   Vsc_count = R42;                  # SCCS Count? R9B = R42 why such a strange instruction?
732d: f0                  ret                    return;


#################################################################
# Tasklist Routine at 2151
# Continuous Self Test
# See GUFB Chapter 28
#################################################################

  Cont_Self_Test:
732e: 2d,66               scall 7096             Set_EGRFlags();
7330: ef,aa,10            call  83dd             Sub116();
7333: 71,ef,2b            an2b  R2b,ef           Disable_isc = 0;
7336: 38,2a,03            jb    B0,R2a,733c      if (VSCDT == 0)  {
7339: 71,df,d9            an2b  Rd9,df           Vvsfl1 = 0; }
#
733c: 3a,2a,01            jb    B2,R2a,7340      if (Vip_enable == 0)  {
733f: f0                  ret                    return; }
#
7340: 30,2a,01            jnb   B0,R2a,7344      if (VSCDT == 1)  {
7343: f0                  ret                    return; }

7344: 71,f7,2b            an2b  R2b,f7           Error_detected = 0;
#
# Fuel Pump Circuit Test
# GUFB pp. 28-26, 28-27
#
7347: b3,78,f3,42         ldb   R42,[R78+f3]     R42 = V_FPMFLG;                   # 1 = do fuel pump circuit test
734b: e0,42,13            djnz  R42,7361         R42--;
                                                 if (R42 != 0) goto 7361;          # skip test
734e: 37,46,18            jnb   B7,R46,7369      if (Pump == 1)  {
# GUFB p. 28-27 - pump is on
7351: 3a,a1,03            jb    B2,Ra1,7357      if (UNDSP == 0)  {                 # Engine running
7354: 91,80,d9            orb   Rd9,80           RMSPRU = 1; }
#
7357: c7,72,46,00         stb   R0,[R72+46]      VIP_FPMTMR = 0;                   # Clear timer
735b: 3c,df,03            jb    B4,Rdf,7361      if (FPM == 0)  {
735e: 91,08,2b            orb   R2b,8            Error_detected = 1; }
# 
7361: ef,7c,03            call  76e0             updTCodes(4004,14);
7364: 04,40,14            #args  
7367: 20,2b               sjmp  7394             goto 7394; }
# GUFB p. 28-26 - pump is off
7369: 37,d9,18            jnb   B7,Rd9,7384      if (RMSPRU == 1)  {
736c: 71,7f,d9            an2b  Rd9,7f           RMSPRU = 0;                       
736f: ef,de,fc            call  7050             Get_diag_vals();                   # load diagnostic testing registers
7372: ef,7a,07            call  7aef             Sub74();                           # call set HSO Time Hold = Master IO Timer Lo + # 0003
7375: c9,7f,73            push  737f             push(737f);                        # return to this address
7378: ef,fb,06            call  7a76             Test_IO(INT_Mask,4680);            # E8 Fuel Pump Output Circuit Check
737b: 08,00,80,46         #args  
737f: 90,1a,2b            orb   R2b,R1a          Flags_2B |= R1a;
7382: 20,16               sjmp  739a             goto 739a; }
#
7384: b3,72,46,42         ldb   R42,[R72+46]     R42 = VIP_FPMTMR;
7388: 9b,78,f5,42         cmpb  R42,[R78+f5]     
738c: d3,06               jltu  7394             if ((uns) R42 >= V_FPMTM)  {
738e: 34,df,03            jnb   B4,Rdf,7394      if (FPM == 1)  {
7391: 91,08,2b            orb   R2b,8            Error_detected = 1; } }
7394: ef,49,03            call  76e0             updTCodes(8004,13);               # Fuel Pump Open ECA to MTR GND (?) - code 95?
7397: 04,80,13            #args  
739a: ef,43,03            call  76e0             updTCodes(100,11);
739d: 00,01,11            #args  
73a0: 3b,2c,04            jb    B3,R2c,73a7      if (Wigflg == 0)  {
73a3: 37,a1,01            jnb   B7,Ra1,73a7      if (CRKFLG == 1)  {               # exit if CRANKING
73a6: f0                  ret                    return; } }
#
# ECT Open/Short Test 
# GUFB p. 28-9
#
73a7: 71,7f,d8            an2b  Rd8,7f           Threshold_lvl = 0;
73aa: ef,b7,05            call  7964             Compare(ECTMIN,IECT);             # ECT raw from AD conversion
73ad: 7e,90,12,01         #args  
73b1: ef,2c,03            call  76e0             updTCodes(2018,0d);               # trouble code bit 2 - ECT open circuit trouble code
73b4: 18,20,0d            #args  
73b7: ef,aa,05            call  7964             Compare(IECT,ECTMAX);
73ba: 12,01,80,90         #args  
73be: ef,1f,03            call  76e0             updTCodes(8020,09);
73c1: 20,80,09            #args  
#
# ACT Sensor Tests
# GUFB p. 28-10
#
73c4: ef,9d,05            call  7964             Compare(ACTMIN,IACT);
73c7: 68,90,14,01         #args  
73cb: 2b,13               scall 76e0             updTCodes(1008,0f);
73cd: 08,10,0f            #args  
73d0: ef,91,05            call  7964             Compare(IACT,ACTMAX);
73d3: 14,01,6a,90         #args  
73d7: 2b,07               scall 76e0             updTCodes(4010,0b);
73d9: 10,40,0b            #args  
#
# BP Sensor Test
# GUFB p. 28-11
#
73dc: 9b,f8,4b,00         cmpb  R0,[Rf8+4b]      
73e0: df,21               je    7403             if (0 != BPPSW)  {                # skip test if BP sensor not present
73e2: b3,72,b6,42         ldb   R42,[R72+b6]     R42 = BAPTMR;
73e6: 9b,79,96,00,42      cmpb  R42,[R78+96]     
73eb: d1,05               jleu  73f2             if ((uns) BAPTMR > VBPMAX )  {
73ed: 91,08,2b            orb   R2b,8            Error_detected = 1;
73f0: 20,11               sjmp  7403             goto 7403; }
#
73f2: ef,6f,05            call  7964             Compare(MDELTA,VBPDL2);
73f5: 0a,01,04,91         #args  
73f9: 3b,2b,07            jb    B3,R2b,7403      if (Error_detected == 0)  {
73fc: ef,65,05            call  7964             Compare(VBPDL1,MDELTA);
73ff: 02,91,0a,01         #args                  } }
7403: 2a,db               scall 76e0             updTCodes(859,1);
7405: 59,08,01            #args  
#
# MAF Sensor Test
# GUFB p. 28-12
#
7408: 8b,79,92,00,ae      cmpw  Rae,[R78+92]     
740d: db,07               jgeu  7416             if (N > VMARPM)  {
# RPM above MAF test max
740f: ef,52,05            call  7964             Compare(IMAF,VMAMAX);
7412: 24,01,0e,91         #args                  }
#
7416: 2a,c8               scall 76e0             updTCodes(2054,0c);
7418: 54,20,0c            #args  
741b: 3a,a1,12            jb    B2,Ra1,7430      if (UNDSP == 0)  {
# In run mode
741e: a3,72,be,42         ldw   R42,[R72+be]     R42 = TSLPIP;
7422: 8b,79,86,00,42      cmpw  R42,[R78+86]     
7427: d9,07               jgtu  7430             if ((uns) R42 <= VMAFPIPLMT)  {
7429: ef,38,05            call  7964             Compare(VMAMIN,IMAF);
742c: 10,91,24,01         #args                  } }
7430: 2a,ae               scall 76e0             updTCodes(104c,10);
7432: 4c,10,10            #args  
#
# TP Sensor Tests
# GUFB p. 28-20
#
7435: ef,2c,05            call  7964             Compare(TAPMIN,ITP);
7438: 70,90,22,01         #args  
743c: 2a,a2               scall 76e0             updTCodes(PIPACL,0e);
743e: 38,02,0e            #args  
7441: ef,20,05            call  7964             Compare(ITP,TAPMAX);
7444: 22,01,6e,90         #args  
7448: 2a,96               scall 76e0             updTCodes(840,0a);
744a: 40,08,0a            #args  
744d: 33,2c,02            jnb   B3,R2c,7452      if (Wigflg == 0) goto 7452;
7450: 20,90               sjmp  74e2             goto 74e2;
# Not in wiggle test mode
#
# EGO Switching Tests
# GUFB pp. 28-23 - 28-25
#
7452: b3,78,24,22         ldb   R22,[R78+24]     R22 = VEGOBP;
7456: e0,22,39            djnz  R22,7492         R22--;
                                                 if (R22 != 0) goto 7492;
# VEGOBP = 1
#
# Part Throttle Counter (PTCNT) logic
# GUFB p. 28-24
#
7459: b3,72,56,20         ldb   R20,[R72+56]     R20 = PTCNT;
745d: 98,00,d0            cmpb  Rd0,R0           
7460: d7,03               jne   7465             if (APT == 0)  {
# At part throttle (APT == 0)
7462: 91,80,e6            orb   Re6,80           VPTFLG = 1; }
7465: 37,d0,11            jnb   B7,Rd0,7479      if (APT < 0)  {
7468: 37,e6,0e            jnb   B7,Re6,7479      if (VPTFLG == 1)  {
746b: 71,7f,e6            an2b  Re6,7f           VPTFLG = 0;
746e: 17,20               incb  R20              R20++;                            # increment PTCNT
7470: d3,03               jnc   7475             if ((uns) R20 >= 0)  {
7472: b1,ff,20            ldb   R20,ff           R20 = ff; }                       # clip PTCNT to 255
7475: c7,72,56,20         stb   R20,[R72+56]     PTCNT = R20; } }                  # and save
#
# EGO Switching Test cont'd
# GUFB p. 28-24
#
7479: 9b,f3,a6,00,c9      cmpb  Rc9,[Rf2+a6]                                       
747e: d9,02               jgtu  7482             if ((uns) ATMR2 > VEGOTM) goto 7482; # Skip PTCNT check if engine hasn't been warm long enough
7480: 20,10               sjmp  7492             goto 7492;
#
7482: b3,fe,0b,32         ldb   R32,[Rfe+b]      R32 = THRMHP;
7486: e0,32,03            djnz  R32,748c         R32--;
                                                 if (R32 != 0) goto 748c;          # Skip upstream check if not equipped with secondary air
7489: 3c,47,06            jb    B4,R47,7492      if (TAD == 1) goto 7492;           # if upstream air active, skip PTCNT check
#
748c: 51,b8,c5,32         an3b  R32,Rc5,b8       R32 = Fmem_flags & b8;            
7490: df,0f               je    74a1             if (R32 == 0) goto 74a1;           # Do PTCNT check if no ECT, ACT, TP, or MAP failures detected
#  
7492: c7,72,56,00         stb   R0,[R72+56]      PTCNT = 0;                        # reset PTCNT
7496: 98,22,00            cmpb  R0,R22           
7499: df,04               je    749f             if (0 == VEGOBP) goto 749f;
749b: 20,1c               sjmp  74b9             goto 74b9;

749d: 20,02               sjmp  74a1                                               # Skip over following jump
#
749f: 20,41               sjmp  74e2             goto 74e2;
# Check part throttle counter
74a1: 9b,f3,a7,00,20      cmpb  R20,[Rf2+a7]     
74a6: d9,02               jgtu  74aa             if ((uns) PTCNT > Vptcnt ) goto 74aa;
74a8: 20,38               sjmp  74e2             goto 74e2;
#
# EGO Switching Test "B" Logic
# GUFB p. 28-25
# 
74aa: b3,73,25,01,30      ldb   R30,[R72+125]    R30 = EGOSS1;
74af: 9b,f3,a5,00,30      cmpb  R30,[Rf2+a5]     
74b4: db,03               jgeu  74b9             if (R30 > VEGOSW)  {
74b6: 91,08,2b            orb   R2b,8            Error_detected = 1; }
#
74b9: 2a,25               scall 76e0             updTCodes(0201,8);
74bb: 01,02,08            #args  
#
74be: b3,fe,16,42         ldb   R42,[Rfe+16]     R42 = NUMEGO;
74c2: 98,22,00            cmpb  R0,R22           
74c5: d7,05               jne   74cc             if (0 != VEGOBP) goto 74cc;
74c7: 99,01,42            cmpb  R42,1            
74ca: d7,02               jne   74ce             if (NUMEGO != 1) goto 74ce;
#
74cc: 20,0f               sjmp  74dd             goto 74dd;                        # only one EGO, we're done
#
74ce: b3,73,26,01,30      ldb   R30,[R72+126]    R30 = Egoss2;
74d3: 9b,f3,a5,00,30      cmpb  R30,[Rf2+a5]     
74d8: db,03               jgeu  74dd             if (R30 > VEGOSW)  {
74da: 91,08,2b            orb   R2b,8            Error_detected = 1; }
#
74dd: 2a,01               scall 76e0             updTCodes(401,12);
74df: 01,04,12            #args  
#
# Continuous VSS test cont'd
# GUFB p. 28-22
#
74e2: b3,79,f9,00,42      ldb   R42,[R78+f9]     R42 = VSSSW;
74e7: e0,42,65            djnz  R42,754f         R42--;
                                                 if (VSSSW != 1) goto 754f;        # Skip test if not enabled
74ea: b3,78,c7,42         ldb   R42,[R78+c7]     R42 = VSTYPE;                     # = 1 on A9L
74ee: 98,00,42            cmpb  R42,R0           
74f1: df,5c               je    754f             if (VSTYPE != 0)  {               # Skip test if no VSS
#
# VSSTMR logic
# GUFB p. 28-22 bottom
#
74f3: b3,fe,02,42         ldb   R42,[Rfe+2]      R42 = TRLOAD;
74f7: 99,04,42            cmpb  R42,4            
74fa: db,1a               jgeu  7516             if ((uns) TRLOAD >= 4) goto 7516;
74fc: a3,73,dc,00,42      ldw   R42,[R72+dc]     R42 = LOAD;
7501: 3c,c5,0e            jb    B4,Rc5,7512      if (TFMFLG == 1) goto 7512;
7504: 37,d0,0b            jnb   B7,Rd0,7512      if (APT >= 0) goto 7512;
7507: 8b,f3,14,01,42      cmpw  R42,[Rf2+114]    
750c: d9,04               jgtu  7512             if ((uns) R42 > VSLOAD) goto 7512;
750e: 20,18               sjmp  7528             goto 7528;

7510: 20,02               sjmp  7514    

7512: 20,0e               sjmp  7522             goto 7522;

7514: 20,0c               sjmp  7522
#
7516: 37,e7,09            jnb   B7,Re7,7522      if (NDSFLG == 1)  {
7519: 8b,f3,74,01,ae      cmpw  Rae,[Rf2+174]    
751e: d3,02               jltu  7522             if ((uns) N < VSAMIN) goto 7522;
7520: 20,06               sjmp  7528             goto 7528; }
#
7522: c7,72,49,00         stb   R0,[R72+49]      VSSTMR = 0;
7526: 20,27               sjmp  754f             goto 754f;
#
7528: 8b,f3,76,01,ae      cmpw  Rae,[Rf2+176]    
752d: db,04               jgeu  7533             if ((uns) N >= VSMMIN) goto 7533;
752f: 20,1e               sjmp  754f             goto 754f;

7531: 20,0d               sjmp  7540    

7533: b3,72,49,42         ldb   R42,[R72+49]     R42 = VSSTMR;
7537: 9b,f3,7a,01,42      cmpb  R42,[Rf2+17a]    
753c: db,02               jgeu  7540             if ((uns) VSSTMR >= VSSTIM) goto 7540; # not stable yet
753e: 20,0f               sjmp  754f             goto 754f;

7540: b3,73,3d,01,42      ldb   R42,[R72+13d]    R42 = VSBAR_H;
7545: 9b,f3,78,01,42      cmpb  R42,[Rf2+178]    
754a: db,03               jgeu  754f             if (VSBAR_H > VSSMN1)  {
754c: 91,08,2b            orb   R2b,8            Error_detected = 1; } } }
#
754f: 29,8f               scall 76e0             updTCodes(8003,2);
7551: 03,80,02            #args  

7554: 36,d9,02            jnb   B6,Rd9,7559      if (Vegrbp == 0) goto 7559;
7557: 20,d9               sjmp  7632             goto 7632;

#
# EGR Sensor Test
# GUFB pp. 28-13 - 28-15
#
7559: 3e,e6,0d            jb    B6,Re6,7569      if (Pfehp_flg == 0)  {
# Sonic EGR
755c: ef,70,09            call  7ecf             ChkSensor(IEVP,VEVPLL,EVPMIN,32); # Lo,Hi limit, E hi = none, E Lo - PFE/EVP/ (sonic) voltage below closed limit
755f: 16,01,b4,90,b0,90,32,00 #args  
7567: 20,1f               sjmp  7588             goto 7588; }
# PFE EGR
7569: 3f,d0,02            jb    B7,Rd0,756e      if (APT < 0) goto 756e;
#
756c: 20,80               sjmp  75ee             goto 75ee;
# Closed throttle
756e: a3,72,88,42         ldw   R42,[R72+88]     R42 = NBAR;
7572: 8b,79,c8,00,42      cmpw  R42,[R78+c8]     
7577: db,f3               jgeu  756c             if ((uns) NBAR >= VN) goto 756c;
#
7579: 2a,5c               scall 77d7             Urolav_T(Fiept,IEPT,VTCEPT);
757b: 80,03               #args  
757d: ef,4f,09            call  7ecf             ChkSensor(Fiept,VEPTIL,Eptmin,3432); # PFE/EVP/ (sonic) voltage below closed limit, Defective PFE/EPT sensor ?
7580: 80,03,40,91,34,91,32,34 #args  
7588: b0,1a,40            ldb   R40,R1a          R40 = R1a;
758b: 2a,60               scall 77ed             Set_TC(31);
758d: 31                  #args  
758e: 29,50               scall 76e0             updTCodes(802a,3);
7590: 2a,80,03            #args  
7593: 2a,58               scall 77ed             Set_TC(35);
7595: 35                  #args  
7596: 29,48               scall 76e0             updTCodes(832,7);
7598: 32,08,07            #args  
759b: 33,2c,08            jnb   B3,R2c,75a6      if (Wigflg == 1)  {
759e: 71,bf,2c            an2b  R2c,bf           EGRFG2 = 0;
75a1: 71,7f,2c            an2b  R2c,7f           EGRFG1 = 0;
75a4: 20,87               sjmp  762d             goto 762d; }
# Not wiggle test
75a6: 2a,45               scall 77ed             Set_TC(32);
75a8: 32                  #args  
75a9: 29,35               scall 76e0             updTCodes(4002,4);
75ab: 02,40,04            #args  
75ae: 36,e6,0a            jnb   B6,Re6,75bb      if (Pfehp_flg == 1)  {
75b1: 2a,3a               scall 77ed             Set_TC(34);
75b3: 34                  #args  
75b4: 29,2a               scall 76e0             updTCodes(1002,6);
75b6: 02,10,06            #args  
75b9: 20,33               sjmp  75ee             goto 75ee; }
#
75bb: 3c,40,e0            jb    B4,R40,759e      if (B4_R40 == 1) goto 759e;
75be: 98,00,d3            cmpb  Rd3,R0           
75c1: d7,28               jne   75eb             if (Rd3 != 0) goto 75eb;     # EGRDC?
75c3: 71,7f,2c            an2b  R2c,7f           EGRFG1 = 0;
75c6: 3e,2c,07            jb    B6,R2c,75d0      if (EGRFG2 == 0)  {
75c9: c7,72,4a,00         stb   R0,[R72+4a]      VIPTMR = 0;
75cd: 91,40,2c            orb   R2c,40           EGRFG2 = 1; }
#
75d0: ef,91,03            call  7964             Compare(IEVP,VEVPHL);
75d3: 16,01,b6,90         #args  
75d7: 33,2b,0a            jnb   B3,R2b,75e4      if (Error_detected == 0) goto 75e4;
75da: b3,72,4a,18         ldb   R18,[R72+4a]     R18 = VIPTMR;
75de: 9b,78,3c,18         cmpb  R18,[R78+3c]     
75e2: d3,4e               jltu  7632             if ((uns) VIPTMR < VEITMR) goto 7632;
75e4: 28,fa               scall 76e0             updTCodes(1002,6);
75e6: 02,10,06            #args  
75e9: 20,42               sjmp  762d             goto 762d;
#
75eb: 71,bf,2c            an2b  R2c,bf           EGRFG2 = 0;
75ee: 9b,78,29,d3         cmpb  Rd3,[R78+29]     
75f2: d3,aa               jltu  759e             if ((uns) EGRDC < VCRTDC) goto 759e;
75f4: a3,73,dc,00,42      ldw   R42,[R72+dc]     R42 = LOAD;
75f9: 8b,78,2e,42         cmpw  R42,[R78+2e]     
75fd: d9,9f               jgtu  759e             if ((uns) LOAD > VEGRLOAD ) goto 759e;
75ff: 3f,2c,07            jb    B7,R2c,7609      if (EGRFG1 == 0)  {
7602: 91,80,2c            orb   R2c,80           EGRFG1 = 1;
7605: c7,72,4a,00         stb   R0,[R72+4a]      VIPTMR = 0; }
7609: 3e,e6,09            jb    B6,Re6,7615      if (Pfehp_flg == 0)  {
760c: ef,55,03            call  7964             Compare(VEVPCL,IEVP);
760f: ba,90,16,01         #args  
7613: 20,0b               sjmp  7620             goto 7620; }

7615: 29,c0               scall 77d7             Urolav_T(Cfiept);
7617: 7e,03               #args  
7619: ef,48,03            call  7964             Compare(Cfiept,VEPTCL);
761c: 7e,03,46,91         #args  
7620: 33,2b,0a            jnb   B3,R2b,762d      if (Error_detected == 0) goto 762d;
7623: b3,72,4a,18         ldb   R18,[R72+4a]     R18 = VIPTMR;
7627: 9b,78,28,18         cmpb  R18,[R78+28]     
762b: d3,05               jltu  7632             if ((uns) VIPTMR >= VECTMR)  {
#
762d: 28,b1               scall 76e0             updTCodes(2002,5);
762f: 02,20,05            #args                  }
#
7632: 71,f7,2b            an2b  R2b,f7           Error_detected = 0;
#
# PIP/IDM Logic (For Tach Buffer)
# GUFB p. 28-19
#
7635: 8b,78,fa,ae         cmpw  Rae,[R78+fa]     
7639: db,02               jgeu  763d             if ((uns) N >= VLORPM) goto 763d;
763b: 20,36               sjmp  7673             goto 7673;
#
763d: 2b,25               scall 7964             Compare(TSLPIP,VPIPTM);
763f: 3e,01,7c,90         #args  
7643: 33,2b,0b            jnb   B3,R2b,7651      if (Error_detected == 1)  {
7646: 91,01,2c            orb   R2c,1            IDM_BYPASS = 1;
7649: c7,72,3f,00         stb   R0,[R72+3f]      IDM_FAULT_CNT = 0;
764d: c3,72,44,00         stw   R0,[R72+44]      TSLIDM = 0; }                     # reset IDM timer
#
7651: 28,8d               scall 76e0             updTCodes(4001,0);
7653: 01,40,00            #args  
7656: 38,2c,0d            jb    B0,R2c,7666      if (IDM_BYPASS == 0)  {
7659: 2b,09               scall 7964             Compare(TSLIDM,VIDMTM);
765b: c4,01,78,90         #args  
765f: 28,7f               scall 76e0             updTCodes(2001,15);
7661: 01,20,15            #args  
7664: 20,11               sjmp  7677             goto 7677; }
#
7666: a3,72,44,42         ldw   R42,[R72+44]     R42 = TSLIDM;
766a: 9b,f2,76,43         cmpb  R43,[Rf2+76]     
766e: d1,07               jleu  7677             if ((uns) TSLIDM > VIDMST )  {
7670: 71,fe,2c            an2b  R2c,fe           IDM_BYPASS = 0;
7673: c3,72,44,00         stw   R0,[R72+44]      TSLIDM = 0; }
#
7677: 29,80               scall 77f9             upd_flflg(LIO_Port,20);
7679: 03,00,20            #args  
767c: 29,7b               scall 77f9             upd_flflg(HSI_Mask,HSO_time);
767e: 0c,00,80            #args  
7681: 29,76               scall 77f9             upd_flflg(30,40);
7683: 30,00,40            #args  
7686: 29,71               scall 77f9             upd_flflg(MKAY,STACK);
7688: c0,00,10            #args  
768b: 29,6c               scall 77f9             upd_flflg(400,LSO_Port);
768d: 00,04,02            #args  
7690: 29,67               scall 77f9             upd_flflg(300,INT_Mask);
7692: 00,03,08            #args  
7695: 33,2c,09            jnb   B3,R2c,76a1      if (Wigflg == 1)  {
7698: 37,d8,04            jnb   B7,Rd8,769f      if (Threshold_lvl == 1)  {
769b: 29,0f               scall 77ac             Set_STO();                        # tweak flags, set STO on and return
769d: 20,02               sjmp  76a1             goto 76a1; }

769f: 29,13               scall 77b4             Reset_STO(); }                    # set STO off flag, set STO output low, and set STO trigger
#
# WARM_UP Counter Logic
# GUFB p. 6-49, 28-8 top
#
76a1: 39,25,3b            jb    B1,R25,76df      if (WARM_UP == 1) return;
76a4: 3f,a1,38            jb    B7,Ra1,76df      if (CRKFLG == 1) return;
76a7: 3a,a1,35            jb    B2,Ra1,76df      if (UNDSP == 1) return;
76aa: b3,73,2d,ff,14      ldb   R14,[R72+ff2d]   R14 = TCSTRT;
76af: 9b,f2,6c,14         cmpb  R14,[Rf2+6c]     
76b3: d6,2a               jge   76df             if (R14 >= VECT5) return;
76b5: 9b,f3,fe,00,b0      cmpb  Rb0,[Rf2+fe]     
76ba: da,23               jle   76df             if (ECT <= VECT3) return;
76bc: 91,02,25            orb   R25,2            WARM_UP = 1;
76bf: 30,ef,1d            jnb   B0,Ref,76df      if (Power_up == 0) return;         # Already incremented this startup cycle
76c2: 3d,2b,1a            jb    B5,R2b,76df      if (STIFLG == 1) return;           # jump if STI input is high
#
# KAM Code Counter Increment Logic
# GUFB p. 28-8, top
#
# incr the # times the test has been run for index R38 and less ?
76c5: a1,17,00,38         ldw   R38,17           R38 = 17;
# 
76c9: b3,39,c9,07,3a      ldb   R3a,[R38+7c9]    R3a = [R38+Kam_index6];           # incr 22 bytes in Table clamp at max of FF
76ce: 17,3a               incb  R3a              R3a++;
76d0: d7,02               jne   76d4             if (R3a == 0)  {
76d2: 15,3a               decb  R3a              R3a--; }                          # clamp to FF max
#
76d4: c7,39,c9,07,3a      stb   R3a,[R38+7c9]    [R38+Kam_index6] = R3a;
76d9: e0,38,ed            djnz  R38,76c9         R38--;
                                                 if (R38 != 0) goto 76c9;
76dc: 71,fe,ef            an2b  Ref,fe           Power_up = 0; }                   # Clear Power_up flag so we don't do this again
# Exit
76df: f0                  ret                    return;


#######################################################
# sets and clears trouble code bit flags
# first param (at 001A) bottom 3 bits are index in 7C4 Table?
# rest of bit >> 3 and - 1 are error flag bit
# third param is index into tables
#######################################################

  updTCodes:
76e0: 28,dc               scall 77be             GetbytesR1a(3);                   # copy the three bytes at return address to R1A/1B/1C
76e2: 03                  #args  
76e3: bc,1c,14            ldsbw R14,R1c          R14 = (int)R1c;                   # 3rd param byte to word
76e6: 44,f2,14,42         ad3w  R42,R14,Rf2      R42 = R14 + Rf2;                  # address 8E5A + data offset
76ea: b3,43,d7,00,42      ldb   R42,[R42+d7]     R42 = [R42+d7];                   # read ROM at lookup address (table at 8F31)
76ef: 44,f2,14,3a         ad3w  R3a,R14,Rf2      R3a = R14 + Rf2;                  # same ROM address AGAIN
76f3: b3,3b,c1,00,3a      ldb   R3a,[R3a+c1]     R3a = [R3a+c1];                   # what is this byte RAM Table? (table at 8F1B)
76f8: ac,1a,18            ldzbw R18,R1a          R18 = (uns)R1a;                   # 1st param byte to word
76fb: 71,07,18            an2b  R18,7            R18 &= 7;                         # mask out bottom 3 bits of first param (0 -7)
76fe: 65,c4,07,18         ad2w  R18,7c4          R18 += Kam_indexl;                # R18 is now a pointer to ?
7702: 01,1c               clrw  R1c              R1c = 0;
7704: 18,03,1a            shrb  R1a,3            R1a /= 8;                         # first param >> 3 (shift out offset bits) 5 bits left
7707: df,07               je    7710             if (R1a != 0)  {                  # zero value is special ( flag bits are biased up by one )
7709: 15,1a               decb  R1a              R1a--;
770b: 07,1c               incw  R1c              R1c++;                            # R1C = 0001 now
770d: 09,1a,1c            shlw  R1c,R1a          R1c <<= R1a; }                    # creates a mask of bit # (R1A - 1)
#
7710: a3,73,02,02,34      ldw   R34,[R72+202]    R34 = Fmem_monitor;               # 382 error bit flags word
7715: b3,15,aa,01,30      ldb   R30,[R14+1aa]    R30 = [R14+C14FIL];               # R14 is second param
771a: 98,42,00            cmpb  R0,R42                                             # value looked up above
771d: df,0d               je    772c             if (0 == R42) goto 772c;
771f: 33,2c,07            jnb   B3,R2c,7729      if (Wigflg == 1)  {
7722: b3,78,f2,3a         ldb   R3a,[R78+f2]     R3a = WIGLVL;
7726: b1,ff,42            ldb   R42,ff           R42 = ff; }
#
7729: 3b,2b,2a            jb    B3,R2b,7756      if (Error_detected == 0)  {
#
772c: 98,00,30            cmpb  R30,R0           
772f: df,02               je    7733             if (R30 != 0)  {
7731: 15,30               decb  R30              R30--; }
#
7733: 5b,78,7f,3a,3b      sb3b  R3b,R3a,[R78+7f] R3b = R3a - Filhys;
7738: 98,30,3b            cmpb  R3b,R30          
773b: d1,05               jleu  7742             if ((uns) R3b > R30 )  {
773d: 02,1c               cplw  R1c              R1c = ~R1c;                       # invert mask
773f: 60,1c,34            an2w  R34,R1c          R34 &= R1c; }                     # clear the error bit
#
7742: b1,28,42            ldb   R42,28           R42 = 28;
7745: 9b,15,ca,07,42      cmpb  R42,[R14+7ca]                                      # R14 is still? 3rd param byte (0x76E3)
774a: d9,08               jgtu  7754             if ((uns) R42 <= [R14+K14CNT])  {
774c: 12,1b               cplb  R1b              R1b = ~R1b;
774e: 72,18,1b            an2b  R1b,[R18]        R1b &= [R18];
7751: c6,18,1b            stb   R1b,[R18]        [R18] = R1b; }
#
7754: 20,37               sjmp  778d             goto 778d; }

7756: 71,f7,2b            an2b  R2b,f7           Error_detected = 0;
7759: 74,42,30            ad2b  R30,R42          R30 += R42;                       # add second param and looked up ROm value
775c: d3,03               jnc   7761             if ((uns) R30 >= 0)  {
775e: b1,ff,30            ldb   R30,ff           R30 = ff; }                       # clamp max value
7761: 98,30,3a            cmpb  R3a,R30                                            # compare second param sum and Table lookup value
7764: db,27               jgeu  778d             if (R3a > R30)  {
7766: 89,c6,07,18         cmpw  R18,7c6                                            # what is this address ?
776a: d7,13               jne   777f             if (R18 != 7c6) goto 777f;
776c: 51,f8,1b,33         an3b  R33,R1b,f8       R33 = R1b & f8;                   # clr bits 0,1,2
7770: df,0d               je    777f             if (R33 == 0) goto 777f;
7772: b2,18,33            ldb   R33,[R18]        R33 = [R18];
7775: 71,f8,33            an2b  R33,f8           R33 &= f8;                        # clr bits 0,1,2
7778: df,05               je    777f             if (R33 == 0) goto 777f;
777a: 70,1b,33            an2b  R33,R1b          R33 &= R1b;
777d: df,0b               je    778a             if (R33 != 0)  {
777f: 92,18,1b            orb   R1b,[R18]        R1b |= [R18];
7782: c6,18,1b            stb   R1b,[R18]        [R18] = R1b;
7785: c7,15,ca,07,00      stb   R0,[R14+7ca]     [R14+K14CNT] = 0; }
778a: 80,1c,34            orw   R34,R1c          R34 |= R1c; }                     # set the error bit
778d: 98,30,3a            cmpb  R3a,R30          
7790: db,03               jgeu  7795             if (R3a > R30)  {
7792: 91,80,d8            orb   Rd8,80           Threshold_lvl = 1; }
7795: c7,15,aa,01,30      stb   R30,[R14+1aa]    [R14+C14FIL] = R30;               # save ? R14 is second param (ie 1AA + 0D = 1B7)
779a: c3,73,02,02,34      stw   R34,[R72+202]    Fmem_monitor = R34;               # 382 error bit flags, bit 2 set = ECT grounded
779f: f0                  ret                    return;


  clear_KAM:
77a0: ad,1d,16            ldzbw R16,1d           R16 = (uns)1d;
77a3: c7,17,c3,07,00      stb   R0,[R16+7c3]     [R16+7c3] = 0;                    # clear Table 7C4 to 7E0
77a8: e0,16,f8            djnz  R16,77a3         R16--;
                                                 if (R16 != 0) goto 77a3;
77ab: f0                  ret                    return;


  Set_STO:
77ac: 91,80,d6            orb   Rd6,80           Sto_on = 1;                       # tweak flags. set STO on and return
77af: 91,20,46            orb   R46,20           Sto_state = 1;                    # LSO output line 5 (STO) ON (MIL)
# set STO off flag, set STO output low, and set STO trigger
77b2: 20,06               sjmp  77ba             goto 77ba;

  Reset_STO:
77b4: 91,40,d6            orb   Rd6,40           Sto_off = 1;                      # set STO OFF flag
77b7: 71,df,46            an2b  R46,df           Sto_state = 0;                    # LSO output line 5 (STO) OFF (MIL)
77ba: 91,04,2b            orb   R2b,4            Sto_trigger = 1;                  # set Self Test Output trigger
77bd: f0                  ret                    return;

################################################################
# copy specified bytes to R1A onwards
# see below for details
################################################################

  GetbytesR1a:
77be: a1,1a,00,16         ldw   R16,1a           R16 = 1a;                         # default destination is R1a onwards

################################################################
# copy specified bytes to register/memory pointed to by R16
# from return address in the GRANDCALLER subroutine.
# gets count (one byte) from return address of caller function.
# copies bytes from 'Grandcaller' function, and mods return addresses.
# Inputs -
#  R16: pointer to 1st result location
#  byte following call site: # of bytes to copy
#  bytes following grandcall site: data to copy
# Outputs -
#  R16: address of last byte copied + 1
#  Desired registers loaded
#  Return addresses on stack incremented past parameters
# Clobbers: R3a-R3d, R42-R43
################################################################

  GetbytesR16:
77c2: cc,3c               pop   R3c              R3c = pop();                      # Caller's (normal) return address
77c4: b2,3d,3a            ldb   R3a,[R3c++]      R3a = [R3c++];                    # Get count of bytes, Inc return address
77c7: cc,42               pop   R42              R42 = pop();                      # Get GrandCaller's return address
77c9: b2,43,3b            ldb   R3b,[R42++]      R3b = [R42++];
77cc: c6,17,3b            stb   R3b,[R16++]      [R16++] = R3b;
77cf: e0,3a,f7            djnz  R3a,77c9         R3a--;
                                                 if (R3a != 0) goto 77c9;          # Get no of bytes into dest. addr
77d2: c8,42               push  R42              push(R42);
77d4: c8,3c               push  R3c              push(R3c);                        # and push modded returns back.
77d6: f0                  ret                    return;


################################################################
# extended filter ? gets 2 bytes following call
# R32 is OLD AD sensor value
# R34 is new AD sensor value
# R36 is manged filtering factor
################################################################

  Urolav_T:
77d7: 2f,e5               scall 77be             GetbytesR1a(2);                   # get ROM bytes to R1A
77d9: 02                  #args                                                    # get 2 bytes into R1A from this caller's return addr
77da: a2,1a,32            ldw   R32,[R1a]        R32 = [R1a];                      # (address of) OLD AD sensor value
77dd: a3,72,96,34         ldw   R34,[R72+96]     R34 = IEVP;                       # NEW AD sensor value 216 - raw EVP
77e1: a3,79,ca,00,36      ldw   R36,[R78+ca]     R36 = VTCEPT;                     # manged filter factor
77e6: ef,7a,be            call  3663             Urolav();                         # filter
77e9: c2,1a,3e            stw   R3e,[R1a]        [R1a] = R3e;                      # save updated value
77ec: f0                  ret                    return;


################################################################
#
################################################################

  Set_TC:
77ed: 2f,cf               scall 77be             GetbytesR1a(1);                   # get 1 ROM byte to R1A
77ef: 01                  #args  
77f0: 98,1a,40            cmpb  R40,R1a          
77f3: d7,03               jne   77f8             if (R40 != R1a) return;
77f5: 91,08,2b            orb   R2b,8            Error_detected = 1; }
77f8: f0                  ret                    return;


################################################################
#
################################################################

  upd_flflg:
77f9: 2f,c3               scall 77be             GetbytesR1a(3);                   # get 3 ROM bytes to R1A
77fb: 03                  #args                                                    # 3 bytes to R1A,B,C from caller
77fc: 63,73,02,02,1a      an2w  R1a,[R72+202]    R1a &= Fmem_monitor;              # 382 word
7801: df,04               je    7807             if (R1a != 0)  {
7803: 90,1c,c5            orb   Rc5,R1c          Fmem_flags |= R1c;
7806: f0                  ret                    return; }

7807: 12,1c               cplb  R1c              R1c = ~R1c;
7809: 70,1c,c5            an2b  Rc5,R1c          Fmem_flags &= R1c;
780c: f0                  ret                    return;


################################################################
# Key On Engine Off (KOEO) Self -Tests
################################################################

  Do_KOEO:
780d: 3d,2c,25            jb    B5,R2c,7835      if (Disable_eolt == 0)  {         # jmp if disable EOLT set
7810: ef,a1,ff            call  77b4             Reset_STO();                      # set STO off flag, set STO output low, and set STO trigger
7813: ef,67,0a            call  827d             HW_Check();                       # do h/w RAM/ROM/CPU checks
7816: ef,37,f8            call  7050             Get_diag_vals();                  # load diagnostic testing registers
7819: 34,2a,05            jnb   B4,R2a,7821      if (Disable_nostart == 1)  {      # jump if not VIP mode flag : disable no start
781c: ef,8d,ff            call  77ac             Set_STO();                        # Set STO output on - diddle some flags?
781f: 27,fb               sjmp  781c             goto 781c; }                      # *HANG* - h/w error

7821: ef,20,00            call  7844             Do_Csum();                        # checksum the ROM
7824: 11,38               clrb  R38              R38 = 0;                          # test selector set to zero
7826: 38,30,0c            jb    B0,R30,7835      if (B0_R30 == 0)  {
7829: 91,10,2c            orb   R2c,10           Sto_hyper = 1;                    # STO very fast readout set
782c: ad,05,d4            ldzbw Rd4,5            Vip_code = (uns)5;
782f: ef,45,f7            call  6f77             Sub43();                          # the skip two returns do not return here
7832: 71,ef,2c            an2b  R2c,ef           Sto_hyper = 0; } }                # clear STO very fast readout
7835: 91,20,2c            orb   R2c,20           Disable_eolt = 1;                 # disable EOLT
7838: 91,40,2a            orb   R2a,40           No_start = 1;                     # Set VIP mode flag : no start
783b: 3f,46,05            jb    B7,R46,7843      if (Pump == 1) return;            # if LSO output line 7 is ON (Fuel Pump)
783e: 32,2a,02            jnb   B2,R2a,7843      if (Vip_enable == 0) return;      # jump if not VIP mode flag : VIP enable
7841: 20,88               sjmp  78cb             goto 78cb; }                      # zero 1CA VIP TIMER EX, incr R38 self test index, and return

7843: f0                  ret                    return;

############################################################
# ROM Checksum
############################################################


  Do_Csum:
7844: 01,30               clrw  R30              R30 = 0;
7846: 01,3c               clrw  R3c              R3c = 0;                          # 
7848: a1,6a,78,42         ldw   R42,786a         R42 = 786a;                       # Start address (2000)
784c: 46,43,00,3a         ad3w  R3a,R0,[R42++]   R3a = [R42++];                    # End address  (9fff)
7850: df,0d               je    785f             if (R3a != 0)  {                  # If real end address
7852: a2,43,3e            ldw   R3e,[R42++]      R3e = [R42++];
7855: 66,3b,3c            ad2w  R3c,[R3a++]      R3c += [R3a++];                   # add to sum
7858: 88,3e,3a            cmpw  R3a,R3e                                            # end address reached?
785b: d1,f8               jleu  7855             if ((uns) R3a <= R3e) goto 7855;  # loop
785d: 27,ed               sjmp  784c             goto 784c; }                      # load next ROM range

785f: 88,3c,00            cmpw  R0,R3c           
7862: df,03               je    7867             if (0 != R3c)  {                  # checksum zero ?
7864: 2b,48               scall 7bae             SaveTCode1(15);                   # E15 - EEC ROM fail
7866: 15                  #args                  }
7867: 20,62               sjmp  78cb             goto 78cb;                        # zero 1CA timer, incr R38 self test index, and return

7869: ff                        

######################## ROM checksum adresses ##############

786a: 00,20               word   2000                                              # Chkbase checksum base address.
                                                                                   # Set to zero to clear error code 15
786c: fe,9f               word   9ffe                                              # last (word) address of ROM checksum
786e: 00,00               word      0
#############################################################


  Test1:
7870: b0,30,32            ldb   R32,R30          R32 = R30;
7873: 28,f7               scall 796c             CompareTC(ECTMIN,IECT,61);     # 61 ECT sensor circuit grounded
7875: 7e,90,12,01,61      #args  
787a: 28,f0               scall 796c             CompareTC(IECT,ECTMAX,51);     # 51 ECT circuit open
787c: 12,01,80,90,51      #args  
7881: 98,30,32            cmpb  R32,R30          
7884: d7,09               jne   788f             if (R32 = R30)  {
7886: 2b,38               scall 7bc0             ChkRngeTC(IECT,Viect2,Viect1,21); # 21 ECT out of range
7888: 12,01,f8,90,f6,90,21 #args                 }
788f: 9b,f8,4b,00         cmpb  R0,[Rf8+4b]      
7893: df,1a               je    78af             if (0 != BPSSW)  {
7895: b3,72,b6,42         ldb   R42,[R72+b6]     R42 = BAPTMR;
7899: 9b,f3,16,01,42      cmpb  R42,[Rf2+116]    
789e: d1,05               jleu  78a5             if ((uns) R42 > VBPMAX )  {
78a0: 2b,0c               scall 7bae             SaveTCode1(22);                   # 22 MAP/BP sensor out of range
78a2: 22                  #args  
78a3: 20,0a               sjmp  78af             goto 78af; }

78a5: ef,18,03            call  7bc0             ChkRngeTC(MDELTA,VBPDL1,VBPDL2,22); # 22 MAP/BP sensor out of range
78a8: 0a,01,02,91,04,91,22 #args                 }
78af: a3,72,a4,42         ldw   R42,[R72+a4]     R42 = IMAF;
78b3: 8b,79,88,00,42      cmpw  R42,[R78+88]     
78b8: d3,11               jltu  78cb             if ((uns) R42 >= Vmafo1)  {
78ba: 8b,79,8e,00,42      cmpw  R42,[R78+8e]     
78bf: d3,05               jltu  78c6             if ((uns) R42 >= VMAMAX)  {
78c1: b1,56,1a            ldb   R1a,56           R1a = 56;                         # 56 MAF circuit above max voltage
78c4: 20,03               sjmp  78c9             goto 78c9; }

78c6: b1,26,1a            ldb   R1a,26           R1a = 26;                         # 26 MAF input out of range
78c9: 2a,e7               scall 7bb2             SaveTCode(); }                    # save code 26
78cb: c7,72,4a,00         stb   R0,[R72+4a]      VIPTMR = 0;                 # CALLED BELOW - zero timer, incr self test index and return
78cf: 17,38               incb  R38              R38++;
78d1: f0                  ret                    return;


  Test2:
78d2: 28,70               scall 7944             Sub67();
78d4: b0,30,32            ldb   R32,R30          R32 = R30;
78d7: 28,93               scall 796c             CompareTC(ACTMIN,IACT,64);     # 64 ACT sensor circuit grounded
78d9: 68,90,14,01,64      #args  
78de: 28,8c               scall 796c             CompareTC(IACT,ACTMAX,54);     # 54 ACT sensor circuit open
78e0: 14,01,6a,90,54      #args  
78e5: 98,30,32            cmpb  R32,R30          
78e8: d7,09               jne   78f3             if (R32 = R30)  {
78ea: 2a,d4               scall 7bc0             ChkRngeTC(IACT,Viact2,Viact1,Flags_24); # 24 ACT sensor out of range
78ec: 14,01,f0,90,ee,90,24 #args                 }
78f3: 3e,d9,1b            jb    B6,Rd9,7911      if (Vegrbp == 0)  {
78f6: 3e,e6,0d            jb    B6,Re6,7906      if (Pfehp_flg == 0)  {
78f9: ef,d3,05            call  7ecf             ChkSensor(IEVP,VEVPLL,EVPMIN,3432); # 32 EGR not controlling,E34 Insufficient EGR flow
78fc: 16,01,b4,90,b0,90,32,34 #args  
7904: 20,0b               sjmp  7911             goto 7911; }

7906: ef,c6,05            call  7ecf             ChkSensor(IEVP,VEPTLL,Eptmin,3434); # 34 Insufficient EGR flow
7909: 16,01,38,91,34,91,34,34 #args              }
7911: b3,fe,02,42         ldb   R42,[Rfe+2]      R42 = TRLOAD;
7915: 99,03,42            cmpb  R42,3            
7918: d3,0b               jltu  7925             if ((uns) R42 >= 3)  {
791a: 99,04,42            cmpb  R42,4            
791d: d9,06               jgtu  7925             if ((uns) R42 <= 4)  {
791f: 37,e7,03            jnb   B7,Re7,7925      if (NDSFLG == 1)  {
7922: 2a,8a               scall 7bae             SaveTCode1(67);                   # 67 NPS circuit open with Air conditioning on
7924: 67                  #args                  } } }                             # 67 Neutral Pressure switch (NPS) circuit open
7925: 37,ee,03            jnb   B7,Ree,792b      if (A3C == 1)  {
7928: 2a,84               scall 7bae             SaveTCode1(79);                   # 79 A/C on / Defrost
792a: 79                  #args                  }
792b: b3,f6,14,42         ldb   R42,[Rf6+14]     R42 = PSPSHP;                     # (0 on A9L)
792f: 99,01,42            cmpb  R42,1            
7932: d7,07               jne   793b             if (R42 == 1)  {
7934: 34,27,04            jnb   B4,R27,793b      if (POWSFG == 1)  {
7937: ef,74,02            call  7bae             SaveTCode1(52);                   # 52 Power Steering Pressure Switch circuit open
793a: 52                  #args                  } }
793b: 28,2f               scall 796c             CompareTC(Vkypwr,IIVPWR,19);      # 19 Failure in ECC reference voltage
793d: 52,90,0c,01,19      #args  
7942: 20,97               sjmp  79db             goto 79db;

  Sub67:
7944: b0,30,32            ldb   R32,R30          R32 = R30;
7947: 28,23               scall 796c             CompareTC(TAPMIN,ITP,63);         # 63 TP sensor circuit below min voltage
7949: 70,90,22,01,63      #args  
794e: 28,1c               scall 796c             CompareTC(ITP,TAPMAX,53);         # 53 TP sensor circuit open, above max voltage
7950: 22,01,6e,90,53      #args  
7955: 98,30,32            cmpb  R32,R30          
7958: d7,09               jne   7963             if (R32 != R30) return;
795a: 2a,64               scall 7bc0             ChkRngeTC(ITP,Vtap1,Vtap2,23);    # 23 - TP out of range during self test
795c: 22,01,5c,90,5e,90,23 #args                 }
7963: f0                  ret                    return;


#######################################################
# Compare two values. First value must be less than second
# or error code is generated
# Entry points for FOUR and FIVE params( 2 addresses + optional byte)
# Both params can be plain or complex address types,complex marked by bit 15.
# four param sets flag for pass/fail, 
# five param has error code as fifth byte and set if fails
#######################################################

  Compare:
7964: 91,08,2b            orb   R2b,8            Error_detected = 1;               # mark as 4 bytes
7967: 2e,55               scall 77be             GetbytesR1a(4);                   # copy 4 bytes from caller to R1A onwards
7969: 04                  #args  
796a: 20,03               sjmp  796f             goto 796f;

# entry point for FIVE params

  CompareTC:
796c: 2e,50               scall 77be             GetbytesR1a(5);
796e: 05                  #args  
796f: 28,1a               scall 798b             GetAddr(1a);                      # make R1a,b into true address
7971: 1a,00               #args  
7973: 28,16               scall 798b             GetAddr(1c);                      # make R1c,d into true address
7975: 1c,00               #args  
7977: a2,1a,42            ldw   R42,[R1a]        R42 = [R1a];
797a: 8a,1c,42            cmpw  R42,[R1c]        
797d: d1,08               jleu  7987             if ((uns) R42 <= [R1c]) goto 7987; # Jump if PASSED (no codes)
797f: 3b,2b,08            jb    B3,R2b,798a      if (Error_detected == 1) return;   # jump if 4 params
7982: b0,1e,1a            ldb   R1a,R1e          R1a = R1e;                        # 5 params, error code
7985: 2a,2b               scall 7bb2             SaveTCode();                      # save errorno in (342) TROUBLE CODE Table
7987: 71,f7,2b            an2b  R2b,f7           Error_detected = 0; }             # clear error marker
798a: f0                  ret                    return;


#######################################################
# Decode complex addresses into their TRUE addresses (plain ones OK too)
# address decoded back to input register (via R16, R42 )
# Address is encoded as 1 bit=flag, 3 bits=base reg/2, 12 bits offset from reg
# NOTE encoding is HALF reg value (because of divide by 8)
# return value is then a POINTER (as a plain address) 
#######################################################

  GetAddr:
798b: a1,3e,00,16         ldw   R16,3e           R16 = 3e;
798f: 2e,31               scall 77c2             GetbytesR16(2);                   # get address (from args in caller)
7991: 02                  #args  
7992: a2,3e,42            ldw   R42,[R3e]        R42 = [R3e];                      # get data from address
7995: 37,43,14            jnb   B7,R43,79ac      if (B7_R43 == 0) return;          # address not encoded - return unchanged
7998: ac,43,3a            ldzbw R3a,R43          R3a = (uns)R43;                   # Hi byte of value
799b: 71,0f,43            an2b  R43,f            R43 &= f;                         # Clear top nibble.  R42 = Offset address
799e: 71,70,3a            an2b  R3a,70           R3a &= 70;                        # Clear bottom nibble and flag
79a1: 08,03,3a            shrw  R3a,3            R3a /= 8;                         # Rbase register (0-14 times 2 effectively)
79a4: 67,3b,f0,00,42      ad2w  R42,[R3a+f0]     R42 += [R3a+f0];                  # R42 += Rbase register (as pointer)
79a9: c2,3e,42            stw   R42,[R3e]        [R3e] = R42; }                    # update input pointer to new address
79ac: f0                  ret                    return;

# 716E Self test jump Table entry


  Sub68:
79ad: b3,78,f3,3a         ldb   R3a,[R78+f3]     R3a = V_FPMFLG;
79b1: e0,3a,03            djnz  R3a,79b7         R3a--;
                                                 if (R3a != 0) goto 79b7;
79b4: 30,c4,04            jnb   B0,Rc4,79bb      if (Code_87 == 1)  {
79b7: 17,38               incb  R38              R38++;
79b9: 27,10               sjmp  78cb             goto 78cb; }                      # zero 1CA timer, incr R38 self test index, and return

79bb: 91,01,d9            orb   Rd9,1            Vip_fp_override = 1;
79be: 91,80,46            orb   R46,80           Pump = 1;                         # LSO output line 7 ON (Fuel Pump)
79c1: ef,77,04            call  7e3b             GetWord(V_fpmdly);
79c4: 74,90               #args  
79c6: 3c,df,03            jb    B4,Rdf,79cc      if (FPM == 0)  {
79c9: 29,e3               scall 7bae             SaveTCode1(96);                   # E96 - Themactor Air System inoperative
79cb: 96                  #args                  }
79cc: 26,fd               sjmp  78cb             goto 78cb;

# 716E Self test jump Table entry

  Sub69:
79ce: ef,6a,04            call  7e3b             GetWord(V_fpmdly);
79d1: 74,90               #args  
79d3: 34,df,03            jnb   B4,Rdf,79d9      if (FPM == 1)  {
79d6: 29,d6               scall 7bae             SaveTCode1(95);                   # E95 - Fuel Pump secondary circuit failure
79d8: 95                  #args                  }
79d9: 26,f0               sjmp  78cb             goto 78cb;                        # zero 1CA timer, incr R38 self test index, and return

79db: 71,df,e6            an2b  Re6,df           Vlfnon = 0;
79de: a1,f9,79,34         ldw   R34,79f9         R34 = 79f9;                       # 'return' address
79e2: 26,e7               sjmp  78cb             goto 78cb;                        # zero 1CA timer, incr R38 self test index, and return

# 716E Self test jump Table entry
# where does R34 come from?

  Sub70:
79e4: 3d,e6,02            jb    B5,Re6,79e9      if (Vlfnon == 0)  {
79e7: 29,06               scall 7aef             Sub74(); }                        # force all LSO and HSO otputs off and STO on
79e9: b1,20,42            ldb   R42,20           R42 = 20;
79ec: c7,73,a2,00,42      stb   R42,[R72+a2]     EGRPER = R42;
79f1: c7,73,a1,00,42      stb   R42,[R72+a1]     EGRCNT = R42;
79f6: c8,34               push  R34              push(R34);                        # address to jump to ?
79f8: f0                  ret                    return;

79f9: b3,fe,0b,3a         ldb   R3a,[Rfe+b]      R3a = THRMHP;                     # 9E65 thermactor present switch = 1.0
79fd: e0,3a,0c            djnz  R3a,7a0c         R3a--;
                                                 if (R3a != 0) goto 7a0c;
# Idle Air Control Output Circuit Check, E81, limit, mask, - Idle Air Control
7a00: 28,74               scall 7a76             Test_IO(f681,4710);
7a02: 81,f6,10,47         #args  
# Air Management 1 Output Circuit Check, E82, limit, mask, - Air Management 1
7a06: 28,6e               scall 7a76             Test_IO(f882,4708);
7a08: 82,f8,08,47         #args                  }
# Canister purge Output Circuit Check, E85, limit, mask, # 12D Canister Purge on time
7a0c: b1,14,42            ldb   R42,14           R42 = 14;
7a0f: c7,72,ae,42         stb   R42,[R72+ae]     Purge_period = R42;
7a13: 28,7c               scall 7a91             OpenCChk(fe85,Purg_on_time);      # Z_VPRG "disabled" replaces this instruction with
7a15: 85,fe,2d,01         #args                                                    #   20, 04  sjmp 7a19
# Fuel Pump Output Circuit Check, E87, limit, mask, IO = Fuel Pump
7a19: 28,5b               scall 7a76             Test_IO(New_irqs,4680);
7a1b: 87,00,80,46         #args  
7a1f: 98,30,00            cmpb  R0,R30           
7a22: df,0d               je    7a31             if (0 != R30)  {
7a24: b3,31,41,03,3a      ldb   R3a,[R30+341]    R3a = [R30+341];
7a29: 99,87,3a            cmpb  R3a,87           
7a2c: d7,03               jne   7a31             if (R3a = 87)  {
7a2e: 91,01,c4            orb   Rc4,1            Code_87 = 1; } }
7a31: 3e,d9,06            jb    B6,Rd9,7a3a      if (Vegrbp == 0)  {
7a34: 28,5b               scall 7a91             OpenCChk(fc84,d3);                # check ? E84
7a36: 84,fc,d3,00         #args                  }
7a3a: 91,20,e6            orb   Re6,20           Vlfnon = 1;
7a3d: b3,f6,74,42         ldb   R42,[Rf6+74]     R42 = EDFHP;
7a41: e0,42,11            djnz  R42,7a55         R42--;
                                                 if (R42 != 0) goto 7a55;
7a44: c7,72,4a,00         stb   R0,[R72+4a]      VIPTMR = 0;
# Electro Drive Fan Output Circuit Check, E88, limit.mask = ElectroDriveFan
7a48: 28,2c               scall 7a76             Test_IO(EM,4720);
7a4a: 88,02,20,47         #args  
7a4e: ef,ea,03            call  7e3b             GetWord(Vdledf);
7a51: bd,90               #args  
7a53: 28,9a               scall 7aef             Sub74(); }
7a55: b3,f6,75,42         ldb   R42,[Rf6+75]     R42 = HEDFHP;
7a59: e0,42,0f            djnz  R42,7a6b         R42--;
                                                 if (R42 != 0) goto 7a6b;
7a5c: c7,72,4a,00         stb   R0,[R72+4a]      VIPTMR = 0;
# Hi Fan Output Circuit Check, E83, limit,mask, R47 bit 6 - HiFan output line
7a60: 28,14               scall 7a76             Test_IO(fa83,4740);
7a62: 83,fa,40,47         #args  
7a66: ef,d2,03            call  7e3b             GetWord(Vdlhed);
7a69: be,90               #args                  }
7a6b: 71,df,e6            an2b  Re6,df           Vlfnon = 0;
7a6e: 28,7f               scall 7aef             Sub74();                          # call set HSO Time Hold = Master IO Timer Lo + # 0003
7a70: 91,10,d9            orb   Rd9,10           Kam_codes = 1;
7a73: e7,03,06            jump  8079             goto Sub99;                       # clr 1CA timer, incr R38 self test index, set bit flag and return


#################################################################
# Four data bytes follow calls to this function (R1A,1B,1C,1D)
# R1A - is Trouble Code if there is an error
# R1B - ROM loc for limit 8F86 + this offset (word)
# R1C - parameter flag - mask to select the device (Fan, CANP, FuelPump etc)
# R1D - pointer to SFR flag byte usually R46 or 47 for output lines
# The OCC AD channel must be a supply voltage to the actuators
# This performs 'circuit' tests
# Measure any variation in voltage when the selected output line is switched
#################################################################

  Test_IO:
7a76: 28,29               scall 7aa1             Sub71();                          # load params from stack & OCC base line test of circuit
7a78: ac,1d,20            ldzbw R20,R1d          R20 = (uns)R1d;                   # fourth param byte to word
# toggle output line for this device
7a7b: b2,20,1d            ldb   R1d,[R20]        R1d = [R20];                      # load contents of SFR
7a7e: 94,1c,1d            xorb  R1d,R1c          R1d ^= R1c;                       # mask contents with third param
7a81: c6,20,1d            stb   R1d,[R20]        [R20] = R1d;                      # store back in [SFR]
7a84: 28,37               scall 7abd             Sub72();                          # read OCC and compare to level before - set Trouble code if out of range
7a86: 3d,e6,06            jb    B5,Re6,7a8f      if (Vlfnon == 0)  {
# retoggle output line for this same device
7a89: 94,1c,1d            xorb  R1d,R1c          R1d ^= R1c;                       # xor 3rd and fourth param (if calls did not change them)
7a8c: c6,20,1d            stb   R1d,[R20]        [R20] = R1d; }                    # store fourth param? to [SFR]
7a8f: 20,0d               sjmp  7a9e             goto 7a9e;                        # return to callers caller


################################################################
# Output Circuit Check ?
# Four data byte follow calls to this function
# (via 7aa1)
################################################################

  OpenCChk:
7a91: 28,0e               scall 7aa1             Sub71();                          # load params from stack & OCC base line test of circuit
7a93: b1,80,42            ldb   R42,80           R42 = 80;
7a96: c6,1c,42            stb   R42,[R1c]        [R1c] = R42;
7a99: 28,22               scall 7abd             Sub72();                          # read OCC and compre to level before - set Trouble code if out of range
7a9b: c6,1c,00            stb   R0,[R1c]         [R1c] = 0;
7a9e: cc,34               pop   R34              R34 = pop();
7aa0: f0                  ret                    return;


################################################################
# Read reference base level OCC AD channel for the test circuit line
# Called from Test_IO, OpenCChk
################################################################

  Sub71:
7aa1: 28,33               scall 7ad6             Sub73();                          # Repeatedly read AD channels 2.4mS
7aa3: cc,1e               pop   R1e              R1e = pop();                      # back up stack by one call
7aa5: 2d,17               scall 77be             GetbytesR1a(4);                   # Get 4 bytes from Grandcaller into R1A
7aa7: 04                  #args  
7aa8: c8,1e               push  R1e              push(R1e);                        # restore stack
7aaa: bc,1b,1e            ldsbw R1e,R1b          R1e = (int)R1b;                   # circuit test param 2 - ROM location selector
7aad: 65,2c,01,1e         ad2w  R1e,12c          R1e += PURGDC;
7ab1: 64,f2,1e            ad2w  R1e,Rf2          R1e += Rf2;                       # R1E + ROM 8E5A + 12C = 8F86 + R1E
7ab4: a3,72,8e,16         ldw   R16,[R72+8e]     R16 = IOCC;                       # 10E - OCC - Output Circuit Check AD value
7ab8: c3,72,5e,16         stw   R16,[R72+5e]     Occsav = R16;                     # 1DE - OCC reference level save value
7abc: f0                  ret                    return;


###############################################################
# Compare to the reference OCC level
# Read the switched OCC level for the test circuit line
# Called from Test_IO, OpenCChk
###############################################################

  Sub72:
7abd: 28,17               scall 7ad6             Sub73();                          # Repeatedly read AD channels for 5161 IOtimes
7abf: a3,72,5e,16         ldw   R16,[R72+5e]     R16 = Occsav;                     # 1DE - OCC reference level save value
7ac3: 6b,72,8e,16         sb2w  R16,[R72+8e]     R16 -= IOCC;                      # 10E - OCC - Output Circuit Check AD value - difference
7ac7: db,02               jc    7acb             if (R16 > 0)  {                   # jmp if positive
7ac9: 03,16               negw  R16              R16 = -R16; }                     # ABS OCC value
7acb: 8a,1e,16            cmpw  R16,[R1e]                                          # limit for this circuit
7ace: db,03               jgeu  7ad3             if ((uns) R16 >= [R1e]) goto 7ad3; # jmp if OCC >= ROM Limit - GOOD
7ad0: e7,32,04            jump  7f05             goto 7f05;                        # Post Trouble Code (in R1a) - open circuit error for X
7ad3: 11,1a               clrb  R1a              R1a = 0;                          # clr trouble code
7ad5: f0                  ret                    return;


###########################################################
# Repeatedly read AD channels for 5161 IO times (12.4 mS)
###########################################################

  Sub73:
7ad6: c0,3c,06            stw   R6,R3c           R3c = IO_Timer;                   # read start time
7ad9: 48,3c,06,3e         sb3w  R3e,R6,R3c       R3e = IO_Timer - R3c;             # = time passed
7add: 89,61,51,3e         cmpw  R3e,5161                                           # loop until 5161 IO times have passed
7ae1: db,0b               jgeu  7aee             if ((uns) R3e >= 5161) return;
7ae3: ef,8f,f5            call  7075             Save_diag_vals();                 # Save diagnostic testing registers
7ae6: ef,45,a7            call  222e             Read_AD();                        # read all the AD channels 
7ae9: ef,64,f5            call  7050             Get_diag_vals();                  # reload diagnostic testing registers
7aec: 27,eb               sjmp  7ad9             goto 7ad9; }

7aee: f0                  ret                    return;


########################################################
# This function forces all LSO lines and BiDir lines OFF
# sets Fan=1 (b5 R47) but clears rest of R46 and 47 and increments HSIO TIME 
# some kind of reset function ?
########################################################

  Sub74:
7aef: a1,00,20,46         ldw   R46,2000         IO_Port_State = 2000;             # set Fan=1 (b5 R47) 
7af3: 45,03,00,06,0e      ad3w  Re,R6,3          HSO_Time = IO_Timer + 3;
7af8: 01,d2               clrw  Rd2              Egrdc_w = 0;
7afa: 01,b8               clrw  Rb8              ISCDTY = 0;
7afc: c7,72,ac,00         stb   R0,[R72+ac]      PURGDC = 0;
7b00: f0                  ret                    return;


# 716E Self test jump Table entry

  Sub75:
7b01: 3b,d6,08            jb    B3,Rd6,7b0c      if (Sto_working == 0)  {
7b04: 17,38               incb  R38              R38++;                            # incr self test index
7b06: 2f,e7               scall 7aef             Sub74();                          # Reset ?
7b08: 85,00,00,46         xrw   R46,0            IO_Port_State ^= 0; }
7b0c: c3,72,42,00         stw   R0,[R72+42]      OUTTMR = 0;
7b10: 71,f7,d8            an2b  Rd8,f7           Reqflg = 0;
7b13: 71,cf,e6            an2b  Re6,cf           Vhfnon = 0;
                                                 Vlfnon = 0;
7b16: c7,72,4a,00         stb   R0,[R72+4a]      VIPTMR = 0;
7b1a: f0                  ret                    return;

########################################################


  Sub76:
7b1b: ef,07,f8            call  7325             Sub66();
7b1e: 3b,d6,f9            jb    B3,Rd6,7b1a      if (Sto_working == 1) goto 7b1a;
7b21: a3,78,e4,1c         ldw   R1c,[R78+e4]     R1c = Vtap5;
7b25: 8b,72,a2,1c         cmpw  R1c,[R72+a2]                                       # compare to raw TP
7b29: db,3b               jgeu  7b66             if (R1c > ITP)  {
7b2b: 91,08,d8            orb   Rd8,8            Reqflg = 1;
7b2e: 3d,46,35            jb    B5,R46,7b66      if (Sto_state == 0)  {            # if LSO output line 5 (STO) is ON (MIL)
7b31: b3,f6,75,42         ldb   R42,[Rf6+75]     R42 = HEDFHP;                     # fan high speed enable
7b35: e0,42,17            djnz  R42,7b4f         R42--;
                                                 if (R42 != 0) goto 7b4f;
7b38: 9b,78,40,18         cmpb  R18,[R78+40]     
7b3c: d1,11               jleu  7b4f             if ((uns) R18 > Vhfntm )  {
7b3e: 3c,e6,0c            jb    B4,Re6,7b4d      if (Vhfnon == 0)  {
7b41: 71,df,e6            an2b  Re6,df           Vlfnon = 0;
7b44: 91,10,e6            orb   Re6,10           Vhfnon = 1;
7b47: ad,05,d4            ldzbw Rd4,5            Vip_code = (uns)5;
7b4a: ef,2a,f4            call  6f77             Sub43(); }
7b4d: 20,16               sjmp  7b65             return; } }                       # return

7b4f: b3,f6,74,42         ldb   R42,[Rf6+74]     R42 = EDFHP;                  # fan control enable
7b53: e0,42,10            djnz  R42,7b66         R42--;
                                                 if (R42 != 0) goto 7b66;
7b56: 9b,78,3f,18         cmpb  R18,[R78+3f]     
7b5a: d1,09               jleu  7b65             if ((uns) R18 <= Vlfntm) return;
7b5c: 3d,e6,06            jb    B5,Re6,7b65      if (Vlfnon == 1) return;
7b5f: 91,20,e6            orb   Re6,20           Vlfnon = 1;
7b62: ef,0f,f4            call  6f74             Sub42();
7b65: f0                  ret                    return; } } }

7b66: 33,d8,37            jnb   B3,Rd8,7ba0      if (Reqflg == 0) goto 7ba0;
7b69: a3,78,e6,1c         ldw   R1c,[R78+e6]     R1c = Vtap6;
7b6d: 8b,72,a2,1c         cmpw  R1c,[R72+a2]     
7b71: d1,2d               jleu  7ba0             if ((uns) R1c <= ITP) goto 7ba0;
7b73: 35,46,02            jnb   B5,R46,7b78      if (Sto_state == 0) goto 7b78;
7b76: 27,8e               sjmp  7b06             goto 7b06;

7b78: 85,71,1a,46         xrw   R46,1a71         SCVAC ^= 1;
                                                 SCVNT ^= 1;
                                                 Sto_state ^= 1;
                                                 WOT_AC ^= 1;
                                                 Canp ^= 1;
                                                 TAB ^= 1;
                                                 TAD ^= 1;
7b7c: 35,e6,03            jnb   B5,Re6,7b82      if (Vlfnon == 1)  {
7b7f: 95,20,47            xorb  R47,20           Fan ^= 1; }
7b82: 34,e6,03            jnb   B4,Re6,7b88      if (Vhfnon == 1)  {
7b85: 95,40,47            xorb  R47,40           Hi_fan ^= 1; }
7b88: a1,00,80,42         ldw   R42,8000         R42 = 8000;
7b8c: c0,d2,42            stw   R42,Rd2          Egrdc_w = R42;
7b8f: c0,b8,42            stw   R42,Rb8          ISCDTY = R42;
7b92: b1,10,1e            ldb   R1e,10           R1e = 10;
7b95: 45,03,00,06,0e      ad3w  Re,R6,3          HSO_Time = IO_Timer + 3;
7b9a: c7,72,ac,43         stb   R43,[R72+ac]     PURGDC = R43;                     # = 80
7b9e: 27,6c               sjmp  7b0c             goto 7b0c;                        # exit w/o odd h/w instruction

7ba0: a3,72,42,1a         ldw   R1a,[R72+42]     R1a = OUTTMR;                     # 1C2 timer?
7ba4: 89,58,02,1a         cmpw  R1a,258          
7ba8: d1,02               jleu  7bac             if ((uns) R1a <= 258) goto 7bac;
7baa: 27,5a               sjmp  7b06             goto 7b06;                        # exit

7bac: 27,68               sjmp  7b16             goto 7b16;


########################################################
# save R1A in TROUBLE CODE Table (at 342)
# save range error code up to index 19
# trouble code set in R1A (7bb2) or via inline param (7bae)
########################################################

  SaveTCode1:
7bae: ef,0d,fc            call  77be             GetbytesR1a(1);                   # Get 1 byte from caller to R1A
7bb1: 01                  #args  

  SaveTCode:
7bb2: 89,13,00,30         cmpw  R30,13                                             # 19 max error code positions in Table
7bb6: db,07               jgeu  7bbf             if ((uns) R30 >= 13) return;
7bb8: c7,31,42,03,1a      stb   R1a,[R30+342]    [R30+Serv_code_tab] = R1a;        # 342 is base of Hard Trouble Code Error Table
7bbd: 07,30               incw  R30              R30++; }
7bbf: f0                  ret                    return;


###############################################################
# Range test.  Error code to 342 Table
# 1st and 2nd params are AD value to check
# 3rd and 4th params are [encoded] value limit low
# 5th and 6th params are [encoded] value limit high
# 7th param is trouble code
# params are placed in R1A/1B/1C/1D/1E/1F/20
###############################################################

  ChkRngeTC:
7bc0: ef,fb,fb            call  77be             GetbytesR1a(7);                   # get 7 bytes to R1A - R20
7bc3: 07                  #args                                                    # copy this many bytes to R1A on
7bc4: 2d,c5               scall 798b             GetAddr(1c);                      # decode R1c value if high bit set
7bc6: 1c,00               #args  
7bc8: 2d,c1               scall 798b             GetAddr(1e);                      # decode R1e value if high bit set
7bca: 1e,00               #args  
7bcc: a2,1a,42            ldw   R42,[R1a]        R42 = [R1a];                      # actual AD value to check
7bcf: 8a,1c,42            cmpw  R42,[R1c]                                          # limit low
7bd2: d3,05               jltu  7bd9             if ((uns) R42 < [R1c]) goto 7bd9;
7bd4: 8a,1e,42            cmpw  R42,[R1e]                                          # limit high
7bd7: d1,06               jleu  7bdf             if ((uns) R42 <= [R1e]) return;
7bd9: b0,20,1a            ldb   R1a,R20          R1a = R20;
7bdc: ef,d3,ff            call  7bb2             SaveTCode(); }                    # save specified trouble code in Table
7bdf: f0                  ret                    return;

# 716E Self test jump Table entry


  Sub77:
7be0: ef,d1,fb            call  77b4             Reset_STO();                      # set STO off flag, set STO output low, and set STO trigger
7be3: 01,30               clrw  R30              R30 = 0;
7be5: 71,fd,2b            an2b  R2b,fd           Rvip_cyl_bal = 0;                 # clear Self Test Output trigger
7be8: 71,fe,2b            an2b  R2b,fe           Rvip_cyl_quit = 0;
7beb: c7,73,92,00,00      stb   R0,[R72+92]      IECT = 0;                      # 112 - clear ECT raw ?
7bf0: 71,ef,2b            an2b  R2b,ef           Disable_isc = 0;
7bf3: 9b,f3,8e,00,00      cmpb  R0,[Rf2+8e]      
7bf8: d7,42               jne   7c3c             if (0 == Vdisfm)  {
7bfa: 51,b8,c5,22         an3b  R22,Rc5,b8       R22 = Fmem_flags & b8;
7bfe: df,3c               je    7c3c             if (R22 != 0)  {
7c00: 2f,ac               scall 7bae             SaveTCode1(98);                   # E98 - Hard Fault present
7c02: 98                  #args  
7c03: a3,73,02,02,22      ldw   R22,[R72+202]    R22 = Fmem_monitor;
7c08: 30,22,03            jnb   B0,R22,7c0e      if (B0_R22 == 1)  {
7c0b: 2f,a1               scall 7bae             SaveTCode1(64);                   # E64 - ACT sensor grounded
7c0d: 64                  #args                  }
7c0e: 31,22,03            jnb   B1,R22,7c14      if (B1_R22 == 1)  {
7c11: 2f,9b               scall 7bae             SaveTCode1(54);                   # E54 - ACT sensor open
7c13: 54                  #args                  }
7c14: 32,22,03            jnb   B2,R22,7c1a      if (B2_R22 == 1)  {
7c17: 2f,95               scall 7bae             SaveTCode1(61);                   # E61 - ECT sensor grounded
7c19: 61                  #args                  }
7c1a: 33,22,03            jnb   B3,R22,7c20      if (B3_R22 == 1)  {
7c1d: 2f,8f               scall 7bae             SaveTCode1(51);                   # E51 - ECT sensor open
7c1f: 51                  #args                  }
7c20: 36,22,03            jnb   B6,R22,7c26      if (B6_R22 == 1)  {
7c23: 2f,89               scall 7bae             SaveTCode1(63);                   # E63 - TP sensor  below min voltage
7c25: 63                  #args                  }
7c26: 37,22,03            jnb   B7,R22,7c2c      if (B7_R22 == 1)  {
7c29: 2f,83               scall 7bae             SaveTCode1(53);                   # E53 - TP sensor  above max voltage
7c2b: 53                  #args                  }
7c2c: 31,23,03            jnb   B1,R23,7c32      if (B1_R23 == 1)  {
7c2f: 2f,7d               scall 7bae             SaveTCode1(56);                   # E56 - TPS sensor below min voltage
7c31: 56                  #args                  }
7c32: 30,23,03            jnb   B0,R23,7c38      if (B0_R23 == 1)  {
7c35: 2f,77               scall 7bae             SaveTCode1(66);                   # E66 - TPS sensor above max voltage
7c37: 66                  #args                  }
7c38: b1,22,38            ldb   R38,22           R38 = 22;
7c3b: f0                  ret                    return; } }

7c3c: a3,fe,2c,1c         ldw   R1c,[Rfe+2c]     R1c = VRLAM_1;
7c40: c3,73,8a,00,1c      stw   R1c,[R72+8a]     LAMBSE1 = R1c;                    # HEGO1 delta time initial value?
7c45: c3,73,8c,00,1c      stw   R1c,[R72+8c]     LAMBSE2 = R1c;                    # HEGO2 delta time initial value?
7c4a: a3,fe,32,3e         ldw   R3e,[Rfe+32]     R3e = VISCN;
7c4e: c3,72,6e,3e         stw   R3e,[R72+6e]     RVIPRPM = R3e;
7c52: 71,bf,4f            an2b  R4f,bf           KNOCK_ENABLED = 0;                # clr Knock Enabled
7c55: 01,9e               clrw  R9e              EFTR = 0;
7c57: a1,00,01,42         ldw   R42,100          R42 = TPBAR  ;
7c5b: c3,73,34,06,42      stw   R42,[R72+634]    KAMRF1 = R42;
7c60: c3,73,36,06,42      stw   R42,[R72+636]    KAMRF2 = R42;
7c65: a3,78,d0,c2         ldw   Rc2,[R78+d0]     SAF = Vipspk;
7c69: 01,d2               clrw  Rd2              Egrdc_w = 0;
7c6b: 91,40,46            orb   R46,40           WOT_AC = 1;                       # LSO output line 6 ON (Wide Open THrottle A/C cutout)
7c6e: 71,f7,46            an2b  R46,f7           Isc = 0;                          # LSO output line 3 OFF (Idle Speed Control)
7c71: 71,ef,47            an2b  R47,ef           TAD = 0;                          # R47 bit 4 OFF (Air management2)
7c74: c7,72,ac,00         stb   R0,[R72+ac]      PURGDC = 0;                       # 12C
7c78: 91,03,d7            orb   Rd7,3            Code_75 = 1;
                                                 Code_74 = 1;                      # DOO trouble codes ?
7c7b: 71,f3,e6            an2b  Re6,f3           Powoff = 0;
                                                 Powon = 0;
7c7e: ef,98,f6            call  7319             Sub65();
7c81: e7,8a,02            jump  7f0e             goto 7f0e;

# Diagnostic Proc Table A

  Sub78:
7c84: 29,b5               scall 7e3b             GetWord(9e8a);
7c86: 30,f0               #args  
7c88: a3,fe,32,32         ldw   R32,[Rfe+32]     R32 = VISCN;
7c8c: 09,05,32            shlw  R32,5            R32 *= 20;
7c8f: 6b,72,88,32         sb2w  R32,[R72+88]     R32 -= NBAR;                 # - filtered RPM
7c93: d6,02               jge   7c97             if (R32 < 0)  {
7c95: 03,32               negw  R32              R32 = -R32; }
7c97: 2c,d3               scall 796c             CompareTC(32,ISUBND,Tmr_OVF_cnt);   # E12 - Cannot control RPM during high RPM test
7c99: 32,00,34,f0,12      #args  
7c9e: 91,10,2b            orb   R2b,10           Disable_isc = 1;
7ca1: 22,6b               sjmp  7f0e             goto 7f0e;

  Sub79:
7ca3: 2f,1b               scall 7bc0             ChkRngeTC(IECT,Viect4,Viect3,21); # E21 - ECT out of range during self test
7ca5: 12,01,fc,90,fa,90,21 #args  
7cac: 2f,12               scall 7bc0             ChkRngeTC(IMAF,Vmafr1,Vmafr2,Flags_26); # E26 - MAF ? sensor out of range during self test
7cae: 24,01,0a,91,0c,91,26 #args  
7cb5: 2f,09               scall 7bc0             ChkRngeTC(ITP,Vtap3,Vtap4,23); # E23 - TP sensor out of range during self test
7cb7: 22,01,60,90,62,90,23 #args  
7cbe: 2f,00               scall 7bc0             ChkRngeTC(IACT,Viact4,Viact3,Flags_24); # E24 - ACT sensor out of range during self test
7cc0: 14,01,f4,90,f2,90,24 #args  
7cc7: 22,45               sjmp  7f0e             goto 7f0e;

# Diagnostic Proc Table A

  Sub80:
7cc9: a3,72,88,42         ldw   R42,[R72+88]     R42 = NBAR;                  # filtered sensor output - in place (0108) - filtered RPM
7ccd: 8b,78,d8,42         cmpw  R42,[R78+d8]     
7cd1: db,04               jgeu  7cd7             if (R42 > Vnmin)  {
7cd3: b1,12,38            ldb   R38,12           R38 = 12;
7cd6: f0                  ret                    return; }

7cd7: 91,e0,d7            orb   Rd7,e0           Code_44_73 = 1;
                                                 Code_42_72 = 1;
                                                 Code_25_41 = 1;
7cda: 28,ff               scall 7ddb             Sub87();
7cdc: d7,03               jnz   7ce1             if (one EGO sensor)  {
7cde: 91,1c,d7            orb   Rd7,1c           Code_67_94 = 1;
                                                 Code_45_92 = 1;
                                                 Code_77_91 = 1; }
7ce1: 29,53               scall 7e36             Sub88();
7ce3: 22,29               sjmp  7f0e             goto 7f0e;

# Diagnostic Proc Table A

  Sub81:
7ce5: 37,2b,03            jnb   B7,R2b,7ceb      if (Egoste1 == 1)  {               # jump if no HEGO1 cross over voltage detected yet
7ce8: 71,bf,d7            an2b  Rd7,bf           Code_42_72 = 0; }
7ceb: 36,2b,03            jnb   B6,R2b,7cf1      if (Egoste2 == 1)  {               # jump if no HEGO2 cross over voltage detected yet
7cee: 71,f7,d7            an2b  Rd7,f7           Code_45_92 = 0; }
7cf1: 3e,d7,07            jb    B6,Rd7,7cfb      if (Code_42_72 == 0)  {
7cf4: 3b,d7,04            jb    B3,Rd7,7cfb      if (Code_45_92 == 0)  {
7cf7: 29,3d               scall 7e36             Sub88();
7cf9: 22,13               sjmp  7f0e             goto 7f0e; } }

7cfb: 28,eb               scall 7de8             Scale_time_delta2(Viplr1);
7cfd: 56,90               #args  
7cff: 29,3a               scall 7e3b             GetWord(9e88);
7d01: 2e,f0               #args  
7d03: 36,d7,03            jnb   B6,Rd7,7d09      if (Code_42_72 == 1)  {
7d06: 2e,a6               scall 7bae             SaveTCode1(42);                   #E42 - EGO sensor indicates system rich
7d08: 42                  #args                  }
7d09: 33,d7,03            jnb   B3,Rd7,7d0f      if (Code_45_92 == 1)  {
7d0c: 2e,a0               scall 7bae             SaveTCode1(TPtr);                 #E92 - Air/Fuel mixture not within Self test range
7d0e: 92                  #args                  }
7d0f: 20,b7               sjmp  7dc8             goto 7dc8;

# Diagnostic Proc Table A

  Sub82:
7d11: 3f,2b,03            jb    B7,R2b,7d17      if (Egoste1 == 0)  {               # jump if HEGO1 cross over voltage detected
7d14: 71,7f,d7            an2b  Rd7,7f           Code_25_41 = 0; }
7d17: 3e,2b,03            jb    B6,R2b,7d1d      if (Egoste2 == 0)  {               # jump if HEGO2 cross over voltage detected
7d1a: 71,ef,d7            an2b  Rd7,ef           Code_77_91 = 0; }
7d1d: 3f,d7,05            jb    B7,Rd7,7d25      if (Code_25_41 == 0)  {
7d20: 3c,d7,02            jb    B4,Rd7,7d25      if (Code_77_91 == 1) goto 7d25;
7d23: 21,e9               sjmp  7f0e             goto 7f0e; }

7d25: 28,bc               scall 7de3             Scale_Time_delta(Viprr1);         # 'filter' to scale time delta (ROM range limited to 10A)
7d27: 54,90               #args  
7d29: a3,73,8a,00,42      ldw   R42,[R72+8a]     R42 = LAMBSE1;
7d2e: 8b,fe,28,42         cmpw  R42,[Rfe+28]     
7d32: d1,04               jleu  7d38             if ((uns) R42 > REQV )  {
7d34: 15,38               decb  R38              R38--;
7d36: 21,d6               sjmp  7f0e             goto 7f0e; }

7d38: 29,01               scall 7e3b             GetWord(942f);
7d3a: 87,b0               #args  
7d3c: 37,d7,03            jnb   B7,Rd7,7d42      if (Code_25_41 == 1)  {
7d3f: 2e,6d               scall 7bae             SaveTCode1(41);                   #E41 - EGO sensor indicates system lean
7d41: 41                  #args                  }
7d42: 34,d7,03            jnb   B4,Rd7,7d48      if (Code_77_91 == 1)  {
7d45: 2e,67               scall 7bae             SaveTCode1(91);                   #E91 - Air/Fuel mixture not with Self test range
7d47: 91                  #args                  }
7d48: 20,7e               sjmp  7dc8             goto 7dc8;
# Diagnostic Proc Table A

  Sub83:
7d4a: b3,78,cd,1a         ldb   R1a,[R78+cd]     R1a = Vairfl;
7d4e: 30,1a,77            jnb   B0,R1a,7dc8      if (B0_R1a == 0) goto 7dc8;
7d51: b3,fe,0b,1a         ldb   R1a,[Rfe+b]      R1a = THRMHP;                     # Thermactor present?
7d55: 30,1a,70            jnb   B0,R1a,7dc8      if (B0_R1a == 0) goto 7dc8;
7d58: 28,89               scall 7de3             Scale_Time_delta(Viprr1);         # 'filter' to scale time delta (ROM range limited to 10A)
7d5a: 54,90               #args  
7d5c: 28,dd               scall 7e3b             GetWord(VDLY1);
7d5e: 56,91               #args  
7d60: 91,08,47            orb   R47,8            TAB = 1;                          # (Air management1)
7d63: 91,10,47            orb   R47,10           TAD = 1;                          # (Air management2)
7d66: 21,a6               sjmp  7f0e             goto 7f0e;
# Diagnostic Proc Table A

  Sub84:
7d68: 37,2b,03            jnb   B7,R2b,7d6e      if (Egoste1 == 1)  {              # jump if no HEGO1 cross over voltage detected yet
7d6b: 71,df,d7            an2b  Rd7,df           Code_44_73 = 0; }
7d6e: 36,2b,03            jnb   B6,R2b,7d74      if (Egoste2 == 1)  {              # jump if no HEGO2 cross over voltage detected yet
7d71: 71,fb,d7            an2b  Rd7,fb           Code_67_94 = 0; }
7d74: 3d,d7,03            jb    B5,Rd7,7d7a      if (Code_44_73 == 1) goto 7d7a;
7d77: 32,d7,12            jnb   B2,Rd7,7d8c      if (Code_67_94 == 1)  {
7d7a: 28,bf               scall 7e3b             GetWord(Viptm2);
7d7c: 58,91               #args  
7d7e: 32,d7,03            jnb   B2,Rd7,7d84      if (Code_67_94 == 1)  {
7d81: 2e,2b               scall 7bae             SaveTCode1(94);                   #E94 Thermactor Air System inoperative
7d83: 94                  #args                  }
7d84: 35,d7,03            jnb   B5,Rd7,7d8a      if (Code_44_73 == 1)  {
7d87: 2e,25               scall 7bae             SaveTCode1(44);                   #E44 Thermactor Air System inoperative
7d89: 44                  #args                  }
7d8a: 20,36               sjmp  7dc2             goto 7dc2; }

7d8c: 71,ef,47            an2b  R47,ef           TAD = 0;
7d8f: 21,7d               sjmp  7f0e             goto 7f0e;
# Diagnostic Proc Table A

  Sub85:
7d91: 28,48               scall 7ddb             Sub87();
7d93: d7,03               jnz   7d98             if (one EGO sensor) goto 7d98;
7d95: 36,2b,0a            jnb   B6,R2b,7da2      if (Egoste2 == 1)  {               # HEGO2 cross over voltage detected
#
7d98: 37,2b,07            jnb   B7,R2b,7da2      if (Egoste1 == 1)  {               # HEGO1 cross over voltage detected
7d9b: 28,9e               scall 7e3b             GetWord(VATMR2);
7d9d: 59,91               #args  
7d9f: 2e,0d               scall 7bae             SaveTCode1(45);                   #E45 Thermactor air upstream during Self test
7da1: 45                  #args                  } }
7da2: 71,f7,47            an2b  R47,f7           TAB = 0;                          # R47 bit 3 OFF (Air management1)
7da5: 91,10,47            orb   R47,10           TAD = 1;                          # R47 bit 4 ON (Air management2)
7da8: 21,64               sjmp  7f0e             goto 7f0e;
# Diagnostic Proc Table A

  Sub86:
7daa: b3,78,ce,1a         ldb   R1a,[R78+ce]     R1a = Vtabfl;
7dae: 30,1a,11            jnb   B0,R1a,7dc2      if (B0_R1a == 1)  {
7db1: 28,88               scall 7e3b             GetWord(VDLY2);
7db3: 57,91               #args  
7db5: 28,24               scall 7ddb             Sub87();
7db7: d7,03               jnz   7dbc             if (one EGO sensor) goto 7dbc;
7db9: 36,2b,06            jnb   B6,R2b,7dc2      if (Egoste2 == 1)  {               # HEGO2 cross over voltage detected
#
7dbc: 37,2b,03            jnb   B7,R2b,7dc2      if (Egoste1 == 1)  {               # HEGO1 cross over voltage detected
7dbf: 2d,ed               scall 7bae             SaveTCode1(IO_Port_State);         # E46 Thermactor air not by-passed during Self test
7dc1: 46                  #args                  } } }
7dc2: 71,ef,47            an2b  R47,ef           TAD = 0;                           # Air management2
7dc5: 71,f7,47            an2b  R47,f7           TAB = 0;                           # Air management1
7dc8: a3,fe,2c,1c         ldw   R1c,[Rfe+2c]     R1c = VRLAM_1;
7dcc: c3,73,8a,00,1c      stw   R1c,[R72+8a]     LAMBSE1 = R1c;
7dd1: c3,73,8c,00,1c      stw   R1c,[R72+8c]     LAMBSE2 = R1c;
7dd6: b1,0a,38            ldb   R38,a            R38 = a;
7dd9: 21,33               sjmp  7f0e             goto 7f0e;

#################################
# Check # of EGOs
# Return:
#  Z flag = clear if 1, set if 2
#################################

  Sub87:
7ddb: b3,fe,16,42         ldb   R42,[Rfe+16]     R42 = NUMEGO;                   # no of HEGOs
7ddf: 99,02,42            cmpb  R42,2                                            
7de2: f0                  ret                    return;


########################################################
# Very odd routine
# Word behind caller is 'filter' to scale time delta (ROM range limited to 10A)
########################################################

  Scale_Time_delta:
7de3: 91,10,28            orb   R28,10           Ramp_rich = 1;
7de6: 20,03               sjmp  7deb             goto 7deb;

  Scale_time_delta2:
7de8: 71,ef,28            an2b  R28,ef           Ramp_rich = 0;
7deb: ef,d0,f9            call  77be             GetbytesR1a(2);                   # copy byte following call count bytes from stackptr2 to 001A
7dee: 02                  #args                                                    # copy this many bytes to 001A from this callers return address
7def: ef,99,fb            call  798b             GetAddr(1a);                      # mangle the value at 001A into ROM if high bit set
7df2: 1a,00               #args  
7df4: 4b,72,60,06,34      sb3w  R34,R6,[R72+60]  R34 = IO_Timer - Viplatm;         # 00E0 IO time since last visit to this proc
7df9: 6d,44,28,34         ml2w  R34,2844         R37:R34 = R35:R34 * 0x2844;       # time since ? * ?
7dfd: 4e,1a,36,3c         ml3w  R3c,R36,[R1a]    R3f:R3c = R37:R36 * [R1a];        # R36 is Hi 16 bits of prior result times "filter"
7e01: 34,28,16            jnb   B4,R28,7e1a      if (Ramp_rich == 0) goto 7e1a;
7e04: a3,73,8a,00,1c      ldw   R1c,[R72+8a]     R1c = LAMBSE1;                    # 10A ? MAP/BP ? time?
7e09: 68,3e,1c            sb2w  R1c,R3e          R1c -= R3e;                       # time delta * # 2844 * filterFactor
7e0c: d1,06               jleu  7e14             if ((uns) R1c <= 0) goto 7e14;
7e0e: 8b,fe,28,1c         cmpw  R1c,[Rfe+28]                                       # 9E82 - 6000
7e12: db,18               jgeu  7e2c             if (R1c > REQV)  {
7e14: a3,fe,28,1c         ldw   R1c,[Rfe+28]     R1c = REQV;                       # 9E82 - 6000 - clamp if too low
7e18: 20,12               sjmp  7e2c             goto 7e2c;

7e1a: 47,73,8a,00,3e,1c   ad3w  R1c,R3e,[R72+8a] R1c = R3e + LAMBSE1;              # 10A Table ?
7e20: db,06               jc    7e28             if ((uns) R1c >= 0) goto 7e28;
7e22: 8b,fe,2a,1c         cmpw  R1c,[Rfe+2a]                                       # 9E84 - A666
7e26: d1,04               jleu  7e2c             if ((uns) R1c > LEQV )  {
7e28: a3,fe,2a,1c         ldw   R1c,[Rfe+2a]     R1c = LEQV; } }                 # 9E84 - A666 - clamp if too high
7e2c: c3,73,8a,00,1c      stw   R1c,[R72+8a]     LAMBSE1 = R1c;                    # 10A
7e31: c3,73,8c,00,1c      stw   R1c,[R72+8c]     LAMBSE2 = R1c;                    # 10C - ? store to raw KEYPWR?

  Sub88:
7e36: c3,72,60,06         stw   R6,[R72+60]      Viplatm = IO_Timer;               # store last time tweaked
7e3a: f0                  ret                    return;

########################################################
# 
#
########################################################

  GetWord:
7e3b: ef,80,f9            call  77be             GetbytesR1a(2);                   # copy byte following call count bytes from stackptr2 to 001A
7e3e: 02                  #args                                                    # copy this many bytes to 001A from this callers return address
7e3f: ef,49,fb            call  798b             GetAddr(1a);                      # mangle the value at 001A into ROM if high bit set
7e42: 1a,00               #args  
7e44: 9a,1a,18            cmpb  R18,[R1a]        
7e47: db,02               jgeu  7e4b             if ((uns) R18 >= [R1a]) return;
7e49: cc,00               pop   R0               R0 = pop(); }                     # nasty! return back two addresses
7e4b: f0                  ret                    return;

# Diagnostic proc Table A


  Sub89:
7e4c: 36,d9,04            jnb   B6,Rd9,7e53      if (Vegrbp == 1)  {
7e4f: b1,0f,38            ldb   R38,f            R38 = f;
7e52: f0                  ret                    return; }

7e53: 3e,e6,1b            jb    B6,Re6,7e71      if (Pfehp_flg == 0)  {
7e56: 28,77               scall 7ecf             ChkSensor(IEVP,VEVPLL,EVPMIN,3432); # limit Low,Limit High,Trouble Codes, Lo limit,Hi limit
7e58: 16,01,b4,90,b0,90,32,34 #args  
7e60: 34,1a,04            jnb   B4,R1a,7e67      if (B4_R1a == 1)  {
7e63: b1,0f,38            ldb   R38,f            R38 = f;
7e66: f0                  ret                    return; }

7e67: a3,72,96,42         ldw   R42,[R72+96]     R42 = IEVP;
7e6b: c3,72,70,42         stw   R42,[R72+70]     Tpsav = R42;
7e6f: 20,18               sjmp  7e89             goto 7e89; }

7e71: 28,5c               scall 7ecf             ChkSensor(Fiept,VEPTRL,Eptmin,3432);
7e73: 80,03,3c,91,34,91,32,34 #args  
7e7b: 34,1a,02            jnb   B4,R1a,7e80      if (B4_R1a == 0) goto 7e80;
7e7e: 20,47               sjmp  7ec7             goto 7ec7;

7e80: a3,73,00,02,42      ldw   R42,[R72+200]    R42 = Fiept;
7e85: c3,72,70,42         stw   R42,[R72+70]     Tpsav = R42;
7e89: b3,78,2b,d3         ldb   Rd3,[R78+2b]     Rd3 = Vdcmin;
7e8d: 20,7f               sjmp  7f0e             goto 7f0e;
# Diagnostic Proc Table D
# Diagnostic proc Table A

  Sub90:
7e8f: 3e,e6,0e            jb    B6,Re6,7ea0      if (Pfehp_flg == 0)  {
7e92: a3,72,96,42         ldw   R42,[R72+96]     R42 = IEVP;
7e96: 6b,72,70,42         sb2w  R42,[R72+70]     R42 -= Tpsav;
7e9a: 8b,78,38,42         cmpw  R42,[R78+38]     
7e9e: 20,0e               sjmp  7eae             goto 7eae; }

7ea0: a3,72,70,42         ldw   R42,[R72+70]     R42 = Tpsav;
7ea4: 6b,73,00,02,42      sb2w  R42,[R72+200]    R42 -= Fiept;
7ea9: 8b,79,c4,00,42      cmpw  R42,[R78+c4]     
7eae: d2,17               jgt   7ec7             if (R42 <= VEPTDL)  {
7eb0: 9b,78,2c,d3         cmpb  Rd3,[R78+2c]     
7eb4: db,0e               jgeu  7ec4             if (Rd3 > Vdcmax)  {
7eb6: 5f,78,2a,18,42      ml3b  R42,R18,[R78+2a] R42 = R18 * Vegrat;
7ebb: 08,03,42            shrw  R42,3            R42 /= 8;
7ebe: 57,78,2b,42,d3      ad3b  Rd3,R42,[R78+2b] Rd3 = R42 + Vdcmin;
7ec3: f0                  ret                    return; }

7ec4: 2c,e8               scall 7bae             SaveTCode1(33);                   # E33 - EGR valve (PFE and sonic) not opening
7ec6: 33                  #args                  }
7ec7: a0,00,d2            ldw   Rd2,R0           Egrdc_w = 0;
7eca: b1,0e,38            ldb   R38,e            R38 = e;
7ecd: 20,3f               sjmp  7f0e             goto 7f0e;

########################################################
# data params follow the call here
# param word 0 (1A) - sensor value EVP ?
# param word 1 (1C) - Lo
# param word 2 (1E) - Hi
# param byte 3 (20) - Trouble Code for ? voltage lower than mangle Lo
# param byte 4 (21) - Trouble Code for ? voltage lower than mangle Hi
########################################################

  ChkSensor:
7ecf: ef,ec,f8            call  77be             GetbytesR1a(8);
7ed2: 08                  #args  
7ed3: ef,b5,fa            call  798b             GetAddr(1c);
7ed6: 1c,00               #args  
7ed8: ef,b0,fa            call  798b             GetAddr(1e);
7edb: 1e,00               #args  
7edd: a2,1a,42            ldw   R42,[R1a]        R42 = [R1a];
7ee0: 01,1a               clrw  R1a              R1a = 0;
7ee2: 8a,1d,42            cmpw  R42,[R1c++]      
7ee5: db,0d               jgeu  7ef4             if ((uns) R42 >= [R1c++]) goto 7ef4;
7ee7: b1,31,1a            ldb   R1a,31           R1a = 31;                         # 35 - PFE/EPT/EVP below min voltage
7eea: 8a,1e,42            cmpw  R42,[R1e]        
7eed: d1,16               jleu  7f05             if ((uns) R42 <= [R1e]) goto 7f05;
7eef: b0,20,1a            ldb   R1a,R20          R1a = R20;
7ef2: 20,11               sjmp  7f05             goto 7f05;

7ef4: 8a,1c,42            cmpw  R42,[R1c]        
7ef7: d1,14               jleu  7f0d             if ((uns) R42 > [R1c] )  {
7ef9: b0,21,1a            ldb   R1a,R21          R1a = R21;
7efc: 8b,1e,02,42         cmpw  R42,[R1e+2]      
7f00: d3,03               jltu  7f05             if ((uns) R42 >= [R1e+2])  {
7f02: b1,35,1a            ldb   R1a,35           R1a = 35; }                       # 35 - PFE/EPT/EVP above max voltage
7f05: 51,62,2a,42         an3b  R42,R2a,62       R42 = VIP_flags & 62;             # VSCST, running, no start
7f09: df,02               je    7f0d             if (R42 == 0) return;
7f0b: 2c,a5               scall 7bb2             SaveTCode(); }                    # save R1A in 342 TROUBLE CODE Table
7f0d: f0                  ret                    return;

7f0e: c7,72,4a,00         stb   R0,[R72+4a]      VIPTMR = 0;
7f12: 17,38               incb  R38              R38++;
7f14: f0                  ret                    return;

# Diagnostic proc Table A


  Sub91:
7f15: b3,79,d4,00,42      ldb   R42,[R78+d4]     R42 = Vspten;
7f1a: e0,42,33            djnz  R42,7f50         R42--;
                                                 if (R42 != 0) goto 7f50;
7f1d: a3,79,d2,00,c2      ldw   Rc2,[R78+d2]     SAF = Vspret;
7f22: 27,ea               sjmp  7f0e             goto 7f0e;

# Diagnostic proc Table A

  Sub92:
7f24: 2f,15               scall 7e3b             GetWord(Vsptdl);
7f26: 55,91               #args  
7f28: a3,72,88,42         ldw   R42,[R72+88]     R42 = NBAR;
7f2c: c3,72,6a,42         stw   R42,[R72+6a]     Nsav = R42;
7f30: a3,79,d0,00,c2      ldw   Rc2,[R78+d0]     SAF = Vspadv;
7f35: 27,d7               sjmp  7f0e             goto 7f0e;

# Diagnostic proc Table A

  Sub93:
7f37: 2f,02               scall 7e3b             GetWord(Vsptdl);
7f39: 55,91               #args  
7f3b: a3,79,ce,00,22      ldw   R22,[R78+ce]     R22 = Vsprpm;
7f40: 67,72,6a,22         ad2w  R22,[R72+6a]     R22 += Nsav;
7f44: ef,25,fa            call  796c             CompareTC(22,NBAR,18);
7f47: 22,00,08,01,18      #args  
7f4c: a3,78,d0,c2         ldw   Rc2,[R78+d0]     SAF = Vipspk;
7f50: b1,11,38            ldb   R38,11           R38 = 11;
7f53: 27,b9               sjmp  7f0e             goto 7f0e;                        # 18 - SPOUT circuit open (grounded? )

# Diagnostic proc Table A

  Sub94:
7f55: a3,fe,3a,3e         ldw   R3e,[Rfe+3a]     R3e = NGOOSE;
7f59: c3,72,6e,3e         stw   R3e,[R72+6e]     RVIPRPM = R3e;
7f5d: 71,ef,2b            an2b  R2b,ef           Disable_isc = 0;
7f60: 27,ac               sjmp  7f0e             goto 7f0e;

# Diagnostic proc Table A

  Sub95:
7f62: 2e,d7               scall 7e3b             GetWord(9e90);
7f64: 36,f0               #args  
7f66: a3,fe,3a,32         ldw   R32,[Rfe+3a]     R32 = NGOOSE;
7f6a: 09,05,32            shlw  R32,5            R32 *= 20;
7f6d: 6b,72,88,32         sb2w  R32,[R72+88]     R32 -= NBAR;
7f71: d6,02               jge   7f75             if (R32 < 0)  {
7f73: 03,32               negw  R32              R32 = -R32; }
7f75: ef,f4,f9            call  796c             CompareTC(32,ISLBND,13);            # 13 Cannot control RPM during low RPM test
7f78: 32,00,38,f0,13      #args  
7f7d: 27,8f               sjmp  7f0e             goto 7f0e;

# Diagnostic proc Table A

  Sub96:
7f7f: 9b,78,0c,00         cmpb  R0,[R78+c]       
7f83: d7,05               jne   7f8a             if (0 == Goosw)  {
7f85: b1,16,38            ldb   R38,16           R38 = 16;
7f88: 20,ba               sjmp  8044             goto 8044; }

7f8a: 9b,f8,4a,00         cmpb  R0,[Rf8+4a]                                        # is knock sensor present
7f8e: df,1f               je    7faf             if (0 != KIHP)  {
7f90: 91,02,2c            orb   R2c,2            Kflg_local = 1;
7f93: a3,78,08,c2         ldw   Rc2,[R78+8]      SAF = Goospk;
7f97: a3,79,80,00,42      ldw   R42,[R78+80]     R42 = Vrlam2;
7f9c: c3,73,8a,00,42      stw   R42,[R72+8a]     LAMBSE1 = R42;
7fa1: c3,73,8c,00,42      stw   R42,[R72+8c]     LAMBSE2 = R42;
7fa6: af,78,0d,1a         ldzbw R1a,[R78+d]      R1a = (uns)Vkts;
7faa: c3,73,a8,00,1a      stw   R1a,[R72+a8]     Htime_delta = R1a; }
7faf: 27,5d               sjmp  7f0e             goto 7f0e;

# Diagnostic proc Table A

  Sub97:
7fb1: 2e,88               scall 7e3b             GetWord(9e89);
7fb3: 2f,f0               #args  
7fb5: 91,f0,d7            orb   Rd7,f0           Code_77_91 = 1;
                                                 Code_44_73 = 1;
                                                 Code_42_72 = 1;
                                                 Code_25_41 = 1;
7fb8: a3,72,88,1c         ldw   R1c,[R72+88]     R1c = NBAR;                       # filtered sensor output - in place (0108) - filtered RPM
7fbc: c3,72,6a,1c         stw   R1c,[R72+6a]     Nsav = R1c;
7fc0: 71,f7,d9            an2b  Rd9,f7           Vip_knock = 0;
7fc3: ef,ae,ef            call  6f74             Sub42();
7fc6: 27,46               sjmp  7f0e             goto 7f0e;
# Diagnostic proc Table A

  Sub98:
7fc8: 31,2c,0a            jnb   B1,R2c,7fd5      if (Kflg_local == 1)  {           # If knock sensor present
7fcb: 33,d9,07            jnb   B3,Rd9,7fd5      if (Vip_knock == 1)  {
7fce: 71,7f,d7            an2b  Rd7,7f           Code_25_41 = 0;
7fd1: a3,f2,50,c2         ldw   Rc2,[Rf2+50]     SAF = Vipspk; } }
#
7fd5: 4b,72,6a,ae,1c      sb3w  R1c,Rae,[R72+6a] R1c = N - Nsav;
7fda: d3,0a               jltu  7fe6             if ((uns) R1c >= 0)  {
7fdc: 8b,f3,86,00,1c      cmpw  R1c,[Rf2+86]     
7fe1: d3,03               jltu  7fe6             if ((uns) R1c >= Goosn)  {
7fe3: 71,ef,d7            an2b  Rd7,ef           Code_77_91 = 0; } }
7fe6: 4b,72,70,aa,42      sb3w  R42,Raa,[R72+70] R42 = TP - Tpsav;
7feb: d6,02               jge   7fef             if (R42 < 0)  {
7fed: 03,42               negw  R42              R42 = -R42; }
7fef: 8b,f3,8a,00,42      cmpw  R42,[Rf2+8a]     
7ff4: d3,03               jltu  7ff9             if ((uns) R42 >= Goostp)  {
7ff6: 71,cf,d7            an2b  Rd7,cf           Code_77_91 = 0;
                                                 Code_44_73 = 0; }
7ff9: 35,d7,03            jnb   B5,Rd7,7fff      if (Code_44_73 == 0) goto 7fff;
7ffc: 3c,d7,12            jb    B4,Rd7,8011      if (Code_77_91 == 0)  {
7fff: 39,d8,0f            jb    B1,Rd8,8011      if (Vf1 == 0)  {
8002: 91,02,d8            orb   Rd8,2            Vf1 = 1;
8005: b3,f3,84,00,1a      ldb   R1a,[Rf2+84]     R1a = Goosec;
800a: 79,0c,1a            sb2b  R1a,c            R1a -= c;
800d: c7,72,4a,1a         stb   R1a,[R72+4a]     VIPTMR = R1a; } }
8011: 2e,28               scall 7e3b             GetWord(Goosec);
8013: 84,90               #args  
8015: 31,2c,0e            jnb   B1,R2c,8026      if (Kflg_local == 1)  {           # If knock sensor present
8018: a3,fe,2c,42         ldw   R42,[Rfe+2c]     R42 = VRLAM_1;
801c: c3,73,8a,00,42      stw   R42,[R72+8a]     LAMBSE1 = R42;
8021: c3,73,8c,00,42      stw   R42,[R72+8c]     LAMBSE2 = R42; }
#
8026: 34,d7,06            jnb   B4,Rd7,802f      if (Code_77_91 == 1)  {
8029: ef,82,fb            call  7bae             SaveTCode1(77);                   # E77 Operator error during Dynamic Response Test or Cyl Balance Test
802c: 77                  #args  
802d: 20,11               sjmp  8040             goto 8040; }

802f: 35,d7,04            jnb   B5,Rd7,8036      if (Code_44_73 == 1)  {
8032: ef,79,fb            call  7bae             SaveTCode1(73);                   # E73 Insufficient TPS change during Dynamic Response Test
8035: 73                  #args                  }
8036: 31,2c,07            jnb   B1,R2c,8040      if (Kflg_local == 1)  {           # If knock sensor present
8039: 37,d7,04            jnb   B7,Rd7,8040      if (Code_25_41 == 1)  {
803c: ef,6f,fb            call  7bae             SaveTCode1(Flags_25);             # E25 Knock not sensed during Dynamic Response Test
803f: 25                  #args                  } }

8040: a3,78,d0,c2         ldw   Rc2,[R78+d0]     SAF = Vipspk;
8044: b3,78,12,42         ldb   R42,[R78+12]     R42 = Vbisw;
8048: e0,42,15            djnz  R42,8060         R42--;
                                                 if (R42 != 0) goto 8060;
804b: b3,f6,13,42         ldb   R42,[Rf6+13]     R42 = BIHP;                       # (0 on A9L)
804f: e0,42,0e            djnz  R42,8060         R42--;
                                                 if (R42 != 0) goto 8060;
8052: 31,d7,04            jnb   B1,Rd7,8059      if (Code_74 == 1)  {
8055: ef,56,fb            call  7bae             SaveTCode1(Rp2);                  # E74 Brake on/off switch circuit open
8058: 74                  #args                  }
8059: 30,d7,04            jnb   B0,Rd7,8060      if (Code_75 == 1)  {
805c: ef,4f,fb            call  7bae             SaveTCode1(75);                   # E75 Brake on/off switch circuit closed
805f: 75                  #args                  } } }
8060: b3,79,cc,00,42      ldb   R42,[R78+cc]     R42 = VPSSW;
8065: e0,42,11            djnz  R42,8079         R42--;
                                                 if (R42 != 0) goto Sub99;
8068: b3,f6,14,42         ldb   R42,[Rf6+14]     R42 = PSPSHP;                     # (0 on A9L)
806c: e0,42,0a            djnz  R42,8079         R42--;
                                                 if (R42 != 0) goto Sub99;
806f: 32,e6,03            jnb   B2,Re6,8075      if (Powoff == 0) goto 8075;
8072: 3b,e6,04            jb    B3,Re6,8079      if (Powon == 0)  {
8075: ef,36,fb            call  7bae             SaveTCode1(52);                   #E52 Power Steering Pressure Switch circuit open
# Diagnostic Proc Table A
8078: 52                  #args                  } } }

  Sub99:
8079: 91,07,d6            orb   Rd6,7            High_speed = 1;
                                                 Lowspeed_repeat = 1;
                                                 Low_speed = 1;
# Diagnostic Proc Table D
807c: 26,90               sjmp  7f0e             goto 7f0e;

  Sub100:
807e: a3,3b,d8,71,1a      ldw   R1a,[R3a+71d8]   R1a = [R3a+71d8];
8083: 20,0c               sjmp  8091             goto 8091;
# Diagnostic Proc Table D

  Sub101:
8085: a3,3b,80,71,1a      ldw   R1a,[R3a+7180]   R1a = [R3a+7180];
808a: 20,05               sjmp  8091             goto 8091;
# Diagnostic proc Table A

  Sub102:
808c: a3,3b,6a,71,1a      ldw   R1a,[R3a+716a]   R1a = [R3a+716a];
8091: 37,1b,08            jnb   B7,R1b,809c      if (B7_R1b == 1)  {
8094: ef,f4,f8            call  798b             GetAddr(1a);
8097: 1a,00               #args  
8099: b2,1a,1a            ldb   R1a,[R1a]        R1a = [R1a]; }
809c: 98,1a,18            cmpb  R18,R1a          
809f: d9,01               jgtu  80a2             if ((uns) R18 <= R1a)  {
80a1: f0                  ret                    return; }

80a2: 17,38               incb  R38              R38++;
80a4: 26,68               sjmp  7f0e             goto 7f0e;
# Diagnostic proc Table A

  Sub103:
80a6: b1,04,36            ldb   R36,4            R36 = 4;
80a9: 38,2b,0b            jb    B0,R2b,80b7      if (Rvip_cyl_quit == 1) goto 80b7;
80ac: 9b,78,1f,00         cmpb  R0,[R78+1f]      
80b0: df,05               je    80b7             if (0 == Vcbflg) goto 80b7;
80b2: de,08               jlt   80bc             if (0 >= Vcbflg)  {
80b4: 31,2b,05            jnb   B1,R2b,80bc      if (Rvip_cyl_bal == 1)  {
80b7: b1,1f,38            ldb   R38,1f           R38 = 1f;
80ba: 26,52               sjmp  7f0e             goto 7f0e; } }

80bc: 71,fe,2b            an2b  R2b,fe           Rvip_cyl_quit = 0;
80bf: b1,1e,38            ldb   R38,1e           R38 = 1e;
80c2: 27,f6               sjmp  80ba             goto 80ba;
# Diagnostic proc Table A

  Sub104:
80c4: ef,74,fd            call  7e3b             GetWord(Vcbdly);
80c7: 9e,90               #args  
80c9: 39,2b,06            jb    B1,R2b,80d2      if (Rvip_cyl_bal == 0)  {
80cc: a3,78,18,1c         ldw   R1c,[R78+18]     R1c = Vcbpct;
80d0: 20,14               sjmp  80e6             goto 80e6; }
# diagnostic proc Table A

80d2: a3,72,74,1c         ldw   R1c,[R72+74]     R1c = Vcbpct_this_time;
80d6: 67,78,16,1c         ad2w  R1c,[R78+16]     R1c += Vcbpad;
80da: db,06               jc    80e2             if ((uns) R1c >= 0) goto 80e2;
80dc: 8b,78,14,1c         cmpw  R1c,[R78+14]     
80e0: d1,04               jleu  80e6             if ((uns) R1c > Vcbclp )  {
80e2: a3,78,14,1c         ldw   R1c,[R78+14]     R1c = Vcbclp; }
80e6: c3,72,74,1c         stw   R1c,[R72+74]     Vcbpct_this_time = R1c;
80ea: 91,10,2b            orb   R2b,10           Disable_isc = 1;
80ed: b1,19,38            ldb   R38,19           R38 = 19;
80f0: 27,c8               sjmp  80ba             goto 80ba;
# diagnostic proc Table A

  Sub105:
80f2: 28,d6               scall 81ca             Sub112();
80f4: ef,44,fd            call  7e3b             GetWord(Visdl4);
80f7: a0,90               #args  
80f9: fa                  di                     disable ints;
80fa: 28,e4               scall 81e0             Sub113();
80fc: 26,10               sjmp  7f0e             goto 7f0e;

  Sub106:
80fe: 28,ca               scall 81ca             Sub112();
8100: ef,38,fd            call  7e3b             GetWord(Vcbtm1);
8103: a2,90               #args  
8105: fa                  di                     disable ints;
8106: 28,f0               scall 81f8             Sub114();
8108: a1,00,80,1c         ldw   R1c,8000         R1c = 8000;
810c: 6b,72,74,1c         sb2w  R1c,[R72+74]     R1c -= Vcbpct_this_time;
8110: 6f,72,72,1c         ml2w  R1c,[R72+72]     R1f:R1c = R1d:R1c * Vcbn;
8114: 0d,01,1c            shldw R1c,1            R1f:R1c *= 2;
8117: c0,36,1e            stw   R1e,R36          R36 = R1e;
811a: c7,73,92,00,34      stb   R34,[R72+92]     IECT = R34;                    # store to raw ECT AD
811f: 25,ed               sjmp  7f0e             goto 7f0e;
# Diagnostic proc Table A

  Sub107:
8121: 28,a7               scall 81ca             Sub112();
8123: ef,15,fd            call  7e3b             GetWord(Visdl5);
8126: a1,90               #args  
8128: fa                  di                     disable ints;
8129: 28,b5               scall 81e0             Sub113();
812b: 25,e1               sjmp  7f0e             goto 7f0e;
# Diagnostic proc Table A

  Sub108:
812d: 28,9b               scall 81ca             Sub112();
812f: ef,09,fd            call  7e3b             GetWord(Vcbtm2);
8132: a3,90               #args  
8134: fa                  di                     disable ints;
8135: 28,c1               scall 81f8             Sub114();
8137: 88,1c,36            cmpw  R36,R1c          
813a: d9,09               jgtu  8145             if ((uns) R36 <= R1c)  {
813c: b0,34,1a            ldb   R1a,R34          R1a = R34;
813f: 19,04,1a            shlb  R1a,4            R1a *= 10;
8142: ef,6d,fa            call  7bb2             SaveTCode(); }                    # save R1A in 342 TROUBLE CODE Table
8145: c7,73,92,00,00      stb   R0,[R72+92]      IECT = 0;                      # store to raw ECT AD
814a: e0,34,9d            djnz  R34,80ea         R34--;
                                                 if (R34 != 0) goto 80ea;
814d: a3,fe,3a,1a         ldw   R1a,[Rfe+3a]     R1a = NGOOSE;
8151: c3,72,6e,1a         stw   R1a,[R72+6e]     RVIPRPM = R1a;
8155: 71,ef,2b            an2b  R2b,ef           Disable_isc = 0;
8158: a3,fe,2c,42         ldw   R42,[Rfe+2c]     R42 = VRLAM_1;
815c: c3,73,8a,00,42      stw   R42,[R72+8a]     LAMBSE1 = R42;
8161: c3,73,8c,00,42      stw   R42,[R72+8c]     LAMBSE2 = R42;                    # store to raw KEYPWR
8166: 88,30,00            cmpw  R0,R30           
8169: d7,04               jne   816f             if (0 == R30)  {
816b: ef,40,fa            call  7bae             SaveTCode1(Last_HSI);             # E 90 - Pass Cyl Balance Test
816e: 90                  #args                  }
816f: 91,02,2b            orb   R2b,2            Rvip_cyl_bal = 1;
8172: b1,1d,38            ldb   R38,1d           R38 = 1d;
8175: 25,97               sjmp  7f0e             goto 7f0e;
# Diagnostic proc Table A

  Sub109:
8177: 33,d6,05            jnb   B3,Rd6,817f      if (Sto_working == 1)  {
817a: c7,72,4a,00         stb   R0,[R72+4a]      VIPTMR = 0;
817e: f0                  ret                    return; }

817f: 99,20,18            cmpb  R18,20           
8182: db,01               jgeu  8185             if (R18 > 20)  {
8184: f0                  ret                    return; }

8185: b1,16,38            ldb   R38,16           R38 = 16;
8188: 26,ef               sjmp  8079             goto Sub99;                       # clr 1CA timer, incr R38 self test index, set bit flag and return

# Diagnostic proc Table A

  Sub110:
818a: 3f,d0,03            jb    B7,Rd0,8190      if (Cl_thrtl == 0)  {
818d: 91,01,2b            orb   R2b,1            Rvip_cyl_quit = 1; }
8190: 30,2b,27            jnb   B0,R2b,81ba      if (Rvip_cyl_quit == 1)  {
8193: 37,d0,24            jnb   B7,Rd0,81ba      if (Cl_thrtl == 1)  {
8196: 71,fe,2b            an2b  R2b,fe           Rvip_cyl_quit = 0;
8199: 01,30               clrw  R30              R30 = 0;
819b: b3,fe,07,34         ldb   R34,[Rfe+7]      R34 = ENGCYL;                     # PIPs/rev * 2
819f: a3,78,1c,1a         ldw   R1a,[R78+1c]     R1a = Viscn1;
81a3: c3,72,6e,1a         stw   R1a,[R72+6e]     RVIPRPM = R1a;
81a7: a3,78,1a,42         ldw   R42,[R78+1a]     R42 = Vlamcb;
81ab: c3,73,8a,00,42      stw   R42,[R72+8a]     LAMBSE1 = R42;
81b0: c3,73,8c,00,42      stw   R42,[R72+8c]     LAMBSE2 = R42;
81b5: b1,18,38            ldb   R38,18           R38 = 18;
81b8: 27,00               sjmp  80ba             goto 80ba; } }

# Diagnostic proc Table A

  Sub111:
81ba: 99,f0,18            cmpb  R18,f0           
81bd: d1,0a               jleu  81c9             if ((uns) R18 <= f0) return;
81bf: c7,72,4a,00         stb   R0,[R72+4a]      VIPTMR = 0;
81c3: 15,36               decb  R36              R36--;
81c5: d2,02               jgt   81c9             if (R36 > 0) return;
81c7: 25,49               sjmp  7f12             goto 7f12; }

81c9: f0                  ret                    return;


  Sub112:
81ca: 3f,d0,12            jb    B7,Rd0,81df      if (Cl_thrtl == 1) return;
81cd: c7,73,92,00,00      stb   R0,[R72+92]      IECT = 0;
81d2: 01,30               clrw  R30              R30 = 0;
81d4: ef,d7,f9            call  7bae             SaveTCode1(77);
81d7: 77                  #args  
81d8: 91,01,2b            orb   R2b,1            Rvip_cyl_quit = 1;
81db: cc,00               pop   R0               R0 = pop();
81dd: 27,6e               sjmp  814d             goto 814d; }

81df: f0                  ret                    return;


  Sub113:
81e0: c3,72,76,00         stw   R0,[R72+76]      Vcb_pip_cnt = 0;
81e4: a3,73,4e,01,1c      ldw   R1c,[R72+14e]    R1c = Prev_PIP_time;
81e9: c3,72,78,1c         stw   R1c,[R72+78]     Vcb_pip_timer = R1c;
81ed: af,73,50,01,1c      ldzbw R1c,[R72+150]    R1c = (uns)Prev_PIP_timeH;
81f2: c3,72,7a,1c         stw   R1c,[R72+7a]     Vcb_pip_htimer = R1c;
81f6: fb                  ei                     enable ints;
81f7: f0                  ret                    return;


  Sub114:
81f8: a3,72,76,1a         ldw   R1a,[R72+76]     R1a = Vcb_pip_cnt;
81fc: a3,73,4e,01,20      ldw   R20,[R72+14e]    R20 = Prev_PIP_time;
8201: af,73,50,01,22      ldzbw R22,[R72+150]    R22 = (uns)Prev_PIP_timeH;
8206: fb                  ei                     enable ints;
8207: 6b,72,78,20         sb2w  R20,[R72+78]     R20 -= Vcb_pip_timer;
820b: bb,72,7a,22         sbbb  R22,[R72+7a]     R22 -= Vcb_pip_htimer - CY;
820f: 8c,1a,20            divw  R20,R1a          R21:R20 = R23:R20 / Vcb_pip_cnt;
8212: af,fe,07,1a         ldzbw R1a,[Rfe+7]      R1a = (uns)ENGCYL;                # PIPs/rev * 2
8216: a3,1b,9c,3d,1e      ldw   R1e,[R1a+3d9c]   R1e = [R1a+3d9c];
821b: a3,1b,a2,3d,1c      ldw   R1c,[R1a+3da2]   R1c = [R1a+3da2];
8220: 8c,20,1c            divw  R1c,R20          R1d:R1c = R1f:R1c / R21:R20;
8223: c3,72,72,1c         stw   R1c,[R72+72]     Vcbn = R1c;
8227: f0                  ret                    return;
#################################################################
# Tasklist Routine at 2151, routine offset 9A
#################################################################


  Sub115:
8228: 31,ea,05            jnb   B1,Rea,8230      if (BIFLG == 1)  {                 # If equal to 1, Brake is on.
822b: 71,fd,d7            an2b  Rd7,fd           Code_74 = 0;
822e: 20,03               sjmp  8233             goto 8233; }

8230: 71,fe,d7            an2b  Rd7,fe           Code_75 = 0;
8233: 34,27,05            jnb   B4,R27,823b      if (POWSFG == 1)  {                # power steering on
8236: 91,08,e6            orb   Re6,8            Powon = 1;
8239: 20,03               sjmp  823e             return; }

823b: 91,04,e6            orb   Re6,4            Powoff = 1;
823e: f0                  ret                    return;

#################################################################
# Check HEGO sensors
# KOER Tasklist Routine at 2151, routine offset 98
#################################################################

  Chk_HEGO:
823f: ef,54,ee            call  7096             Set_EGRFlags();                   # Set up EGR flags
8242: a3,72,4c,32         ldw   R32,[R72+4c]     R32 = Egobar1;                    # OLD average HEGO1
8246: a3,72,9c,34         ldw   R34,[R72+9c]     R34 = IEGO1;                      # NEW value - raw HEGO1
824a: a3,78,02,36         ldw   R36,[R78+2]      R36 = Vtcego;                     # time constant
824e: ef,12,b4            call  3663             Urolav();                         # filter HEGO1
8251: c3,72,4c,3e         stw   R3e,[R72+4c]     Egobar1 = R3e;                    # save new filtered value
8255: 71,7f,2b            an2b  R2b,7f           Egoste1 = 0;                      # clear HEGO1 cross over voltage detected
8258: 89,c0,d5,3e         cmpw  R3e,d5c0                                           # O2S TRIP VOLTAGE
825c: d1,03               jleu  8261             if ((uns) R3e > d5c0 )  {
825e: 91,80,2b            orb   R2b,80           Egoste1 = 1; }                    # signal HEGO1 voltage cross?
8261: a3,72,4e,32         ldw   R32,[R72+4e]     R32 = Egobar2;                    # OLD average HEGO2
8265: a3,72,9e,34         ldw   R34,[R72+9e]     R34 = IEGO2;                      # NEW value HEGO2 raw
8269: ef,f9,b3            call  3665             Urolav_1();                       # filter oxygen sensor,
                                                                                   #  using same time constant from above
826c: c3,72,4e,3e         stw   R3e,[R72+4e]     Egobar2 = R3e;                    # filtered value (new HEGO2 avg)
8270: 71,bf,2b            an2b  R2b,bf           Egoste2 = 0;                      # clear HEGO2 cross over voltage detected
8273: 89,c0,d5,3e         cmpw  R3e,d5c0                                           # O2S TRIP VOLTAGE
8277: d1,03               jleu  827c             if ((uns) R3e <= d5c0) return;
8279: 91,40,2b            orb   R2b,40           Egoste2 = 1; }                    # signal HEGO2 voltage cross?
827c: f0                  ret                    return;

#################################################################
# CPU test 
# range of 8061 ALU, addressing, push/pop etc.
#################################################################


  HW_Check:
827d: fa                  di                     disable ints;
827e: ff                  nop                    
827f: ff                  nop                    
8280: c3,73,46,01,10      stw   R10,[R72+146]    SvStack = STACK;                  # save old stack ptr
8285: ff                  nop                    
8286: a1,58,00,10         ldw   R10,58           STACK = 58;                       # set new stack pointer
828a: a1,7c,a1,3c         ldw   R3c,a17c         R3c = a17c;
828e: a1,7c,a1,3a         ldw   R3a,a17c         R3a = a17c;
8292: 05,3a               decw  R3a              R3a--;
8294: 88,3a,3c            cmpw  R3c,R3a          
8297: ff                  nop                    
8298: db,03               jgeu  829d             if ((uns) R3c >= R3a) goto 829d;
829a: 20,e2               sjmp  837e             goto 837e;                        # exit CPU ALU error


829c: f8                                                                           # safety catch ?

829d: d3,fb               jltu  829a             if ((uns) R3c < R3a) goto 829a;
829f: 65,63,75,3c         ad2w  R3c,7563         R3c += 7563;
82a3: db,04               jc    82a9             if ((uns) R3c >= 0) goto 82a9;
82a5: 27,f3               sjmp  829a             goto 829a;


82a7: ff,f8               ??                                                       # safety catch ?

82a9: d3,ef               jnc   829a             if ((uns) R3c < 0) goto 829a;
82ab: f9                  stc                    CY = 1
82ac: 00                  skip                   goto 82ae;


82ad: f8                        

82ae: d3,ea               jnc   829a             if ((uns) R3c < 0) goto 829a;
82b0: a1,e5,4b,3a         ldw   R3a,4be5         R3a = 4be5;
82b4: 64,3a,3c            ad2w  R3c,R3a          R3c += R3a;                       # test ADD
82b7: 89,c4,62,3c         cmpw  R3c,62c4         
82bb: d7,dd               jne   829a             if (R3c != 62c4) goto 829a;
82bd: 09,01,3c            shlw  R3c,1            R3c *= 2;
82c0: 69,63,75,3c         sb2w  R3c,7563         R3c -= 7563;                      # test SHIFT and SUB
82c4: 89,25,50,3c         cmpw  R3c,5025         
82c8: d7,d0               jne   829a             if (R3c != 5025) goto 829a;
82ca: 85,82,b0,3c         xrw   R3c,b082         Word_tmr ^= 1;
                                                 Seconds ^= 1;
                                                 B12_R3c ^= 1;
                                                 B13_R3c ^= 1;
                                                 B15_R3c ^= 1;
82ce: 85,82,b0,3c         xrw   R3c,b082         Word_tmr ^= 1;
                                                 Seconds ^= 1;
                                                 B12_R3c ^= 1;
                                                 B13_R3c ^= 1;
                                                 B15_R3c ^= 1;                     # test XOR
82d2: 89,25,50,3c         cmpw  R3c,5025         
82d6: d7,c2               jne   829a             if (R3c != 5025) goto 829a;
82d8: 61,82,b0,3c         an2w  R3c,b082         Free_run = 0;
                                                 Decrement = 0;
                                                 Inverse = 0;
                                                 B4_R3c = 0;
                                                 Millisecs = 0;
                                                 Eighths = 0;
                                                 B8_R3c = 0;
                                                 B9_R3c = 0;
                                                 B10_R3c = 0;
                                                 B11_R3c = 0;
                                                 B14_R3c = 0;                      # test AND
82dc: 89,00,10,3c         cmpw  R3c,1000         
82e0: d7,b8               jne   829a             if (R3c != 1000) goto 829a;
82e2: 81,31,ce,3c         orw   R3c,ce31         Free_run = 1;
                                                 B4_R3c = 1;
                                                 Millisecs = 1;
                                                 B9_R3c = 1;
                                                 B10_R3c = 1;
                                                 B11_R3c = 1;
                                                 B14_R3c = 1;
                                                 B15_R3c = 1;                      # test OR
82e6: 89,31,de,3c         cmpw  R3c,de31         
82ea: d7,ae               jne   829a             if (R3c != de31) goto 829a;
82ec: b1,31,33            ldb   R33,31           R33 = 31;
82ef: c7,73,0f,02,33      stb   R33,[R72+20f]    Xram2H = R33;
82f4: b1,92,33            ldb   R33,92           R33 = 92;
82f7: 57,73,0f,02,33,32   ad3b  R32,R33,[R72+20f] R32 = R33 + Xram2H;
82fd: 99,c3,32            cmpb  R32,c3           
8300: d7,7c               jne   837e             if (R32 != c3) goto 837e;
8302: b1,7b,30            ldb   R30,7b           R30 = 7b;
8305: b1,c5,32            ldb   R32,c5           R32 = c5;
8308: 5c,30,32,34         ml3b  R34,R32,R30      R34 = R32 * R30;
830c: 89,a7,5e,34         cmpw  R34,5ea7         
8310: d7,6c               jne   837e             if (R34 != 5ea7) goto 837e;
8312: 9c,32,34            divb  R34,R32          R34 /= R32;
8315: 99,7b,34            cmpb  R34,7b           
8318: d7,64               jne   837e             if (R34 != 7b) goto 837e;
831a: 01,30               clrw  R30              R30 = 0;
831c: 01,32               clrw  R32              R32 = 0;
831e: 11,3c               clrb  R3c              R3c = 0;
8320: 0f,3c,30            norm  R0,R3c           R3c = nrml(0);                    # test norml
8323: 99,7b,34            cmpb  R34,7b           
8326: d7,56               jne   837e             if (R34 != 7b) goto 837e;
8328: 99,1f,3c            cmpb  R3c,1f           
832b: d7,51               jne   837e             if (R3c != 1f) goto 837e;
832d: a1,7c,a1,3c         ldw   R3c,a17c         R3c = a17c;
8331: c3,73,0c,02,3c      stw   R3c,[R72+20c]    Xram1L = R3c;
8336: 28,4b               scall 8383             POP_test();                       # stack test - push and pop
8338: 8b,73,0e,02,3c      cmpw  R3c,[R72+20e]    
833d: d7,3f               jne   837e             if (R3c != Xram2L) goto 837e;
833f: 8b,73,10,02,3c      cmpw  R3c,[R72+210]    
8344: d7,38               jne   837e             if (R3c != Xram3L) goto 837e;
8346: 88,30,3c            cmpw  R3c,R30          
8349: d7,33               jne   837e             if (R3c != R30) goto 837e;
834b: a1,00,04,10         ldw   R10,400          STACK = 400;                      # stack to absolute address test locations
834f: a1,75,55,3c         ldw   R3c,5575         R3c = 5575;
8353: c3,73,0c,02,3c      stw   R3c,[R72+20c]    Xram1L = R3c;
8358: 28,29               scall 8383             POP_test();                       # test stack push/pop
835a: 8b,73,0e,02,3c      cmpw  R3c,[R72+20e]    
835f: d7,1d               jne   837e             if (R3c != Xram2L) goto 837e;
8361: 8b,73,10,02,3c      cmpw  R3c,[R72+210]    
8366: d7,16               jne   837e             if (R3c != Xram3L) goto 837e;
8368: 88,30,3c            cmpw  R3c,R30          
836b: d7,11               jne   837e             if (R3c != R30) goto 837e;
836d: b1,aa,30            ldb   R30,aa           R30 = aa;                         # indexed fetch test
8370: c7,73,0f,02,30      stb   R30,[R72+20f]    Xram2H = R30;
8375: a1,8f,03,32         ldw   R32,38f          R32 = Xram2H;
8379: 9a,32,30            cmpb  R30,[R32]        
837c: df,1c               je    839a             if (R30 = [R32]) goto RAM_test;   # OK if equal, run RAM test
837e: 91,10,2a            orb   R2a,10           Disable_nostart = 1;
8381: 20,50               sjmp  83d3             goto 83d3;                        # reset stack ptr, enable ints and return

### push and pop test (called above) ######

  POP_test:
8383: cb,73,0c,02         push  [R72+20c]        push(Xram1L);
8387: cf,73,0e,02         pop   [R72+20e]        Xram2L = pop();
838b: cb,73,0e,02         push  [R72+20e]        push(Xram2L);
838f: cc,30               pop   R30              R30 = pop();
8391: c8,30               push  R30              push(R30);
8393: cf,73,10,02         pop   [R72+210]        Xram3L = pop();
8397: f0                  ret                    return;

# safety catch for push and pop ?



8398: 27,e4               ??    

#############################################################
# memory RAM test from 100 to 8FF
# uses odd and even bit patterns (aaaa and 5555)
 and restores stack at end of test
############################################################



  RAM_test:
839a: a1,ff,08,3a         ldw   R3a,8ff          R3a = 8ff;                        # RAM test start and end addresses
839e: a1,00,01,42         ldw   R42,100          R42 = TPBAR  ;
83a2: a1,aa,aa,30         ldw   R30,aaaa         R30 = aaaa;
83a6: a1,55,55,32         ldw   R32,5555         R32 = 5555;
83aa: 95,40,02            xorb  R2,40            CPU_OK ^= 1;
83ad: 17,05               incb  R5               WDG_Timer++;
83af: a2,42,34            ldw   R34,[R42]        R34 = [R42];                      # backup contents of test location
83b2: 95,40,02            xorb  R2,40            CPU_OK ^= 1;
83b5: c2,42,30            stw   R30,[R42]        [R42] = R30;                      # test odd bits
83b8: a2,42,36            ldw   R36,[R42]        R36 = [R42];
83bb: 88,30,36            cmpw  R36,R30          
83be: d7,1a               jne   83da             if (R36 != R30) goto 83da;
83c0: c2,42,32            stw   R32,[R42]        [R42] = R32;                      # test even bits
83c3: a2,42,36            ldw   R36,[R42]        R36 = [R42];
83c6: 88,32,36            cmpw  R36,R32          
83c9: d7,0f               jne   83da             if (R36 != R32) goto 83da;
83cb: c2,43,34            stw   R34,[R42++]      [R42++] = R34;                    # restore contents of test location
83ce: 88,3a,42            cmpw  R42,R3a          
83d1: d3,d7               jltu  83aa             if ((uns) R42 < R3a) goto 83aa;   # loop to end
83d3: a3,73,46,01,10      ldw   R10,[R72+146]    STACK = SvStack;
83d8: fb                  ei                     enable ints;
83d9: f0                  ret                    return;

83da: e7,a1,ff            jump  837e             goto 837e;                        # RAM error

################################################################

  Sub116:
83dd: 35,2b,05            jnb   B5,R2b,83e5      if (STIFLG == 1)  {

  Sub117:
83e0: c3,72,40,00         stw   R0,[R72+40]      MILTMR = 0;
83e4: f0                  ret                    return; }

83e5: 3f,a1,36            jb    B7,Ra1,841e      if (CRKFLG == 1) goto 841e;
83e8: 51,fa,c5,34         an3b  R34,Rc5,fa       R34 = Fmem_flags & fa;
83ec: d7,16               jne   8404             if (R34 == 0)  {
83ee: b3,72,32,42         ldb   R42,[R72+32]     R42 = C41FIL;
83f2: 9b,78,49,42         cmpb  R42,[R78+49]     
83f6: d9,0c               jgtu  8404             if ((uns) R42 <= C41LVL)  {
83f8: b3,72,3c,42         ldb   R42,[R72+3c]     R42 = C91FIL;
83fc: 9b,78,53,42         cmpb  R42,[R78+53]     
8400: d9,02               jgtu  8404             if ((uns) R42 > C91LVL ) goto 8404;
8402: 20,27               sjmp  842b             goto 842b; } }

8404: a3,79,98,00,40      ldw   R40,[R78+98]     R40 = FMDTM;                      # timer value for ?
8409: 6b,72,40,40         sb2w  R40,[R72+40]     R40 -= MILTMR;                    # Check Engine LP?
840d: db,1e               jc    842d             if ((uns) R40 >= 0) goto 842d;
840f: 01,42               clrw  R42              R42 = 0;
8411: 8f,79,9c,00,40      divw  R40,[R78+9c]     R41:R40 = (FMDTM - MILTMR) / MILTM1;
8416: dd,03               jv    841b             if (OVF == 1) goto Sub118;
8418: 38,40,12            jb    B0,R40,842d      if (B0_R40 == 1) goto 842d;

  Sub118:
841b: e7,8e,f3            jump  77ac             goto Set_STO;                     # tweak flags, set STO on and return
841e: 3c,2a,0a            jb    B4,R2a,842b      if (Disable_nostart == 1) goto 842b; # jump if VIP mode flag : disable no start
8421: 3c,2d,07            jb    B4,R2d,842b      if (FIRST_PIP == 1) goto 842b;
8424: 8b,79,9a,00,00      cmpw  R0,[R78+9a]      
8429: d7,05               jne   8430             if (0 == MILLIM)  {
# Don't turn on (turn off) MIL during crank
842b: 2f,b3               scall 83e0             Sub117();
842d: e7,84,f3            jump  77b4             goto Reset_STO; }                 # set STO off flag, set STO output low, and set STO trigger
#
8430: 2f,e9               scall 841b             Sub118();
8432: 27,ac               sjmp  83e0             goto Sub117;


################################################################
# Diagnostic proc Table A
# jump Table entry 0x71C8
# reset lots of stuff and jump back to cycling thru procs
# switch out of self test to run mode ?
## function/maps/scalars
################################################################

  Sub119:
8434: 3b,d6,4d            jb    B3,Rd6,8484      if (Sto_working == 0)  {
8437: 3a,2b,4a            jb    B2,R2b,8484      if (Sto_trigger == 1) return;
843a: 30,2a,03            jnb   B0,R2a,8440      if (VSCDT == 1)  {
843d: 91,20,2a            orb   R2a,20           RUNNING = 1; }                    # Activate KOER self test mode
#
8440: fa                  di                     disable ints;
8441: ff                  nop                    
8442: a1,8c,04,10         ldw   R10,48c          STACK = 48c;                      # Reinitialize stack pointer
8446: ef,a6,f6            call  7aef             Sub74();                          # Reset Low speed outputs ?
8449: 01,46               clrw  R46              IO_Port_State = 0;                # clear all LSO outputs
844b: 31,2a,03            jnb   B1,R2a,8451      if (Vscst == 1)  {
844e: 91,40,2a            orb   R2a,40           No_start = 1; }
#
8451: ef,de,9b            call  2032             Reset_All();                      # Reset EEC - init Tables and ports
8454: 30,2a,06            jnb   B0,R2a,845d      if (VSCDT == 1)  {
8457: 71,fe,2a            an2b  R2a,fe           VSCDT = 0;
845a: 91,80,2a            orb   R2a,80           Disable_vscdt = 1; }
#
845d: 31,2a,0c            jnb   B1,R2a,846c      if (Vscst == 1)  {
8460: 71,bd,2a            an2b  R2a,bd           Vscst = 0;
                                                 No_start = 0;
8463: a1,00,28,42         ldw   R42,2800         R42 = 2800;
8467: c3,01,34,01,42      stw   R42,[R0+134]     PUTMR = R42; }                    # Counts up after h/w reset
#
846c: 35,2a,06            jnb   B5,R2a,8475      if (RUNNING == 1)  {              # not self test mode
846f: 71,db,2a            an2b  R2a,db           Vip_enable = 0;                   # Clear KOER self test
                                                 RUNNING = 0;
8472: 91,18,2a            orb   R2a,18           Disable_running = 1;
                                                 Disable_nostart = 1; }
#
8475: 36,2a,06            jnb   B6,R2a,847e      if (No_start == 1)  {
8478: 71,bb,2a            an2b  R2a,bb           Vip_enable = 0;
                                                 No_start = 0;
847b: 91,10,2a            orb   R2a,10           Disable_nostart = 1; }
#
847e: ef,33,f3            call  77b4             Reset_STO();                      # Reset STO
8481: e7,cd,9c            jump  2151             goto Backg_loop; }
#
8484: f0                  ret                    return;


###################################################################
# Handle HSI line 7 data (Ignition Diagnostic Monitor)
# *** CALLED IN INTERRUPT HANDLER CONTEXT ***
###################################################################

  Idm_inth:
8485: 71,7f,87            an2b  R87,7f           Idm_irq = 0;
8488: 37,90,03            jnb   B7,R90,848e      if (B7_Last_HSI == 1)  {
848b: 91,10,4e            orb   R4e,10           New_idm = 1; }
848e: f0                  ret                    return;


#################################################################
# Background routine, part of all 3 background task lists
# Check whether we've received new inputs on PIP, IDM, BAP,
# and clear their respective timers if we have.
#################################################################

  Set_ign_timers:
848f: 37,4e,07            jnb   B7,R4e,8499      if (New_pip == 1)  {
8492: 71,7f,4e            an2b  R4e,7f           New_pip = 0;
8495: c3,72,be,00         stw   R0,[R72+be]      TSLPIP = 0; }
8499: 38,2c,0a            jb    B0,R2c,84a6      if (IDM_BYPASS == 0)  {
849c: 34,4e,07            jnb   B4,R4e,84a6      if (New_idm == 1)  {
849f: 71,ef,4e            an2b  R4e,ef           New_idm = 0;
84a2: c3,72,44,00         stw   R0,[R72+44]      TSLIDM = 0; } }
84a6: 36,4e,07            jnb   B6,R4e,84b0      if (NEW_BAP == 0) return;
84a9: 71,bf,4e            an2b  R4e,bf           NEW_BAP = 0;
84ac: c7,72,b6,00         stb   R0,[R72+b6]      BAPTMR = 0; }
84b0: f0                  ret                    return;


#############################################################
# Entry point from background loop
# Console_init (R24 bit 4) == 0 (always when using this entry)
# See below for other inputs, outputs
#
# Tasklist Routine at 2151, routine offset 0
# check for and set up calibration console
# (re)initialize calibration base registers
#############################################################

  Check_ConsoleD:
84b1: fa                  di                     disable ints;

#############################################################
# Entry point from initialization routine
# Interrupts disabled
# Inputs:
#  Console_init (R24 bit 4) == 1 (initialization only), 0 if called from b/g loop
#  0C80 bit 6 == 1 to use console cal data, 0 to use ROM
#  0D00 (word) == 2Axx if console present
#  2020 (byte) == # of (word) base registers to initialize
#  2022 == ROM vector of base register values
#  C200 == console vector of base register values
#  1FF2 (word), 1FF6 (word) - see code
# Outputs:
#  Console_init (R24 bit 4) = 0
#  RF0 - RFE base pointers set to appropriate calibration data
#  C000 (byte) = 0
#  C11A (word) = time of next HSO #2 interrupt if console present
#
# N.B. Check_console is where the TwEECer and Quarterhorse patches are installed.
#############################################################

  Check_console:
84b2: a3,01,00,0d,14      ldw   R14,[R0+d00]     R14 = [d00];                      # Console Present register
84b7: 99,2a,15            cmpb  R15,2a           
84ba: d7,2c               jne   84e8             if (R15 = 2a)  {                  # jump if console not present
#      
# Console hardware is present
84bc: 3c,24,1b            jb    B4,R24,84da      if (Console_init == 0)  {         # jump if initialization
84bf: 38,0a,18            jb    B0,Ra,84da       if (HSO_OVF == 0)  {              # or HSO queue full
#
# Called from b/g loop and HSO queue not full -
# Schedule console interrupt and call console background routine
84c2: 47,01,0e,20,06,80   ad3w  R80,R6,[R0+200e] HSO_time = IO_Timer + [200e];     # add 5D (223.2 us) to current time
84c8: d7,02               jne   84cc             if (HSO_time == 0)  {
84ca: 07,80               incw  R80              HSO_time++; }                     # avoid 0
#
84cc: c3,01,1a,c1,80      stw   R80,[R0+c11a]    [c11a] = HSO_time;                # Store scheduled time of wakeup in console
84d1: a0,80,0e            ldw   Re,R80           HSO_Time = HSO_time;
84d4: b1,0f,0d            ldb   Rd,f             HSO_Cmd = f;                      # Schedule HSO interrupt #2
84d7: ef,2c,4b            call  d006             d006(); } }                       # Call console background routine #1
#
# Console hardware is present
# Jump here from 84bc (Console_init == 1), 84da (HSO_OVF == 1)
84da: a3,01,80,0c,14      ldw   R14,[R0+c80]     R14 = [c80];                      # flags for data pointers
84df: 36,14,06            jnb   B6,R14,84e8      if (Csmode == 1)  {
84e2: a1,00,c2,14         ldw   R14,c200         R14 = c200;                       # Use these calibration pointers for console,
                                                                                   # instead of ones in ROM
84e6: 20,09               sjmp  84f1             goto 84f1; } }
#
# Jump here from 84ba (console not present), 84e8 (Csmode == 0)
84e8: c7,01,00,c0,00      stb   R0,[R0+c000]     [c000] = 0;                       # Console Hardport Address
84ed: a1,22,20,14         ldw   R14,2022         R14 = 2022;                       # Calibration Table pointers in ROM
#
# Jump here from 84e6 (Csmode == 1)
84f1: 3c,24,01            jb    B4,R24,84f5      if (Console_init == 0)  {         # enable ints if called from b/g loop
84f4: fb                  ei                     enable ints; }
#
# R14 (word) = address of first calibration pointer to copy (c200 if console active, 2022 if not)
84f5: a1,f0,00,18         ldw   R18,f0           R18 = f0;                         # copy calibration pointers to base registers starting at Rf0
84f9: b3,01,20,20,1a      ldb   R1a,[R0+2020]    R1a = [2020];                     # # of calibration pointers
#
# enter loop
84fe: a2,15,1c            ldw   R1c,[R14++]      R1c = [R14++];                    # Get pointer
8501: c2,19,1c            stw   R1c,[R18++]      [R18++] = R1c;                    # Store in base register
8504: e0,1a,f7            djnz  R1a,84fe         R1a--;
                                                 if (R1a != 0) goto 84fe;          # loop until all done
#
# Done initializing calibration base regs
8507: 3c,24,22            jb    B4,R24,852c      if (Console_init == 0)  {         # jump if initialization
#
# Called from background loop
850a: a3,01,f2,1f,42      ldw   R42,[R0+1ff2]    R42 = [1ff2];                     # console value ?
850f: 89,1c,1f,42         cmpw  R42,1f1c                                           # console background routine #2 address
8513: d7,17               jne   852c             if (R42 == 1f1c)  {
8515: a1,a5,a5,42         ldw   R42,a5a5         R42 = a5a5;
8519: c3,01,f6,1f,42      stw   R42,[R0+1ff6]    [1ff6] = R42;                     # read/write console ?
851e: 8b,01,f6,1f,42      cmpw  R42,[R0+1ff6]    
8523: d7,07               jne   852c             if (R42 == [1ff6])  {
8525: c9,2c,85            push  852c             push(Check_console_exit);         # return address for...
8528: cb,01,f2,1f         push  [R0+1ff2]        push([1ff2]); } } }               # indirect call to console b/g routine #2
#
# Jump here from 8507, 8513, 8523
  Check_console_exit:
852c: 71,ef,24            an2b  R24,ef           Console_init = 0;                 # Clear initialization flag
852f: f0                  ret                    return;


#################################################################
# Tasklist Routine at 2151, routine offset 22
# Update EGR for PFE type (not used on A9L)
#################################################################

  Update_PFE_EGR:
8530: 36,e6,6f            jnb   B6,Re6,85a2      if (Pfehp_flg == 1)  {             # return if Pressure Feedback EGR h/w not present (A9L has EVP instead)
8533: b3,01,c0,07,16      ldb   R16,[R0+7c0]     R16 = Kam_flags;
8538: a3,72,b4,14         ldw   R14,[R72+b4]     R14 = PUTMR;
853c: 8b,f8,50,14         cmpw  R14,[Rf8+50]     
8540: db,0c               jgeu  854e             if (R14 > TKYON1)  {
8542: 71,fd,28            an2b  R28,fd           PTPFLG = 0;
8545: 3f,28,03            jb    B7,R28,854b      if (KAM_ERROR == 1) goto 854b;
8548: 3f,16,03            jb    B7,R16,854e      if (B7_R16 == 0)  {
854b: 91,20,ec            orb   Rec,20           BPUFLG = 1; } }
854e: 3a,a1,09            jb    B2,Ra1,855a      if (UNDSP == 0)  {
8551: 9b,f8,56,c8         cmpb  Rc8,[Rf8+56]     
8555: d1,03               jleu  855a             if ((uns) ATMR1 > TKYON4 )  {
8557: 71,7f,16            an2b  R16,7f           B7_R16 = 0; } }
855a: 35,ec,40            jnb   B5,Rec,859d      if (BPUFLG == 1)  {
855d: 39,28,3d            jb    B1,R28,859d      if (PTPFLG == 0)  {
8560: 8b,f8,52,14         cmpw  R14,[Rf8+52]     
8564: d3,37               jltu  859d             if ((uns) R14 >= TKYON2)  {
8566: 8b,f8,54,14         cmpw  R14,[Rf8+54]     
856a: d9,31               jgtu  859d             if ((uns) R14 <= TKYON3)  {
856c: a1,80,a2,3e         ldw   R3e,a280         R3e = a280;
8570: a3,72,96,34         ldw   R34,[R72+96]     R34 = IEVP;
8574: 8b,f3,38,01,34      cmpw  R34,[Rf2+138]    
8579: d1,1d               jleu  8598             if ((uns) R34 > VEPTLL )  {
857b: 8b,f3,3a,01,34      cmpw  R34,[Rf2+13a]    
8580: db,16               jgeu  8598             if (R34 > VEPTHL)  {
8582: 67,f8,4e,34         ad2w  R34,[Rf8+4e]     R34 += IDLDEL;
8586: d3,03               jnc   858b             if ((uns) R34 >= 0)  {
8588: bd,ff,34            ldsbw R34,ff           R34 = 0xffff; }
858b: a3,01,ee,07,32      ldw   R32,[R0+7ee]     R32 = EPTZER;                     # old filtered EVP
8590: ef,cb,b0            call  365e             Urolav_1Arg(97f0);                   # new value in R34
8593: 48,d0               #args                                                    # filter factor
8595: 91,80,16            orb   R16,80           B7_R16 = 1; } }
8598: c3,01,ee,07,3e      stw   R3e,[R0+7ee]     EPTZER = R3e; } } } }             # new filtered EVP
859d: c7,01,c0,07,16      stb   R16,[R0+7c0]     Kam_flags = R16; }
#
85a2: f0                  ret                    return;

#############################################################
# Checksum the KAM tables  0x704 - 7AF
#
# Checksum stored at 0x702 (word)
# New checksum is OK if within 1 of saved sum, then updated 
# otherwise tables are cleared (set to 128)
# called only at reset
#############################################################


  Check_Kam_1:
85a3: ad,56,30            ldzbw R30,56           R30 = (uns)56;                    # 86 byte tables
85a6: 01,38               clrw  R38              R38 = 0;                          # start new csum
85a8: af,31,03,07,3a      ldzbw R3a,[R30+703]    R3a = (uns)[R30+KCsumh];          # Table 1
85ad: 64,3a,38            ad2w  R38,R3a          R38 += R3a;
85b0: af,31,59,07,3a      ldzbw R3a,[R30+759]    R3a = (uns)[R30+LTMTB185];        # Table 2
85b5: 64,3a,38            ad2w  R38,R3a          R38 += R3a;
85b8: e0,30,ed            djnz  R30,85a8         R30--;
                                                 if (R30 != 0) goto 85a8;          # loop
85bb: a3,01,02,07,3a      ldw   R3a,[R0+702]     R3a = CHKSUM;                     # current csum
85c0: 68,38,3a            sb2w  R3a,R38          R3a -= R38;
85c3: db,02               jc    85c7             if (R3a > 0)  {
85c5: 03,3a               negw  R3a              R3a = -R3a; }
85c7: 89,01,00,3a         cmpw  R3a,1            
85cb: d9,06               jgtu  85d3             if ((uns) R3a <= 1)  {
85cd: c3,01,02,07,38      stw   R38,[R0+702]     CHKSUM = R38;                     # OK, save new csum
85d2: f0                  ret                    return; }

# checksum is bad - Clear tables

  Sub121:
85d3: b1,80,3a            ldb   R3a,80           R3a = 80;                         # set cells to 128
85d6: ad,56,30            ldzbw R30,56           R30 = (uns)56;
85d9: c7,31,03,07,3a      stb   R3a,[R30+703]    [R30+KCsumh] = R3a;               # Table 1
85de: c7,31,59,07,3a      stb   R3a,[R30+759]    [R30+LTMTB185] = R3a;             # Table 2
85e3: e0,30,f3            djnz  R30,85d9         R30--;
                                                 if (R30 != 0) goto 85d9;
85e6: a1,00,56,38         ldw   R38,5600         R38 = 5600;                       # new csum = (56+56)*128
85ea: c3,01,02,07,38      stw   R38,[R0+702]     CHKSUM = R38;                     # save sum
85ef: c7,01,e0,07,00      stb   R0,[R0+7e0]      KWUCTR = 0;
85f4: f0                  ret                    return;

#############################################################
# checksum KAM ISC correction Table 0x7E4-7EA (7EC is csum) 4 words ?
# clear cells to zero if checksum is off by more than 1
# this routine called only at reset
#############################################################

  Check_Kam_2:
85f5: a1,08,00,30         ldw   R30,8            R30 = 8;
85f9: 01,32               clrw  R32              R32 = 0;
# checksum loop
85fb: 67,31,e2,07,32      ad2w  R32,[R30+7e2]    R32 += [R30+Kamqc];               # add words 7E4-7EA
8600: 79,02,30            sb2b  R30,2            R30 -= 2;
8603: d7,f6               jne   85fb             if (R30 != 0) goto 85fb;
#
8605: 4b,01,ec,07,32,34   sb3w  R34,R32,[R0+7ec] R34 = R32+ISKSUM;                # old sum (cksum? )
860b: d6,02               jge   860f             if (R34 < 0)  {
860d: 03,34               negw  R34              R34 = -R34; }
860f: 89,01,00,34         cmpw  R34,1            
8613: d1,0e               jleu  8623             if ((uns) R34 > 1 )  {
# Checksum bad, clear ISCKAM cells
8615: a1,08,00,32         ldw   R32,8            R32 = 8;
8619: a1,e4,07,30         ldw   R30,7e4          R30 = ISCKAM0;
861d: c6,31,00            stb   R0,[R30++]       [R30++] = 0;                      # zero cells
8620: e0,32,fa            djnz  R32,861d         R32--;
                                                 if (R32 != 0) goto 861d; }
# Update ISKSUM
8623: c3,01,ec,07,32      stw   R32,[R0+7ec]     ISKSUM = R32;                    # new csum
8628: f0                  ret                    return;


#############################################################
#  end of routines 
#############################################################


#############################################################
# Initialisation lists
#
# Start of each list has 
# Word 0 - top byte of address for list (bottom byte from each item)
# word 1 - next list START (i.e. end of this list +1)
# then has pairs of bytes -
# byte 0 address  (top byte for list + this byte)
# byte 1 data which is OR'ed into address
#
# addresses are cleared by the loop at 203d
# so this is same as assigning them, except can check result this way
#############################################################



8629: ff                        

862a: 00,00               word      0                                              # high byte address = 0
862c: 50,86               word   8650                                              # next list, and end of this one

862e: ee,04   struct            Flags_ee,  4                                       # start of 1st init list
8630: a1,84   struct            a1_Flags, 84                                       #a1_Flags (CRKFLG=1, UNDSP=1)
8632: 4f,01   struct            Flags_4F, 1                                        #Flags_4F
8634: c1,80   struct            c1, 80                                             #MKAY
8636: 9c,01   struct            ANPIP1, 1                                          #ANPIP1
8638: 9d,01   struct            ANPIP2, 1                                          #ANPIP2
863a: ae,40   struct            N, 40                                              #N = 0x640 = 400rpm
863c: af,06   struct            af, 6                                              #
863e: b0,1e   struct            ECT, 1e                                            #ECT
8640: b1,1e   struct            ACT, 1e                                            #ACT
8642: c2,28   struct            SAF, 28                                            #SAF (10 degrees BTDC)
8644: dc,01   struct            Pip_counter, 1                                     #Pip_counter
8646: d0,ff   struct            APT, -1                                            #APT initialized to closed throttle
8648: c6,01   struct            DOL_COUNT, 1                                       #DOL_COUNT
864a: 46,10   struct            IO_Port_State, 10                                  #IO_Port_State (SCVNT on)
864c: 47,40   struct            Flags_47, 40                                       #Flags_47 (Hi Speed Fan on)
864e: 9b,01   struct            Vsc_count, 1                                       #Vsc_count

8650: 5a,86               word   865a                                              # next list start 
8652: ff,ff               word   ffff                                              # pad?
8654: ff,ff               word   ffff
8656: ff,ff               word   ffff
8658: ff,ff               word   ffff
865a: 00,01               word    100                                              # Addresses + 0x100 for this list
865c: 8e,86               word   868e                                              # start of next list 

865e: 00,c0   struct            TPBAR, c0                                          #TPBAR = 0x5bc0
8660: 01,5b   struct            101, 5b                                            #
8662: 02,c0   struct            EGRBAR, c0                                         #EGRBAR = 0x4cc0
8664: 03,4c   struct            103, 4c                                            #
8666: 04,80   struct            EPTBAR, 80                                         #EPTBAR = 0xa280
8668: 05,a2   struct            105, a2                                            #
866a: 08,40   struct            NBAR, 40                                           #NBAR = 0x640
866c: 09,06   struct            109,  6                                            #
866e: 16,c0   struct            IEVP, c0                                           #EVP = 0x4cc0
8670: 17,4c   struct            117, 4c                                            #
8672: 26,80   struct            RATCH, 80                                          #RATCH = 3e80
8674: 27,3e   struct            127, 3e                                            #
8676: 28,c0   struct            EOFF, c0                                           #EOFF = 4cc0
8678: 29,4c   struct            129, 4c                                            #
867a: 31,d8   struct            Bapbar, d8                                         #Bapbar = d8
867c: 41,08   struct            Secs_ext, 8                                        #Secs_ext = 8
867e: 52,01   struct            RANNUM, 1                                          #RANNUM = 0x2001
8680: 53,20   struct            153, 20                                            #
8682: 69,01   struct            169,  1                                            #LAMMUL = 0x0100
8684: 70,c0   struct            EVP, c0                                            #EVP = 0x4cc0
8686: 71,4c   struct            171, 4c                                            #
8688: 7c,80   struct            CONPR, 80                                          #CONPR = 0xa280
868a: 7d,a2   struct            17d, a2                                            #
868c: fe,d8   struct            BP, d8                                             #BP = d8

868e: 98,86               word   8698                                              # next list
8690: ff,ff               word   ffff                                              # pad?
8692: ff,ff               word   ffff
8694: ff,ff               word   ffff
8696: ff,ff               word   ffff
8698: 00,02               word    200                                              # Addresses + 0x200 for this list
869a: ca,86               word   86ca

869c: 0b,80   struct            20b, 80                                            #
869e: 0d,80   struct            20d, 80                                            #
86a0: 11,c8   struct            VBAT, c8                                           #VBAT
86a2: 16,ff   struct            ACCTMR, ff                                         #ACCTMR = 0ffff
86a4: 17,ff   struct            217, ff                                            #
86a6: 26,99   struct            Htime_beta, 99                                     #Htime_beta = 0x7999
86a8: 27,79   struct            227, 79                                            #
86aa: 2a,80   struct            TBART, 80                                          #TBART
86ac: 2b,3e   struct            SPKADn, 3e                                         #SPKADn
86ae: 3a,22   struct            Dwlbst, 22                                         #Dwlbst = 0x822
86b0: 3b,08   struct            23b, 8                                             #
86b2: 68,01   struct            ENPIP1, 1                                          #ENPIP1
86b4: 69,01   struct            ENPIP2, 1                                          #ENPIP2
86b6: 6a,01   struct            Inj_pip_cnt1, 1                                    #Inj_pip_cnt1
86b8: 6b,01   struct            Inj_pip_cnt2, 1                                    #Inj_pip_cnt2
86ba: bb,ff   struct            TSLMPH, ff                                         #TSLMPH
86bc: b9,0a   struct            VSC_ON_COUNT, a                                    #VSC_ON_COUNT
86be: c5,03   struct            HSOQ, 3                                            #HSOQ
86c0: d4,ff   struct            Q1, ff                                             #Q1
86c2: e0,ff   struct            Q2, ff                                             #Q2
86c4: ea,ff   struct            Q3, ff                                             #Q3
86c6: f4,ff   struct            Q4, ff                                             #Q4
86c8: fe,ff   struct            Q5, ff                                             #Q5

86ca: d4,86               word   86d4                                              # next list
86cc: ff,ff               word   ffff                                              # pad?
86ce: ff,ff               word   ffff
86d0: ff,ff               word   ffff
86d2: ff,ff               word   ffff
86d4: 00,03               word    300                                              # Addresses + 0x300 for this list
86d6: e6,86               word   86e6

86d8: 08,ff   struct            Q6, ff                                             #Q6
86da: 12,ff   struct            Q7, ff                                             #Q7
86dc: 1c,ff   struct            Q8, ff                                             #Q8
86de: 22,ff   struct            Q9, ff                                             #Q9
86e0: c3,19   struct            3c3, 19                                            #High byte of Seq_max
86e2: c0,6c   struct            MNPIP, 6c                                          #MNPIP      - initialized to 0x56c (1388) at startup
86e4: c1,05   struct            3c1, 5                                             #MNPIP high 

86e6: ff,ff               word   ffff                                              # end of all lists


##### 86e8 to 8aff = 0xff (unused) #####

# GUFB.xls Launch Control patch goes here  #

##### 8b00 to 8bff = 0xff (unused) #####



######################### Reg 0xF0 points here (8c00)

8c00: 5a,8e               word   8e5a                                              # pointer to next block (RF2)
8c02: 80,3e               word   3e80            RATIV                             # initial/default value for TPBAR and RATCH, typically 1.25V
8c04: 54,00               word     54            HWRPM                             # Heated Windshield Idle RPM adder
8c06: fa,00               word     fa            A3CTT                             # Heated Windscreen Transition Time Threshold
8c08: e8,03               word    3e8            HWRT                              # Heated Windscreen Recognition Time Threshold
8c0a: 48,01               word    148            SSFCTR                            # Steady State Factor -  Used in MKAY and signature KAY calculations.
#
# Shift light constants
#
8c0c: 60,3b               word   3b60            SPTRPM                            # Shift Indicator Light Timer Enable RPM - SPTRPM
8c0e: 20,4e               word   4e20            SHIRPM                            # Shift Indicator Light RPM -  Shift indicator light is turned on at this rpm regardless of any other condition evaluations. 
8c10: 0c                  byte    c              SLTIM1                            # time before shift light turned on (1/8 sec = 1.5 secs)
8c11: 20                  byte   20              SLTIM2                            # time before shift light turned off (= 4 secs)


## Min PIP periods 4,6,8 cyls - at 6500rpm - (ref 3e67) - see GUFB p. 19-32
# RPM at which the PIP signal is regarded as unreliable. Set slightly higher than Rev Limit Half Fuel On.

8c12: 83,07               word    783            MNPIP4                            # 1923 ticks = 4.615mS - 4 cyl  
8c14: 02,05               word    502            MNPIP6                            # 1282 ticks = 3.076mS - 6 cyl
8c16: c1,03               word    3c1            MNPIP8                            #  961 ticks = 2.306ms - 8 cyl (min pip period, = 6250000/rpm)

# Time between LAMMUL decrements in forward gear - FN393F
  FN393F:
8c18: 7f,19   func               127, 25
8c1a: 23,19   func                35, 25
8c1c: 1e,2d   func                30, 45
8c1e: 80,2d   func              -128, 45
8c20: 80,2d   func              -128, 45
8c22: 80,2d   func              -128, 45
8c24: 80,2d   func              -128, 45

# Time Before Drive - FN394F
  FN394F:
8c26: 7f,03   func               127,  3
8c28: 80,03   func              -128,  3
8c2a: 80,03   func              -128,  3
8c2c: 80,03   func              -128,  3
8c2e: 80,03   func              -128,  3
8c30: 80,03   func              -128,  3
8c32: 80,03   func              -128,  3


# Shift Indicator Light RPM vs ECT - FN651
  Fn651:
8c34: ff,7f,00,00   func         32767,    0
8c38: 55,00,00,00   func            85,    0
8c3c: 41,00,a0,0f   func            65, 4000
8c40: 00,80,a0,0f   func        -32768, 4000
8c44: 00,80,a0,0f   func        -32768, 4000
8c48: 00,80,a0,0f   func        -32768, 4000
8c4c: 00,80,a0,0f   func        -32768, 4000

# Shift Indicator Light RPM vs LOAD - FN652A
  Fn652A:
8c50: ff,ff,80,3e   func        65535,16000
8c54: 9a,59,80,3e   func        22938,16000
8c58: 33,33,10,27   func        13107,10000
8c5c: 9a,19,00,1e   func         6554, 7680
8c60: 00,00,00,1e   func            0, 7680
8c64: 00,00,00,1e   func            0, 7680
8c68: 00,00,00,1e   func            0, 7680
8c6c: 00,00,00,1e   func            0, 7680
8c70: 00,00,00,1e   func            0, 7680
8c74: 00,00,00,1e   func            0, 7680

# BAP Transfer
  FN000:
8c78: ff,ff,d1,f7   func        65535,63441
8c7c: 41,a2,d1,f7   func        41537,63441
8c80: 56,8a,75,b8   func        35414,47221
8c84: d8,74,a3,78   func        29912,30883
8c88: 00,00,a3,78   func            0,30883
8c8c: 00,00,a3,78   func            0,30883

# Startup Fuel Row Scaler for Time
  FN018:
8c90: ff,70   func              255,112
8c92: 2d,70   func               45,112
8c94: 0f,40   func               15, 64
8c96: 0a,30   func               10, 48
8c98: 06,20   func                6, 32
8c9a: 00,00   func                0,  0
8c9c: 00,00   func                0,  0

##### Accel Enrichment Fuel Scaler for Throttle Rate
  FN019B:
8c9e: ff,70   func              255,112
8ca0: f4,70   func              244,112
8ca2: 22,00   func               34,  0
8ca4: 00,00   func                0,  0
8ca6: 00,00   func                0,  0

##### Accel Enrichment Fuel Scaler for ECT/ACT
  FN020B:
8ca8: 7f,60   func               127, 96
8caa: 7d,60   func               125, 96
8cac: e7,00   func               -25,  0
8cae: 80,00   func              -128,  0
8cb0: 80,00   func              -128,  0

################ Func: EEC Load Scaling
# Table - emission load scaling - FN021
# Spark, MAF Backflow Scaler for Load 
# Scale: 256.0 Offset: 0.0 Math: 1
# Scale: 32768.0 Offset: 0.0 Math: 1
# X: Raw Load
# Y: Table Row Pointer
#################

  FN021:
8cb2: ff,ff,00,07   func        65535, 1792
8cb6: 00,60,00,07   func        24576, 1792
8cba: cd,4c,00,06   func        19661, 1536
8cbe: cd,0c,00,01   func         3277,  256
8cc2: 66,06,00,00   func         1638,    0
8cc6: 00,00,00,00   func            0,    0
8cca: 00,00,00,00   func            0,    0
8cce: 00,00,00,00               

# Temp -> Column scale for FN1306 (Startup lambda subtracter), FN1307 (Base fuel)
  FN022B:
8cd2: 7f,90   func               127,144
8cd4: 78,90   func               120,144
8cd6: f1,00   func               -15,  0
8cd8: 80,00   func              -128,  0
8cda: 80,00   func              -128,  0
8cdc: 80,00   func              -128,  0

#################################
# RPM scaling table - FN070(N)
# Spark, Injector Timing, MAF Backflow Scaler for RPM 
# Table 8CDE Engine speed rpm scaler 0-9 for tables
# 4000 RPM up = 9, 3000 RPM = 8, 1500 RPM = 5, 500 RPM = 0
#################################

  FN070:
8cde: ff,ff,00,09   func        65535, 2304
8ce2: 80,3e,00,09   func        16000, 2304
8ce6: e0,2e,00,08   func        12000, 2048
8cea: 70,17,00,05   func         6000, 1280
8cee: d0,07,00,00   func         2000,    0
8cf2: 00,00,00,00   func            0,    0
8cf6: 00,00,00,00   func            0,    0


# Table scaler for LOAD - FN021(N)
  FN021:
8cfa: ff,ff,00,07   func        65535, 1792
8cfe: 00,60,00,07   func        24576, 1792
8d02: cd,4c,00,06   func        19661, 1536
8d06: cd,0c,00,01   func         3277,  256
8d0a: 66,06,00,00   func         1638,    0
8d0e: 00,00,00,00   func            0,    0
8d12: 00,00,00,00   func            0,    0

########## Table - fuel load scaling
# Base Fuel Scaler for LOAD 
  FN072A:
8d16: ff,ff,70,00   func        65535,  112
8d1a: 33,73,70,00   func        29491,  112
8d1e: 9a,59,50,00   func        22938,   80
8d22: 33,33,30,00   func        13107,   48
8d26: 33,13,10,00   func         4915,   16
8d2a: 9a,09,00,00   func         2458,    0
8d2e: 00,00,00,00   func            0,    0

# Fuel & EGR Scaler for LOAD - FN082(LOAD)
  FN082:
8d32: ff,ff,00,02   func        65535,  512
8d36: 8f,42,00,02   func        17039,  512
8d3a: 7b,24,00,01   func         9339,  256
8d3e: ae,17,00,00   func         6062,    0
8d42: 00,00,00,00   func            0,    0

# Fuel & EGR Scaler for RPM - FN083(N)
  FN083:
8d46: ff,ff,00,03   func        65535,  768
8d4a: 40,1f,00,03   func         8000,  768
8d4e: 10,0e,00,00   func         3600,    0
8d52: 00,00,00,00   func            0,    0

# A/C Time Delay vs TP - FN087(TP)
  FN087:
8d56: ff,ff,ff,00   func        65535,  255
8d5a: 00,8c,ff,00   func        35840,  255
8d5e: 00,8c,00,00   func        35840,    0
8d62: 00,00,00,00   func            0,    0
8d66: 00,00,00,00   func            0,    0
8d6a: 00,00,00,00   func            0,    0

# Fuel C/L Ramp Rate - FN339(|BIAS/PTPAMP|)
  FN339:
8d6e: ff,ff   func              255,255
8d70: cd,c8   func              205,200
8d72: 9a,a2   func              154,162
8d74: 58,80   func               88,128
8d76: 00,80   func                0,128

# Fuel C/L Jumpback Bias - FN342(|BIAS/PTPAMP|)
  FN342:
8d78: ff,00   func              255,  0
8d7a: 58,00   func               88,  0
8d7c: 33,22   func               51, 34
8d7e: 1a,40   func               26, 64
8d80: 0a,59   func               10, 89
8d82: 05,65   func                5,101
8d84: 00,80   func                0,128

# Fuel C/L Jump From Bias - FN344(|BIAS/PTPAMP|)
  FN344:
8d86: ff,5b   func              255, 91
8d88: e6,5b   func              230, 91
8d8a: 9a,6e   func              154,110
8d8c: 58,80   func               88,128
8d8e: 00,80   func                0,128

# Ignition Expected Pips Multiplier - FN346(|BIAS/PTPAMP|)
# scaled x 16
  FN346:
8d90: ff,f3   func              255,243
8d92: e6,f3   func              230,243
8d94: cd,7a   func              205,122
8d96: b3,52   func              179, 82
8d98: 9a,3e   func              154, 62
8d9a: 80,32   func              128, 50
8d9c: 57,27   func               87, 39
8d9e: 1a,19   func               26, 25
8da0: 05,14   func                5, 20
8da2: 00,10   func                0, 16
8da4: 00,10   func                0, 16

# Fuel Accel Enrichment vs BP - FN378(BP)
  FN378:
8da6: ff,80   func              255,128
8da8: f0,80   func              240,128
8daa: e0,70   func              224,112
8dac: a0,50   func              160, 80
8dae: 00,40   func                0, 64

############## ECT or ACT A/D to degrees F
# ECT/ACT Transfer -  Input is a rough hi byte only conversion.
  FN703A:
8db0: ff,ec   func              255, -20
8db2: e8,ec   func              232, -20
8db4: e0,fb   func              224,  -5
8db6: d1,0a   func              209,  10
8db8: b8,17   func              184,  23
8dba: 49,43   func               73,  67
8dbc: 25,5a   func               37,  90
8dbe: 14,6f   func               20, 111
8dc0: 0d,7f   func               13, 127
8dc2: 00,7f   func                0, 127


# ISC Adder vs ECT - FN825A
  FN825A:
8dc4: 7f,06   func               127,  6                                           
8dc6: 6e,06   func               110,  6
8dc8: 67,00   func               103,  0
8dca: 5a,00   func                90,  0
8dcc: 50,09   func                80,  9
8dce: 37,09   func                55,  9
8dd0: f3,29   func               -13, 41
8dd2: 80,29   func              -128, 41

# ISC Adder vs ACT - FN825B
  FN825B:
8dd4: 7f,09   func               127,  9                                          
8dd6: 71,09   func               113,  9
8dd8: 64,06   func               100,  6
8dda: 58,00   func                88,  0
8ddc: 80,00   func              -128,  0
8dde: 80,00   func              -128,  0
8de0: 80,00   func              -128,  0

#############################################################
# Func: MAF Transfer function (volts => Kg per hr)
# Scale: 4.0 Offset: 0.0 Math: 1
# Scale: 4096.0 Offset: 0.0 Math: 1
# X: MAF Voltage
# Y: Mass Flow Kg/hr MAF Transfer - FN036
#############################################################
  FN036:
8de2: ff,ff,4d,0a   func        65535, 2637
8de6: 4a,4c,4d,0a   func        19530, 2637
8dea: 17,47,93,08   func        18199, 2195
8dee: d5,42,59,07   func        17109, 1881
8df2: 2d,3e,29,06   func        15917, 1577
8df6: b4,38,ec,04   func        14516, 1260
8dfa: ae,35,49,04   func        13742, 1097
8dfe: 62,32,a5,03   func        12898,  933
8e02: 8f,2e,00,03   func        11919,  768
8e06: 1b,2b,7d,02   func        11035,  637
8e0a: 50,29,40,02   func        10576,  576
8e0e: 33,27,fd,01   func        10035,  509
8e12: 0e,25,c1,01   func         9486,  449
8e16: 77,22,7b,01   func         8823,  379
8e1a: d3,1f,3c,01   func         8147,  316
8e1e: 3d,1e,1d,01   func         7741,  285
8e22: d9,1c,04,01   func         7385,  260
8e26: 0e,1b,e6,00   func         6926,  230
8e2a: 2f,19,c5,00   func         6447,  197
8e2e: 7d,17,ab,00   func         6013,  171
8e32: 23,15,8d,00   func         5411,  141
8e36: e9,12,74,00   func         4841,  116
8e3a: 75,11,67,00   func         4469,  103
8e3e: 25,0e,4b,00   func         3621,   75
8e42: 00,0c,3b,00   func         3072,   59
8e46: 23,09,2b,00   func         2339,   43
8e4a: 00,00,2b,00   func            0,   43
8e4e: 00,00,2b,00   func            0,   43
8e52: 00,00,2b,00   func            0,   43
8e56: 00,00,2b,00   func            0,   43

################################################### RF2 points here (8e5a)


8e5a: d6,8f               word   8fd6                                              # next register value (RF4)

8e5c: 00                  byte    0              Bfulsw

8e5d: ff                        

#
# Signature Kay constants
# GUFB p. 7-19
#
8e5e: 00,20               word   2000            FKSKAY                            # Filter constant of update rate to SIGKAL (= .005)
8e60: 00,a0               word   a000            SIGKLL                            # Lowest value for signature PIP multiplier (= 1.25)
8e62: 55,d5               word   d555            SIGKLU                            # Highest value for signature PIP multiplier (= 1.6666)
#
# Supercharger bypass constants
# GUFB p. 12-11
#
8e64: 00,83               word   8300            THBPSC                            # Min delta from RATCH to enable supercharger bypass
8e66: 00,06               word    600            THBPSH                            # Hysteresis for above
#
# Inlet Air Control constants
# GUFB p. 12-10
#
8e68: 20,4e               word   4e20            Niac                              # Min RPM to open inlet air control
8e6a: d0,07               word    7d0            Niach                             # Hysteresis for above

#
# Vehicle Speed Control (VSC) and Vehicle Speed Control Command Switches (VSCCS) parameters
#
8e6c: 80,0c               word    c80            DEBAMP                            # Minimum IVSCCS amplitude change, A/D counts
8e6e: 00,0c               word    c00            HI_OFF                            # Max VSCCS input for OFF button, A/D counts
8e70: 00,e6               word   e600            LOW_ON                            # Min VSCCS input for ON button, A/D counts
8e72: c0,0c               word    cc0            LCOAST                            # Min VSCCS input range for COAST button, A/D counts
8e74: 80,2f               word   2f80            HCOAST                            # Max VSCCS input range for COAST button, A/D counts
8e76: 40,38               word   3840            LACCEL                            # Min VSCCS input range for ACCEL button, A/D counts
8e78: 00,5d               word   5d00            HACCEL                            # Max VSCCS input range for ACCEL button, A/D counts
8e7a: 80,62               word   6280            LRESUM                            # Min VSCCS input range for RESUME button, A/D counts
8e7c: c0,91               word   91c0            HRESUM                            # Max VSCCS input range for RESUME button, A/D counts
8e7e: 40,92               word   9240            LOHOLD                            # Min VSCCS input range for HOLD button, A/D counts
8e80: 00,c7               word   c700            HIHOLD                            # Max VSCCS input range for HOLD button, A/D counts
8e82: 91,01               word    191            DCBIAS                            # VSC DC correction factor
8e84: b8,1e               word   1eb8            SETGN                             # SET_SPEED proportional gain
8e86: cd,2c               word   2ccd            VEHGN                             # Vehicle Speed proportional gain
8e88: c3,04               word    4c3            TAPGN                             # Throttle Position proportional gain
8e8a: 29,00               word     29            DEBTIM                            # SCCS debounce time, msec
8e8c: 00,32               word   3200            MINVSP                            # Minimum vehicle speed to enable VSC, MPH
8e8e: 00,c8               word   c800            MAXVSP                            # Maximum ""
8e90: 80,57               word   5780            VSNMAX                            # Maximum RPM for VSC
8e92: 00,14               word   1400            MPHDED                            # Deadband for VSC, MPH
8e94: 00,02               word    200            MPHH                              # Hysteresis term for aove
8e96: 00,06               word    600            ACLDED                            # Maximum increment above MPH to which SET_SPEED can increase, mph
8e98: 00,03               word    300            ACLINC                            # Acceleration ramp rate, MPH/sec.
8e9a: 00,01               word    100            HLDREF                            # Offset for VSC duty cycle

8e9c: fe                  byte   fe              VSMPG                             # MFA MPH Min - Minimum speed to remain in MFA mode.
8e9d: 0a                  byte    a              VSMPGH                            # MFA MPH Hysteresis - VSMPGH
8e9e: 26                  byte   26              HLDRNG                            # VSC Error Deadband for no pulses required
8e9f: b0                  byte   b0              LOWBAT                            # VSCCS Low Battery threshold
8ea0: 32                  byte   32              VSCFRQ                            # VSC PWM Frequency, Hz
8ea1: 01                  byte    1              VSTYPE                            # MPH Sensor Present -
                                                                                   #  0 = no sensor
                                                                                   #  1 = mph sensor
                                                                                   #  2 = mph sensor and cruise control
8ea2: 0d                  byte    d              DASMPH                            # ISC Dashpot Min MPH - DASMPH
8ea3: 04                  byte    4              DASMHYST                          # ISC Dashpot Hysteresis For MPH - DASMHYST

8ea4: 80,01               word    180            DASMIN                            # ISC Min DASPOT Clip For Declutch - DASMIN

8ea6: 03                  byte    3              MFMHYS                            # Managed Failure Mode Hysteresis - MFMHYS
8ea7: 01                  byte    1              Vairfl
8ea8: 01                  byte    1              Vtabfl

8ea9: ff                        

8eaa: 78,00               word     78            Vipspk                            # VIP Spark
8eac: 00,32               word   3200            Vkypwr
8eae: 66,06               word    666            Viprr1
8eb0: 33,03               word    333            Viplr1
8eb2: 10,0e               word    e10            Vnmin                             # HEGO Test Min RPM


  VDLY8:
8eb4: 00,ff               ??    

8eb6: 00,19               word   1900            Vtap1                             # VTAP1 - VTAP1
8eb8: 80,3e               word   3e80            Vtap2                             # VTAP2 - VTAP2
8eba: 00,19               word   1900            Vtap3                             # VTAP3 - VTAP3
8ebc: 80,3e               word   3e80            Vtap4                             # VTAP4 - VTAP4
8ebe: 00,64               word   6400            Vtap5                             # VTAP5 - VTAP5
8ec0: 80,57               word   5780            Vtap6
8ec2: 00,0a               word    a00            ACTMIN                            # ACT min  (checked in 38A1 and 7XXX)
8ec4: c0,e9               word   e9c0            ACTMAX                            # ACT max

8ec6: 3c                  byte   3c              VECT5                             # Maximum TCSTRT for WARM_UP (GUFB p. 28-8)

8ec7: ff                        

8ec8: 80,f7               word   f780            TAPMAX                            # TPS Max - TAPMAX
8eca: 00,0a               word    a00            TAPMIN                            # TPS Min - TAPMIN

8ecc: c8                  byte   c8              WIGLVL                            # Threshold for wiggle test
8ecd: 01                  byte    1              V_FPMFLG                          # 1 = enable fuel pump self test

8ece: 10,08               word    810            V_fpmdly

8ed0: 10                  byte   10              VIDMST                            # VIDMST 

8ed1: ff                        

8ed2: 82,00               word     82            VIDMTM
8ed4: d0,07               word    7d0            VLORPM
8ed6: 5a,00               word     5a            VPIPTM
8ed8: 00,0a               word    a00            ECTMIN                            # ECT min # ECT range low

################################################### R78 points here (8eda)
#
# Self-test constants
#
###################################################
8eda: c0,e9               word   e9c0            ECTMAX                            # ECT range high # ECT max 
8edc: 00,05               word    500            Vtcego

8ede: 78                  byte   78              Goosec                            # Goose C


  Goosmp:
8edf: 50                  byte   50              Goosmp                            # Not used
8ee0: 40,06               word    640            Goosn                             # Goose RPM
8ee2: a8,00               word     a8            Goospk                            # Goose spark
8ee4: 00,32               word   3200            Goostp                            # Goose TP - Min throttle voltage delta for goose.

8ee6: 00                  byte    0              Goosw
8ee7: 14                  byte   14              Vkts
8ee8: 00                  byte    0              Vdisfm

8ee9: ff                        

8eea: 00,0b               word    b00            VTCDSN                            # Self test idle speed ramp down time (if 0, default to TCDESN)

8eec: 01                  byte    1              Vbisw                             # VBISW

8eed: ff                        

8eee: 7b,04               word    47b            Vcbclp
8ef0: 48,01               word    148            Vcbpad
8ef2: ec,01               word    1ec            Vcbpct                            # VCBPCT
8ef4: 33,73               word   7333            Vlamcb
8ef6: c2,00               word     c2            Viscn1
8ef8: b0,01               word    1b0            Vcbdly                            # VCBDLY
8efa: 30,30               word   3030            Visdl4
8efc: 18,18               word   1818            Vcbtm1
8efe: 01                  byte    1              VEGOBP                            # 

8eff: 08                  byte    8              VEGOSW                            # VIP # of EGO Switch Required
8f00: f0                  byte   f0              VEGOTM                            # VIP EGO Time since engine warm, sec
8f01: 0a                  byte    a              Vptcnt                            # VPTCNT -
8f02: 10                  byte   10              VECTMR
8f03: 6d                  byte   6d              VCRTDC
8f04: 09                  byte    9              Vegrat
8f05: 20                  byte   20              Vdcmin
8f06: 6d                  byte   6d              Vdcmax

8f07: ff                        

8f08: cd,2c               word   2ccd            VEGRLOAD
8f0a: 00,0a               word    a00            EVPMIN                            # EVP min error threshold
8f0c: 40,f6               word   f640            EVPMAX                            # EVP max ""    ""
8f0e: 00,0f               word    f00            VEVPLL                            # EVP self test lower limit
8f10: 80,22               word   2280            VEVPHL                            # EVP self test upper limit
8f12: 00,14               word   1400            Vevpdl
8f14: 00,28               word   2800            VEVPCL

8f16: 10                  byte   10              VEITMR

8f17: 10,10               word   1010            Vdledf
8f19: 50                  byte   50              Vlfntm

8f1a: 78                  byte   78              Vhfntm

#
# Fault count threshold tables
# 

8f1b: c8                  byte   c8              C14LVL                            # Error 14 threshold - Erratic PIP
8f1c: c8                  byte   c8              C22LVL                            # Error 22 threshold - BP out of range
8f1d: fe                  byte   fe              C29LVL                            # Error 29 threshold - VSS failure
8f1e: c8                  byte   c8              C31LVL                            # Error 31 threshold - EPT/EVP below min
8f1f: fe                  byte   fe              C32LVL                            # Error 32 threshold - EPT/EVP low in self test
8f20: c8                  byte   c8              C33LVL                            # Error 33 threshold - No EGR flow observed
8f21: fe                  byte   fe              C34LVL                            # Error 34 threshold - EPT/EVP high in self test
8f22: c8                  byte   c8              C35LVL                            # Error 35 threshold - EPT/EVP above max
8f23: c8                  byte   c8              C41LVL                            # Error 41 threshold - Lack of HEGO #1 switching
8f24: c8                  byte   c8              C51LVL                            # Error 51 threshold - ECT high
8f25: c8                  byte   c8              C53LVL                            # Error 53 threshold - TP high
8f26: c8                  byte   c8              C54LVL                            # Error 54 threshold - ACT high
8f27: c8                  byte   c8              C56LVL                            # Error 56 threshold - MAF short to power
8f28: c8                  byte   c8              C61LVL                            # Error 61 threshold - ECT low
8f29: c8                  byte   c8              C63LVL                            # Error 63 threshold - TP low
8f2a: c8                  byte   c8              C64LVL                            # Error 64 threshold - ACT low
8f2b: c8                  byte   c8              C66LVL                            # Error 66 threshold - MAF open
8f2c: c8                  byte   c8              C87LVL                            # Error 87 Threshold - Fuel pump relay
8f2d: c8                  byte   c8              C91LVL                            # Error 91 Threshold - Lack of HEGO #2 switching.
8f2e: c8                  byte   c8              C95LVL                            # Error 95 Threshold - Fuel pump circuit
8f2f: c8                  byte   c8              C96LVL                            # Error 96 Threshold - Fuel pump circuit
8f30: c8                  byte   c8              IDMLVL                            # IDM fault (code #18?)

#
# Fault upcount tables
#

  C14UP:
8F31: c8,64,64,0a,64,14 ??                                                         # Error 22 Up Count -  BAP sensor out of range.

  C33UP:
8f36: 0a,14,64,64,64,64,64,14 ??                                                   # Error 35 Up Count -  EVP input high

  C61UP:
8f3e: 64,64,64,14,ff,64,64,64 ??                                                   # Error 61 Up Count -  ECT low
                                                                                   # Error 91 Up Count -  Lack of left HEGO switching.
                                                                                   # Error 95 Up Count -  Fuel pump open circuit

  Idmup:
8f46: 32,ff               ??    

8f48: 40,b3               word   b340            Viact1
8f4a: c0,0f               word    fc0            Viact2
8f4c: 40,be               word   be40            Viact3
8f4e: c0,0f               word    fc0            Viact4
8f50: 40,b3               word   b340            Viect1
8f52: c0,0f               word    fc0            Viect2
8f54: c0,3a               word   3ac0            Viect3
8f56: c0,0f               word    fc0            Viect4

8f58: 4b                  byte   4b              VECT3                             # ECT WARM_UP threshold for updating KAM counters
8f59: 05                  byte    5              Filhys

8f5a: 33,73               word   7333            Vrlam2
8f5c: b0,04               word    4b0            VBPDL1                            # Maximum BAP interval, in ticks
8f5e: f7,06               word    6f7            VBPDL2                            # Minimum ""  ""      , "" ""
8f60: 28,00               word     28            VMAFPIPLMT                        # Max time since last PIP for MAF test, msec
8f62: 00,2d               word   2d00            Vmafo1
8f64: 40,1f               word   1f40            Vmafr1
8f66: c0,5d               word   5dc0            Vmafr2
8f68: 00,f5               word   f500            VMAMAX                            # max MAF voltage (mass air max) = 4.785 V
8f6a: c0,12               word   12c0            VMAMIN                            # min MAF voltage (mass air min) = 0.356 V
8f6c: 50,46               word   4650            VMARPM                            # Max RPM (4500) for MAF Max Voltage Test 
8f6e: cd,0c               word    ccd            VSLOAD                            # Max decel load for M/T VSS test

8f70: 9a                  byte   9a              VBPMAX                            # Maximum BP sensor interval, msec

8f71: ff                        

8f72: 00,00               word      0            FMDTM                             # MIL Delay Time. delay before turning light on after fault detected.
8f74: 08,00               word      8            MILLIM                            # 0 = don't turn on MIL during crank
8f76: 00,00               word      0            MILTM1                            # MIL Freq.  The light will flash at frequency =  1 / (2 * MILTM1).


  Vnd1:
8f78: 00,00,00,80,80,07,80,07 ?? 
# next limits are the min that Output Circuit Check needs to see when line toggles, else circuit is faulty
# AM1 Output Circuit Check.
# AM2 Output Circuit Check.

  Occdt3:
8f80: 00,00,80,07,80,07,80,07 ??                                                   # High Speed Fan Output Circuit Check.
                                                                                   # EVR Output Circuit Check.
                                                                                   # Canister Purge Output Circuit Check.
                                                                                   # Fuel Pump Output Circuit Check.

  Occdt8:
8f88: 00,00,40,06,40,06   ??                                                       # Low Speed Fan Output Circuit Check.
                                                                                   # SCVNT Output Circuit Check.


#
# EPT SELF-TEST PARAMETERS
#

8f8e: 00,0a               word    a00            Eptmin                            # Minimum EPT reading
8f90: 40,f6               word   f640            Eptmax                            # Maximum EPT reading
8f92: 80,98               word   9880            VEPTLL                            # Self-Test EPT lower limit, engine off
8f94: 00,b4               word   b400            VEPTHL                            # Self-Test EPT upper limit, engine off
8f96: c0,99               word   99c0            VEPTRL                            # Self-Test EPT lower limit, engine runing
8f98: 80,d4               word   d480            VEPTRH                            # Self-Test EPT upper limit, engine running
8f9a: 40,97               word   9740            VEPTIL                            # Self-Test EPT lower limit at idle
8f9c: 80,d4               word   d480            VEPTIH                            # Self-Test EPT upper limit at idle
8f9e: 00,14               word   1400            VEPTDL                            # Self-Test EPT lower limit
8fa0: 00,96               word   9600            VEPTCL                            # Self-test EPT lower limit
8fa2: a0,0f               word    fa0            VN                                # Max Idle RPM for EPT Test
8fa4: 1a,00               word     1a            VTCEPT                            # Filter time constant for EPT Test


8fa6: 00                  byte    0              VPSSW                             # Power Steering Pressure Switch Test Enable

8fa7: ff                        

#
# SPOUT SELF-TEST PARAMETERS
#

8fa8: 58,02               word    258            Vsprpm                            # Minimum RPM to pass SPOUT test
8faa: 78,00               word     78            Vspadv                            # Advanced spark for SPOUT test
8fac: 14,00               word     14            Vspret                            # Retarded spark for SPOUT test
8fae: 01                  byte    1              Vspten                            # SPOUT test enable switch
8faf: 28                  byte   28              Vsptdl                            # Minimum stabilized time for SPOUT test

#
# THERMACTOR SELF-TEST PARAMETERS
#

8fb0: 08                  byte    8              VDLY1
8fb1: 18                  byte   18              VDLY2                             # Time to delay before dump/upstream air
8fb2: 50                  byte   50              VIPTM2
8fb3: 50                  byte   50              VATMR2                            # Time to wait before downstream air test
8fb4: e5,00               word     e5            VSTGN
8fb6: e5,00               word     e5            VVHGN
8fb8: 8f,02               word    28f            VTPGN
8fba: 00,06               word    600            VRSH
8fbc: 00,78               word   7800            VRSS
8fbe: 9a,04               word    49a            VACRR

#
# VSC SELF-TEST PARAMETERS
#

8fc0: a0                  byte   a0              VIPT1
8fc1: a0                  byte   a0              VIPT2                             # Maximum ramp time VSC test
8fc2: 50                  byte   50              VIPT3
8fc3: 78                  byte   78              VDLY10                            # Delay before starting speed ramp
8fc4: 18                  byte   18              VDLY11                            # Delay after speed ramp
8fc5: ff

8fc6: 00,05               word    500            Vtpld                             # Minimum TP gain for VSC test
8fc8: 00,05               word    500            Vtplu                             # Maximum TP gain for VSC test
8fca: 26,01               word    126            Vdcbia                            # Vehicle speed DC bias
8fcc: f0                  byte   f0              VVSCET                            # Maximum time in VSC test, time units unclear

#
# VSS SELF-TEST PARAMETERS
#

8fcd: 38                  byte   38              Vsmapl                            # Max decel MAP to do VSS test with manual trans
8fce: 60,22               word   2260            VSAMIN                            # Minimum RPM (x4) to do VSS test with automatic trans
8fd0: 70,17               word   1770            VSMMIN                            # Minimum RPM (x4) to do VSS test with manual trans
8fd2: 0a                  byte    a              VSSMN1                            # Minimum vehicle speed to pass VSS test
8fd3: 01                  byte    1              Vsssw                             # VSS test enable switch
8fd4: 18                  byte   18              VSSTIM                            # Minimum stabilized time before VSS test (1/8 secs)

8fd5: ff                        

############## RF4 points here (8fd6) #####################################

8fd6: a8,93               word   93a8

8fd8: 4b                  byte   4b              MFATM3
8fd9: bd                  byte   bd              MFATM2
8fda: 00                  byte    0              MFATM5
8fdb: 00                  byte    0              MFATM1
8fdc: bd                  byte   bd              MFATM4

8fdd: 01                  byte    1              MFASW                             # Allow MFA fuel economy mode strategy if set.
8fde: 00                  byte    0              CINTSW                            # Enable Special Injector Timing In Neutral
8fdf: 74                  byte   74              CINTV                             # Injector Timing Value in Neutral
8fe0: 7f                  byte   7f              CTHIN                             # Maximum ECT at cold start to use NUMPR.
8fe1: 7b                  byte   7b              NUMPR                             # O/L Fuel Startup Neutral Multiplier
8fe2: 26                  byte   26              OLMTD1                            # O/L Fuel Multiplier Time Delay, Sec.
8fe3: ff                  byte   ff              AGB                               # Decel Fuel Shut Off Min Time Delay After Startup, Sec.
#
# Managed Fuel Air Strategy Constants
#
8fe4: c0,5d               word   5dc0            MFANLO                            # MFA State Min RPM
8fe6: e8,1c               word   1ce8            MFANHI                            # MFA State Max RPM
8fe8: 90,01               word    190            MFASN                             # MFA State Constant RPM Entry Condition
8fea: 00,80               word   8000            MFALH                             # MFA State Max Load Condition
8fec: 64                  byte   64              SWTCNT                            # MFA State EGO Switch Requirement

8fed: ff                        

8fee: 20,03               word    320            MFANHH                            # MFA State Max RPM Hysteresis
8ff0: 90,01               word    190            MFANLH                            # MFA State Min RPM Hysteresis
8ff2: 00,80               word   8000            MFALL                             # MFA State Min Load
8ff4: 66,66               word   6666            MFALHH                            # MFA State Max Load Condition Hysteresis
8ff6: d0                  byte   d0              MPMNBP                            # MFA Min BP for Fuel Economy Mode
8ff7: 0a                  byte    a              MPNBPH                            # MFA Min BP for Fuel Economy Hysteresis
8ff8: 0d                  byte    d              MFARMP                            # MFA Ramp Increment

8ff9: ff                        

#
# Injector timing constants
#
8ffa: 01,00               word      1            INJREF                            # Injection Timing Pulse Edge -
                                                                                   #  0 = Use rising edge, 1 = Use falling edge
8ffc: 00,80               word   8000            IDKMUL                            # Injector delay timing multiplier
8ffe: 00,00               word      0            IDKADD                            # Injector delay timing global adder

9000: 00                  byte    0              ALPHA                             # Transient fuel proportioning between ACT, ECT
                                                                                   #  0 = ECT to 0x7F = ACT
9001: ff                        

9002: 33,00               word     33            AEM                               # Accelerator enrichment fuel multiplier


  Aeflag:
9004: 01,ff               ??    

9006: c0,ff               word   ffc0            TPDLTA                            # Minimum TP change that indicates throttle plate movement.
9008: df,ff               word   ffdf            AEACLD                            # Delta Load for Intake Manifold Filling

900a: 14                  byte   14              AETAR                             # Fuel Transient minimum throttle angle rate
900b: 00                  byte    0              FRCTAE                            # Fuel Transient ACT/ECT proportioning factor
900c: 4d                  byte   4d              Kft                               # Fuel Transient Comp Multiplier

900d: ff                        

#
# Transient Fuel Calibration Constants
#

900e: 20,03               word    320            TFSMN                             # Transient Fuel Deadband Above Idle during Dashpot Mode

9010: 03                  byte    3              TFCTM                             # Transient Fuel Time Delay After Start, sec.
9011: 02                  byte    2              MTEISF                            # Transient Fuel Equilib Intake Surf Multiplier
9012: 10                  byte   10              MTEFTC                            # Transient Fuel Time Constant Multiplier
9013: 01                  byte    1              TFCISW                            # Transient Fuel Compensation Initialization Switch
9014: 9a                  byte   9a              MEFTRA                            # Transient Fuel Accel Multiplier
9015: 80                  byte   80              MEFTRD                            # Transient Fuel Decel Multiplier

9016: 1a,00               word     1a            TFCDED                            # Transient Fuel deadband, percent



9018: 00,00               word      0            ARCHLK                            # Intake airflow mass leakage rate
901a: 4a,1b               word   1b4a            SARCHG                            # "Engine displacement" 1B4A = 6986 (unit = 0.0430981 Cubic Inches)
                                                                                   # Actually the standard air mass of one cylinder's displacement.
                                                                                   #  GUFB documents it as 4.4256e-5 lb/in^3 + (CID/NUMCYL).
                                                                                   #  Scale factor is 238.8e-9 lbs/LSB, or 108.3e-6 g/LSB.
901c: 64,3b               word   3b64            ALOSL                             # low injector slope (unit = 0.00171662 lbs/hr)
901e: b2,2c               word   2cb2            AHISL                             # high injector slope (unit = 0.00171662 lbs/hr)
9020: 00,00               word      0            FAMINC                            # Filtered Air Mass Increment/Decrement
9022: 7e,00               word     7e            KPSINU                            # ISC Gain For Underspeed in Neutral. 
9024: 7e,00               word     7e            KPSIND                            # ISC Gain For Overspeed in Neutral. 
9026: 7e,00               word     7e            KPSIDU                            # ISC Gain For Underspeed in Drive. 
9028: 7e,00               word     7e            KPSIDD                            # ISC Gain For Overspeed in Drive. 
902a: 66,06               word    666            PSIBRM                            # Maximum allowed value for IPSIBR.
902c: 9a,f9               word   f99a            PSIBRN                            # Minimum allowed value for IPSIBR.
902e: cd,08               word    8cd            ITHBMA                            # Throttle Body Air Flow
9030: cd,00               word     cd            DEBYCP                            # ISC Min Airflow 
9032: c3,f5               word   f5c3            DASPTK                            # ISC Gain Associated With The Desired DASPOT Airflow
9034: cd,00               word     cd            DASPTO                            # ISC Offset term applied to the DASPOT calculation
9036: 40,03               word    340            DELHYS                            # ISC Dashpot TP Closed Hysteresis
9038: 58,02               word    258            RPMCTL                            # ISC RPM Control Adder - max delta above DSDRPM to enable idle rpm C/L rpm control
903a: f0,0f               word    ff0            NDIF                              # ISC RPM Deviation Allowed Over ISC Time

903c: 08                  byte    8              MINMPH                            # ISC Min Speed To Enter C/L RPM Control

903d: ff                        

903e: 64,00               word     64            RPMDED                            # ISC RPM Deadband
9040: 40,03               word    340            DELRAT                            # Filtered Air Mass threshold above RATCH

9042: 02                  byte    2              SAMRAT                            # Airmass Filter Sample Rate, in background loops
9043: 04                  byte    4              ISCTM                             # ISC Time Interval The Change In RPM Is Evaluated
9044: 00                  byte    0              LOWLOD                            # LOAD value which indicates decel - should be below normal idle load
9045: 00                  byte    0              ACLOD                             # A/C On Load Adder to LOWLOD
9046: 01                  byte    1              UPDISC                            # Time that engine speed must be within RPMDED prior to KAM update, sec.
9047: 03                  byte    3              UPDATM                            # ISC KAM Update Rate, background loop counts.
9048: ff                  byte   ff              NIOLD                             # Neutral idle open loop delay (time in closed loop control before going open loop, secs)
9049: 02                  byte    2              NIHYS                             # Hysteresis term for NIOLD

904a: 54,00               word     54            NUBASE                            # Base Idle Speed (target) in Neutral (672rpm) before additions
904c: 54,00               word     54            DRBASE                            # Base Idle Speed (target) in Drive (672rpm) before additions
904e: 08,00               word      8            BZZRPM                            # Buzz RPM -  Added at start up to idle rpm to clear engine.
9050: 03,00               word      3            DNAC                              # Idle RPM Adder For A/C
9052: 67,00               word     67            ISCLPD                            # Drive Idle RPM GPAS Clip Limit
9054: 8f,02               word    28f            FAMLIM                            # Multiplier for FAM deadband
9056: 00,a0               word   a000            MAXFAM                            # Difference between FAM & AMPEM at idle
9058: 00,00               word      0            NDPPM                             # FAM Neutral To Drive transition adder
905a: 00,00               word      0            DNPPM                             # FAM Drive To Neutral transition subtracter
905c: 66,00               word     66            ACPPM                             # DESMAF/FAM A/C-on transition adder
905e: 66,00               word     66            DACPPM                            # FAM A/C-off transition subtracter
9060: 00,00               word      0            PSPPM                             # DESMAF/FAM P/S-on transition adder
9062: 28,00               word     28            DACTM                             # Delay to turn off A/C idle adder
9064: 00,00               word      0            DNPOWS                            # Idle Speed delta for P/S load (not used in A9L)

9066: 19                  byte   19              TKDTM                             # ISC Startup Kickdown Time, sec
9067: 50                  byte   50              BZZTM                             # Buzz RPM Time - Duration that Buzz rpm is added to base target idle rpm at startup.
9068: 00                  byte    0              NDDELT                            # Time Before N/D or D/N Switch Registers


# MFA Fuel Table - Lambda multiplier for lean cruise - FN1328(N,PERLOAD)
  FN1328:
9069: 80,80,80,80,80,80,80,80,80,80   table 128,128,128,128,128,128,128,128,128,128
9073: 80,80,80,80,80,80,80,80,80,80   table 128,128,128,128,128,128,128,128,128,128
907d: 80,80,80,80,80,80,80,80,80,80   table 128,128,128,128,128,128,128,128,128,128
9087: 80,80,80,80,80,80,80,80,80,80   table 128,128,128,128,128,128,128,128,128,128
9091: 80,80,80,80,80,80,80,80,80,80   table 128,128,128,128,128,128,128,128,128,128
909b: 80,80,80,80,80,80,80,80,80,80   table 128,128,128,128,128,128,128,128,128,128
90a5: 80,80,80,80,80,80,80,80,80,80   table 128,128,128,128,128,128,128,128,128,128
90af: 80,80,80,80,80,80,80,80,80,80   table 128,128,128,128,128,128,128,128,128,128

# MFA Altitude Fuel Multiplier vs BP - FN311
  FN311:
90b9: ff,80   func              255,128
90bb: e0,80   func              224,128
90bd: b0,00   func              176,  0
90bf: 00,00   func                0,  0
90c1: 00,00   func                0,  0

90c3: 00                  byte    0

90c4: 00,ff               ??                                                       # TP Scaler for MAF Failure 


  FN098:
90c6: ff,ff,00,06   func        65535, 1536
90ca: 00,7d,00,06   func        32000, 1536
90ce: 00,19,00,02   func         6400,  512
90d2: 00,00,00,00   func            0,    0
90d6: 00,00,00,00   func            0,    0
90da: 00,00,00,00   func            0,    0
90de: 00,00,00,00   func            0,    0

# Failed Mass Air Flow Sensor - FN040(N)
#  -  Substitution air mass value used if both the MAF and TP sensors have failed.
  FN040:
90e2: ff,ff,37,1a   func        65535, 6711
90e6: 80,3e,37,1a   func        16000, 6711
90ea: 10,27,f0,16   func        10000, 5872
90ee: 40,1f,a9,13   func         8000, 5033
90f2: 70,17,6b,0e   func         6000, 3691
90f6: 30,11,d5,09   func         4400, 2517
90fa: 10,0e,8e,06   func         3600, 1678
90fe: 00,00,f6,0d   func            0, 3574

# Failed Mass Air Flow Sensor (TP OK) - FN1358(N,TP)
# -  Substitution air mass value used if the MAF sensor has failed and the TP sensor is ok.
  FN1358:
9102: 1a,15,0a,0a,0a,09,08,07,06,06   table  26, 21, 10, 10, 10,  9,  8,  7,  6,  6
910c: 44,41,3a,2f,22,19,13,11,0f,0e   table  68, 65, 58, 47, 34, 25, 19, 17, 15, 14
9116: 58,57,55,51,4b,42,32,28,1d,19   table  88, 87, 85, 81, 75, 66, 50, 40, 29, 25
9120: 60,64,68,69,6a,69,64,5a,4b,3e   table  96,100,104,105,106,105,100, 90, 75, 62
912a: 62,69,6b,6d,6e,6f,71,72,71,6f   table  98,105,107,109,110,111,113,114,113,111
9134: 64,6a,6d,70,72,75,77,7d,90,90   table 100,106,109,112,114,117,119,125,144,144
913e: 83,88,8c,90,93,94,9d,aa,df,df   table 131,136,140,144,147,148,157,170,223,223

# Injector Timing Scaler for LOAD - FN085(LOAD)
  FN085:
9148: ff,ff,70,00   func        65535,  112
914c: 00,60,70,00   func        24576,  112
9150: cd,4c,60,00   func        19661,   96
9154: cd,0c,10,00   func         3277,   16
9158: 66,06,00,00   func         1638,    0
915c: 00,00,00,00   func            0,    0


# Injector Timing - FN1315(N,LOAD)
# 10 Cols: Speed [RPM] 500,700,900,1100,1300,1500,2000,2500,3000,4000
#  8 Rows: LOAD []   .05,.15,.23,.30,.40,.50,.60,.75
#  - injector timing (global injector delay in crank degrees)  
  FN1315:
9160: 58,58,58,58,58,58,58,58,58,58   table  88, 88, 88, 88, 88, 88, 88, 88, 88, 88
916a: 58,58,58,58,58,58,58,58,58,58   table  88, 88, 88, 88, 88, 88, 88, 88, 88, 88
9174: 58,58,58,58,58,58,58,58,58,58   table  88, 88, 88, 88, 88, 88, 88, 88, 88, 88
917e: 58,58,58,58,58,58,58,58,58,58   table  88, 88, 88, 88, 88, 88, 88, 88, 88, 88
9188: 58,58,58,58,58,5f,64,64,64,64   table  88, 88, 88, 88, 88, 95,100,100,100,100
9192: 5f,5f,5f,5f,5f,5f,69,69,74,74   table  95, 95, 95, 95, 95, 95,105,105,116,116
919c: 69,69,69,69,69,69,69,74,74,74   table 105,105,105,105,105,105,105,116,116,116
91a6: 69,69,69,69,69,69,69,74,74,74   table 105,105,105,105,105,105,105,116,116,116


# Injector Bank - FN1327(cyl#)
# Cylinder # starts from 1
  FN1327:
91b0: 00,00,00,00,00,02,02,02,02,01   table   0,  0,  0,  0,  0,  2,  2,  2,  2


# Injector Firing Order - FN1329(seq#)
  FN1329:
91b9: 01,03,07,02,06,05,04,08         table   1,  3,  7,  2,  6,  5,  4,  8


# Func: Accelerator Enrichment Multiplier vs TPS (accelerator enrichment vs TP voltage) - FN331B(TPS)
  FN331B:
91c1: ff,00                     func 255,   0
91c3: d5,00                     func 213,   0
91c5: 71,26                     func 113,  38
91c7: 32,7a                     func  50, 122
91c9: 00,80                     func   0, 128


# Accel Enrichment Fuel (lbs/min)- FN1303
# 7 Rows: ECT [DegF] FN020B (-30,0,30,50,100,150,200)
# 8 Cols: Throttle Rate [Deg/sec] FN019B (15,33,48,63,77,90,110,125)
  FN1303:
91cb: 54,5c,68,70,7c,88,9c,e0   table  84, 92,104,112,124,136,156,224
91d3: 30,38,40,48,68,78,98,dc   table  48, 56, 64, 72,104,120,152,220
91db: 14,20,28,30,42,54,6c,b4   table  20, 32, 40, 48, 66, 84,108,180
91e3: 10,14,18,20,32,44,66,88   table  16, 20, 24, 32, 50, 68,102,136
91eb: 08,08,0c,12,20,32,48,74   table   8,  8, 12, 18, 32, 50, 72,116
91f3: 06,06,08,0c,12,20,30,50   table   6,  6,  8, 12, 18, 32, 48, 80
91fb: 06,06,08,0c,12,20,30,48   table   6,  6,  8, 12, 18, 32, 48, 72

9203: ff                        

# Table - Air Charge clip vs RPM - FN037(N)
# The maximum air charge (air mass in 1 cylinder) based upon rpm.
  FN037:
9204: ff,ff,65,aa   func        65535,43621
9208: 00,00,65,aa   func            0,43621
920c: 00,00,65,aa   func            0,43621
9210: 00,00,65,aa   func            0,43621
9214: 00,00,65,aa   func            0,43621
9218: 00,00,65,aa   func            0,43621
921c: 00,00,65,aa   func            0,43621
9220: 00,00,65,aa   func            0,43621
9224: 00,00,65,aa   func            0,43621
9228: 00,00,65,aa   func            0,43621


# Table - injector breakpoint vs battery voltage - FN389(VBAT)
# Output is lbs/rev (scale factor?)
 FN389:
922c: ff,ff,e0,1f   func        65535, 8160
9230: 00,00,e0,1f   func            0, 8160
9234: 00,00,e0,1f   func            0, 8160
9238: 00,00,e0,1f   func            0, 8160
923c: 00,00,e0,1f   func            0, 8160
9240: 00,00,e0,1f   func            0, 8160
9244: 00,00,e0,1f   func            0, 8160
9248: 00,00,e0,1f   func            0, 8160

# Scaler for ECT for FN1861 - FN020C
  FN020C:
924c: 7f,60   func               127, 96
924e: 7d,60   func               125, 96
9250: e7,00   func               -25,  0
9252: 80,00   func              -128,  0
9254: 80,00   func              -128,  0

# ISC Transfer - FN800(DEBYMA_FM)
# Alter if air flow characteristics through the ISC valve have changed.
  FN800:
9256: ff,ff,00,80   func        65535,32768
925a: 9a,25,00,80   func         9626,32768
925e: f6,24,9a,79   func         9462,31130
9262: ec,21,cd,6c   func         8684,27853
9266: 9a,1f,66,66   func         8090,26214
926a: 00,18,e1,5a   func         6144,23265
926e: 00,0c,9a,49   func         3072,18842
9272: 00,08,00,40   func         2048,16384
9276: 00,04,ec,31   func         1024,12780
927a: ec,01,d7,23   func          492, 9175
927e: 00,00,cd,0c   func            0, 3277

9282: 00,00,00,00               

# ISC Adder vs RPM - FN810(N)
  FN810:
9286: ff,ff,00,00   func        65535,    0
928a: 60,09,00,00   func         2400,    0
928e: 08,07,ae,03   func         1800,  942
9292: 78,05,00,08   func         1400, 2048
9296: 00,00,00,08   func            0, 2048

# ISC Dutycycle Multiplier vs LOAD - FN820B(LOAD)
  FN820B:
929a: ff,ff,80,00   func        65535,  128
929e: 00,00,80,00   func            0,  128
92a2: 00,00,80,00   func            0,  128
92a6: 00,00,80,00   func            0,  128
92aa: 00,00,80,00   func            0,  128
92ae: 00,00,80,00   func            0,  128

# ISC Gain vs RPM - FN824(N_BYTE)
  FN824:
92b2: ff,c0   func              255,192
92b4: 38,c0   func               56,192
92b6: 2b,40   func               43, 64
92b8: 29,40   func               41, 64
92ba: 1f,ff   func               31,255
92bc: 00,ff   func                0,255
92be: 00,ff   func                0,255

# ISC Startup RPM vs ECT - FN826A(ECT)
  FN826A:
92c0: 7f,00   func               127,  0
92c2: 32,06   func                50,  6
92c4: 26,36   func                38, 54
92c6: 19,06   func                25,  6
92c8: 0a,06   func                10,  6
92ca: 00,13   func                 0, 19
92cc: 80,13   func              -128, 19

# Spark Idle Multiplie vs Dashpot - FN839(DASPOT)
  FN839:
92ce: ff,7f   func              255,127
92d0: 06,7f   func                6,127
92d2: 00,53   func                0, 83
92d4: 00,53   func                0, 83

# ISC Error Spark Multiplier Drive - FN841D(RPMERR)
  FN841D:
92d6: ff,7f,7f,00   func         32767,  127
92da: 64,00,7f,00   func           100,  127
92de: 28,00,71,00   func            40,  113
92e2: 00,00,60,00   func             0,   96
92e6: b0,ff,46,00   func           -80,   70
92ea: 00,80,46,00   func        -32768,   70
92ee: 00,80,46,00   func        -32768,   70

# ISC Error Spark Multiplier Neutral - FN841N(RPMERR)
  FN841N:
92f2: ff,7f,7c,00   func         32767,  124
92f6: b8,01,7c,00   func           440,  124
92fa: 00,00,53,00   func             0,   83
92fe: 10,ff,3e,00   func          -240,   62
9302: 00,80,3e,00   func        -32768,   62
9306: 00,80,3e,00   func        -32768,   62
930a: 00,80,3e,00   func        -32768,   62

# ISC C/L RPM Correction Rate - FN860(RPMERR) ?
  FN860:
930e: ff,7f,05,00   func         32767,    5
9312: 00,80,05,00   func        -32768,    5
9316: 00,80,05,00   func        -32768,    5
931a: 00,80,05,00   func        -32768,    5
931e: 00,80,05,00   func        -32768,    5
9322: 00,80,05,00   func        -32768,    5
9326: 00,80,05,00   func        -32768,    5

# Table - dashpot decrement rate (dashpot decrement step at given flow(Kg/Hr(flow),Kg/Hr(Step))- FN879
# X: DASPOT
# Y: Dashpot decr [lb/min]
  FN879:
932a: ff,ff,00,01   func        65535,  256
932e: 00,0c,00,01   func         3072,  256
9332: 66,0a,b8,00   func         2662,  184
9336: 33,07,1d,00   func         1843,   29
933a: 9a,05,08,00   func         1434,    8
933e: fe,00,0c,00   func          254,   12
9342: 00,00,0e,00   func            0,   14

# Max Dashpot Pre Position Clip (maximum dashpot airflow by rpm in Kg/Hr)- FN882(N)
  FN882:
9346: ff,ff,9a,19   func        65535, 6554
934a: 40,1f,9a,19   func         8000, 6554
934e: 70,17,00,10   func         6000, 4096
9352: d0,07,ec,01   func         2000,  492
9356: 00,00,ec,01   func            0,  492

# ISC duty cycle during crank (keyed off ect at start) - FN884(ECT)
  FN884:
935a: 7f,4d   func               127, 77
935c: 5a,4d   func                90, 77
935e: 50,7f   func                80,127
9360: 80,7f   func              -128,127
9362: 80,7f   func              -128,127
9364: 80,7f   func              -128,127

# Desired Idle Airflow Multiplier - FN1861(ECT,ATMR3)
# Multiplier of desired idle airflow to adjust for extra friction at cold start
# Airflow multiplier vs. ECT and ATMR3
  FN1861:
9366: a6,80,66,5a,4d,48,44   table 166,128,102, 90, 77, 72, 68
936d: a6,80,66,53,4d,48,44   table 166,128,102, 83, 77, 72, 68
9374: a6,9a,66,4d,4a,48,44   table 166,154,102, 77, 74, 72, 68
937b: 9a,90,5a,46,4a,48,44   table 154,144, 90, 70, 74, 72, 68
9382: 86,7a,53,46,4a,48,44   table 134,122, 83, 70, 74, 72, 68
9389: 6d,66,53,46,40,40,40   table 109,102, 83, 70, 64, 64, 64


# Desired idle airflow in drive (Kg/Hr) vs. desired idle RPM
  Drv_aflw:
9390: ff,ff   func              255,255
9392: 7a,ff   func              122,255
9394: 5e,ca   func               94,202
9396: 3f,8d   func               63,141
9398: 2a,60   func               42, 96
939a: 00,00   func                0,  0

# Desired idle airflow in neutral
  FN875D:
939c: ff,ff   func              255,255
939e: 7a,fa   func              122,250
93a0: 2a,60   func               42, 96
93a2: 00,00   func                0,  0
93a4: 00,00   func                0,  0
93a6: 00,00   func                0,  0


################################################### Reg 0xF6 points here (93a8)

93a8: 30,94               word   9430
93aa: 33,33               word   3333            FKARCH                            # Air Charge Manifold filling model slow filter constant
93ac: 00,40               word   4000            FKARC1                            # Air Charge Manifold filling model fast filter constant
93ae: 1a,01               word    11a            FILFRC                            # Air Charge Fraction to select slow transient vs fast
                                                                                   #  0x100 = steady state
93b0: 01                  byte    1              ARCHSW                            # Air charge select switch -
                                                                                   # 1 = enable manifold filling model 0 = disable

93b1: ff                        

93b2: 2c,01               word    12c            ACRT
93b4: 00,00               word      0            HWPPM                             # DESMAF adder for heated windshield

93b6: 00                  byte    0              BYSTM3
93b7: 00                  byte    0              BYSTM2
93b8: 00                  byte    0              BYSTM5
93b9: 00                  byte    0              BYSTM1
93ba: 01                  byte    1              BYSTM4

93bb: 00                  byte    0              BIHP                              # Brake Input H/w Present - Set if brake pedal switch present.
93bc: 00                  byte    0              PSPSHP                            # Power Steering Pressure Switch Present
#
# Thermactor logic constants
#
93bd: 00                  byte    0              BYPWOT                            # Min time to force Thermactor Air Bypass (sec)
93be: 71                  byte   71              ATBYS                             # Min ACT for Thermactor Air Bypass
93bf: 76                  byte   76              CTBYS                             # Min ECT for Thermactor Air Bypass
93c0: 05                  byte    5              CTBYSH                            # Hysteresis for ATBYS and CTBYS

93c1: ff                        

93c2: 90,01               word    190            UPRPMH
93c4: a0,0f               word    fa0            UPRPM2

93c6: 14                  byte   14              CTARTM                           # Max Closed Throttle Upstream Air time
93c7: 9b                  byte   9b              HMSTM                            # Max time that Upstream Air occurs after startup.
93c8: 03                  byte    3              HMCTM                            # Max time for upstream air at high load, sec.

93c9: ff                        

93ca: 66,66               word   6666            UPLOD                            # PERLOAD min. for upstream air
93cc: ae,07               word    7ae            UPLODH                           # Hysteresis term for UPLOD

93ce: 38                  byte   38              UPSTM3
93cf: 5f                  byte   5F              UPSTM2
93d0: 00                  byte    0              UPSTM5
93d1: 00                  byte    0              UPSTM1
93d2: 00                  byte    0              UPSTM4

93d3: 00                  byte    0              UPSWOT                           # WOT Upstream Air Time Delay (sec)

93d4: 66,66               word   6666            DNLOD                            # Maximum load for downstream air
93d6: d7,03               word    3d7            DNLODH                           # Hysteresis for downstream air

93d8: ff                  byte   ff              DNSTMI                           # Time delay for downstream air when not at CT (sec)

93d9: ff                        

93da: 48,0d               word    d48            INLRPM                            # Max RPM to increment CTNTMR (x 4)
93dc: 20,03               word    320            INLRPH                            # Hysteresis term for above

93de: 3c                  byte   3c              BYPLES                            # Time w/o an EGO #n switch to set LEGOFGn, sec.
93df: ff                  byte   ff              DMPDLY                            # MFA delay to bypass thermactor air, sec.
93e0: 00                  byte    0              LOESSW                            # Clear LEGOFGn after detecting EGO #n switch 
93e1: 00                  byte    0              ECADHP                            # Electronically Controlled Accessory Drive Present
93e2: 71                  byte   71              ECADECT                           # Max temp for low speed drive
93e3: 48                  byte   48              ECADN                             # min RPM (byte) for low speed drive
93e4: 1e                  byte   1e              ECADVS                            # Min speed (mph) for low speed drive
93e5: 6c                  byte   6c              EDETHYS                           # Hysteresis term for ECADECT
93e6: 22                  byte   22              EDNHYS                            # Hysteresis term for ECADN
93e7: 1a                  byte   1a              EDVSHYS                           # Hysteresis term for ECADVS

93e8: 00                  byte    0              EDTM3
93e9: 00                  byte    0              EDTM3
93ea: 00                  byte    0              EDTM3
93eb: 00                  byte    0              EDTM3
93ec: 00                  byte    0              EDTM3

93ed: 76                  byte   76              CTPRG
93ee: 03                  byte    3              CTPRGH
93ef: 00                  byte    0              PURGSW                            # Canister Purge O/L Enable
93f0: 01                  byte    1              EVTDOT

93f1: ff

93f2: 88,13               word 1388              EVRPM                             # Not used?
93f4: 20,03               word  320              EVRPMH                            # Not used?

93f6: a5                  byte   a5              PRGTD3
93f7: dc                  byte   dc              PRGTD2
93f8: 00                  byte    0              PRGTD5
93f9: 00                  byte    0              PRGTD1
93fa: dc                  byte   dc              PRGTD4

#
# A/C Clutch Logic Constants
# 

93fb: 05                  byte    5              ACSTRD                            # A/C Max Time Off After Start (sec)
93fc: 00                  byte    0              BRKCOT                            # A/C Max Time To Disable For Brake (1/8 sec)
93fd: 18                  byte   18              ACWDLY                            # A/C Delay After WOT (1/8 sec)
93fe: 0c,00               word      c            ACMNDT                            # A/C Clutch Min Disable Time (1/8 sec)
9400: f6,00               word     f6            IDLCOT                            # A/C Clutch Max Delay At Idle (ms)
9402: 79                  byte   79              CTAC                              # A/C Clutch Engage Max Temp - CTAC
9403: 04                  byte    4              CTACH                             # A/C Clutch Engage Max Temp Hysteresis - CTACH
9404: c8,00               word     c8            ACOFFN                            # A/C Clutch Off RPM Threshold
9406: 90,01               word    190            ACOFFH                            # A/C Clutch Off RPM Hysteresis
9408: 00,87               word   8700            THBP4                             # Min TP above RATCH for A/C WOT cutout          
940a: 00,05               word    500            THBP4H                            # Hysteresis for above
940c: 0c,00               word      c            ACMNET                            # A/C Clutch Min Enable Time

#
#

940e: 00                  byte    0              HPACL                             # Set if Adjustable Dampers Present

940f: ff                        

9410: d5,09               word    9d5            SHKCHG                            # Min Air Charge for Adjustable Damper -  The minimum air charge to indicate hard acceleration.
9412: 80,a2               word   a280            SHKTP                             # Min TP for Adjustable Damper -  The minimum voltage above closed throttle to indicate hard acce
                                                                                   leration.

9414: 6e                  byte   6e              Fan_temp                          # coolant fan low speed temp (220DegF)
9415: 02                  byte    2              HSFHYS                            # High Speed Fan Temperature Hysteresis
9416: 02                  byte    2              LSFHYS                            # Low Speed Fan Temperature Hysteresis
9417: 50                  byte   50              LSFVS                             # Low Speed Fan MPH
9418: 0a                  byte    a              LSFVSH                            # Low Speed Fan MPH Hysteresis
9419: 0a                  byte    a              EDFTM                             # Low Speed Fan Min Time Before High Speed

941a: e0,01               word    1e0            ACMNFT                            # A/C Min Time Off Before Turning Fan Off

941c: 00                  byte    0              EDFHP                             # Electro Drive Fan Hardware Present
941d: 00                  byte    0              HEDFHP                            # High speed Electro Drive Fan Hardware Present
941e: 75                  byte   75              Ect_hs1                           # fan high speed temp 1(234DegF) # ect1 fan on 
941f: 79                  byte   79              Ect_hs2                           # ect2 fan on fan high speed temp 2(242DegF)
9420: 71                  byte   71              HSFRPM                            # Fan High Speed Min RPM
9421: 50                  byte   50              HSFVS                             # Fan High Speed Min MPH

9422: 00,c0               word   c000            HSFLOD                            # Fan High Speed Min Load
9424: 66,46               word   4666            FMMISC                            # Default ISC Dutycycle -  Default ISC dutycyle when both TPS and MAF failed flags are set

9426: 32                  byte   32              FMMDSD                           # Default Desired Idle RPM -  Default desired idle rpm when both TPS and MAF failed flags are set
9427: 4b                  byte   4b              ACTFMM                            # ACT value to use if failed
9428: 4b                  byte   4b              ECTFMM                            # ECT value to use if failed

9429: ff                        

942a: 00,02               word    200            FMCTTP                            # Change in TP if failed and not at idle
942c: cd,03               word    3cd            IDLMAF                            # Maximum AM value at idle

942e: ef                  byte   ef              BAPFMM                            # Default BAP value when sensor failed

942f: 50                  byte   50

################################################### Reg 0xF8 points here (9430)
9430: a8                  byte   a8
9431: 97,
9432: 00,00               word      0            KCS1                              # closed throttle spark adder (Deg BTDC x 4
9434: 00,00               word      0            KPS1                              # part throttle   spark adder (Deg BTDC x 4)
9436: 68,10               word   1068            HCSD                              # Minimum RPM for High Cam Spark Retard (x 4)
9438: e8,03               word    3e8            HCSDH                             # Hysteresis for HCSD (x 4)
943a: 00,00               word      0            KWS1                              # spark adder WOT (Deg BTDC x 4)

943c: 00                  byte    0              SPLCLP                            # Spark Advance Limit Min for rotor registry (deg BTDC x 4)
943d: b4                  byte   b4              SPUCLP                            # Spark Advance Limit Max for rotor registry (deg BTDC x 4)
943e: 80                  byte   80              Y                                 # PT Spark Multiplier - 0x80 = 1.0
943f: 20                  byte   20              LUGTMIM                           # Spark/Fuel Lug Time Limit - LUGTIM
9440: 01                  byte    1              LUGSW                             # Lugging Timer Reset Switch -  If set then Lugging Timer is cleared before Lugging Timer Up Flag
                                                                                    is cleared and Lugging Timer Down Flag is set.

9441: 00                  byte    0              FRCSPK ??                         # Not used in this strategy
9442: 00,00               word      0            NSADD                             # Spark Adder Neutral - NSADD

#
# PIP rising edge to rising edge interval thresholds for switching
# between Falling-Edge (normal) and Rising-Edge (high RPM) spark
# See GUFB pp. 7-20, 7-21 for explanation
#
# 0x310 = 784 ticks x 2.4 us = 1.8816 ms = 7972 RPM as the threshold
#
# Note that there is also a dynamic threshold based on how much time
# is left to the next scheduled SPOUT On event.
# See Spark_calc routine, 0x2c0d - 0x2c31
#
9444: 10,03               word    310            SPKSWL                            # Min PIP-PIP interval for Falling-Edge spark, ticks
9446: 10,03               word    310            SPKSWH                            # Max PIP-PIP interval for Rising-Edge spark, ticks

9448: ff                  byte   ff              TTNOV                             # RPM to MPH Ratio for First Gear (for Torque Truncation Spark)
9449: 00                  byte    0              HP_HIDRES                         # High Data Rate Electronic Spark H/W present 
944a: 00                  byte    0              CCDSW                             # Computer Controlled Dwell Present if Set. (else dwell is TFI controlled)

944b: ff                        

944c: 7b,14               word   147b            PACPER
944e: f6,28               word   28f6            PACOFF
9450: 30,00               word     30            PACSLO                            #  # Slope for linear equation describing PIP period and percent of PIP period for acceleration, 
                                                                                   (Units = Beta/second)
9452: ec,11               word   11ec            PACLIM                            # Max PIP acceleration in percent of PIP period, Beta (0x8000 = 1)
9454: ae,07               word    7ae            SPTADV                            # Spark Advance Limit PIP%
9456: 00,80               word   8000            Lowdwell                          # max low speed dwell (off time in ms )
9458: 33,33               word   3333            Hidwell                           # max high speed dwell  (off time in ms )

945a: 70                  byte   70              DWLWF                             # DWLWF - Weighting factor determining effect of ECT and ACT on Base Dwell, unitless.
945b: 26                  byte   26              DWLTBP

945c: 1f,05               word    51f            dwLTSW                            # Switch point for change of max permitted DWELL,sec
945e: 20,02               word    220            KACRAT                            # Spark Tip In TP delta - KACRAT (41.5 mV)

9460: 00                  byte    0              RETLIM                            # Spark Retard For Knock Sensor, Tip-in - RETLIM
9461: 00                  byte    0              ADVLIM                            # Spark Knock Advance Limit - ADVLIM
9462: 00                  byte    0              TIPMAX                            # Tip in retard (max tip in spark retard in Deg BTDC)
9463: 01                  byte    1              TIPINC                            # Spark Tip-In Advance Per PIP (1/4 degree) - TIPINC

9464: cd,1c               word   1ccd            TIPLOD                            # Spark Tip-In Load Threshold (22.5%)
9466: 66,06               word    666            TIPHS                             # Spark Tip-In Load Hysteresis (5%)
9468: 00,7d               word   7d00            RPMMIN                            # Spark Knock Min RPM -  The minimum rpm for the knock strategy to be enabled.
946a: 66,06               word    666            LODNOK                            # Spark Knock Min Load (5%)

946c: 00                  byte    0              ECTNOK                            # Spark Knock Min ECT - ECTNOK
946d: 3c                  byte   3c              ECTIP                             # Spart Tip-In Retard Min ECT 

946e: 00,00               word      0            NTIP                              # Spark Tip-In Max RPM - NTIP
9470: 00,80               word   8000            WOPEN                             # Position of knock sensor window opening, units beta (scale?)
9472: 00,00               word      0            WINLEN
9474: 80,3e               word   3e80            RPMCNL
9476: ae,07               word    7ae            SPKLIM                            # max increase in spark advance between PIPs,
                                                                                   # as proportion of interval between PIPs x 32768
                                                                                   # (= .06; see GUFB p. 7-16)

9478: 04                  byte    4              KNKCYL                            # See GUFB p. 7-40 - this value is probably a mistake
                                                                                   # (and irrelevant anyway because A9L
                                                                                   # lacks the knock detection h/w)
9479: 0c                  byte    c              WINCLD
947a: 00                  byte    0              KIHP                              # Knock Input H/w Present
947b: 01                  byte    1              BPSSW                             # Barometric Pressure Sensor present
947c: ef                  byte   ef              KONBP                             # Default BP if no sensor

947d: ff                        

947e: 00,06               word    600            IDLDEL
9480: 33,00               word     33            TKYON1
9482: 71,00               word     71            TKYON2                            # Time delay before Keyon Updates are permitted, sec.
9484: 0a,02               word    20a            TKYON3

9486: 0a                  byte  a                TKYON4

9487: ff                        

# PT Spark Scaler for ECT - FN033(ECT)
  FN033:
9488: ff,7f,00,06   func         32767, 1536
948c: 73,00,00,06   func           115, 1536
9490: 69,00,00,05   func           105, 1280
9494: 62,00,00,04   func            98, 1024
9498: 35,00,00,03   func            53,  768
949c: 1e,00,00,00   func            30,    0
94a0: 00,80,00,00   func        -32768,    0
94a4: 00,80,00,00   func        -32768,    0
94a8: 00,80,00,00   func        -32768,    0

# Closed Throttle Spark Adder For RPM - FN111(N)
  FN111:
94ac: ff,7f,7c,00   func         32767,   124
94b0: 40,06,7c,00   func          1600,   124
94b4: bc,02,00,00   func           700,     0
94b8: 00,80,00,00   func        -32768,     0
94bc: 00,80,00,00   func        -32768,     0

# CT Spark Adder For ECT - FN112(ECT)
# Generates cold temperature spark advance. Input = ECT, deg F and Output = spark adder.
  FN112:
94c0: 7f,00   func               127,   0
94c2: 12,00   func                18,   0
94c4: 00,0c   func                 0,  12
94c6: 80,0c   func              -128,  12
94c8: 80,0c   func              -128,  12
94ca: 80,0c   func              -128,  12
94cc: 80,0c   func              -128,  12

# Hi Cam Closed Throttle Spark Subtracter For BP - FN115(BP)
  FN115:
94ce: ff,00   func              255,   0
94d0: 00,00   func                0,   0
94d2: 00,00   func                0,   0
94d4: 00,00   func                0,   0
94d6: 00,00   func                0,   0
94d8: 00,00   func                0,   0

# Lug mode load threshold vs. RPM - FN125(N)
  FN125:
94da: ff,ff,8f,02   func        65535,  655
94de: 00,19,8f,02   func         6400,  655
94e2: 70,17,a4,10   func         6000, 4260
94e6: 30,11,a4,10   func         4400, 4260
94ea: 00,00,cd,2c   func            0,11469

# Part Throttle Spark Advance vs Air Charge Temp. - FN126(ACT)
  FN126:
94ee: 7f,f8   func               127,  -8
94f0: 5f,f8   func                95,  -8
94f2: 50,00   func                80,   0
94f4: 80,00   func              -128,   0
94f6: 80,00   func              -128,   0

# LOMALT Multiplier vs BP - FN129A
  FN129A:
94f8: ff,00   func              255,  0
94fa: de,00   func              222,  0
94fc: d4,80   func              212,128
94fe: bc,80   func              188,128
9500: 60,9a   func               96,154
9502: 00,9a   func                0,154

# WOT Spark Advance vs RPM - FN131(N)
  FN131:
9504: ff,ff,68,00   func        65535,  104
9508: 20,4e,68,00   func        20000,  104
950c: b0,36,58,00   func        14000,   88
9510: a0,28,5a,00   func        10400,   90
9514: 98,21,56,00   func         8600,   86
9518: 20,1c,4a,00   func         7200,   74
951c: a0,0f,20,00   func         4000,   32
9520: 00,00,20,00   func            0,   32
9524: 00,00,20,00   func            0,   32

# WOT Spark Advance vs BP - FN133(BP)
  FN133:
9528: ff,00   func              255,   0
952a: de,00   func              222,   0
952c: d4,10   func              212,  16
952e: bc,10   func              188,  16
9530: 00,30   func                0,  48

# WOT Spark Advance vs ECT - FN134(ECT)
  FN134:
9532: 7f,f0   func               127, -16
9534: 7b,f0   func               123, -16
9536: 76,f8   func               118,  -8
9538: 64,00   func               100,   0
953a: 3c,00   func                60,   0
953c: 2b,0c   func                43,  12
953e: 80,0c   func              -128,  12

# WOT Spark Advance vs ACT - FN135(ACT)
  FN135:
9540: 7f,e8   func               127, -24
9542: 78,e8   func               120, -24
9544: 4b,00   func                75,   0
9546: 80,00   func              -128,   0
9548: 80,00   func              -128,   0
954a: 80,00   func              -128,   0
954c: 80,00   func              -128,   0

# Idle Spark Subtractor - FN180(CTNTMR)
  FN180:
954e: ff,00   func              255,  0
9550: 00,00   func                0,  0
9552: 00,00   func                0,  0
9554: 00,00   func                0,  0
9556: 00,00   func                0,  0
9558: 00,00   func                0,  0

# ISC Neutral RPM Adder - FN880
  FN880:
955a: ff,09   func              255,  9
955c: dc,00   func              220,  0
955e: 05,00   func                5,  0
9560: 00,08   func                0,  8
9562: 00,08   func                0,  8
9564: 00,08   func                0,  8
9566: 00,08   func                0,  8

# Startup Kicker Time Delay - FN400
  FN400:
9568: 7f,00   func               127,  0
956a: 33,00   func                51,  0
956c: 2d,1e   func                45, 30
956e: 23,1e   func                35, 30
9570: 1e,00   func                30,  0
9572: 80,00   func              -128,  0

# Base Spark Table - FN901(N,LOAD)
# Normally used for lug mode, tip-in
# 10 Cols: Speed [RPM] 500,700,900,1100,1300,1500,2000,2500,3000,4000
#  8 Rows: LOAD []   .05,.15,.23,.30,.40,.50,.60,.75
  FN901:
9574: 70,70,70,7c,84,88,88,88,88,88   table 112,112,112,124,132,136,136,136,136,136
957e: 70,70,70,7c,84,88,88,88,70,70   table 112,112,112,124,132,136,136,136,112,112
9588: 70,70,84,90,90,94,98,98,70,70   table 112,112,132,144,144,148,152,152,112,112
9592: 64,68,70,74,80,80,98,a0,70,70   table 100,104,112,116,128,128,152,160,112,112
959c: 50,54,64,70,7c,80,84,88,70,70   table  80, 84,100,112,124,128,132,136,112,112
95a6: 3c,3c,40,40,48,50,5c,6c,6c,6c   table  60, 60, 64, 64, 72, 80, 92,108,108,108
95b0: 20,28,28,2c,34,3c,54,54,54,54   table  32, 40, 40, 44, 52, 60, 84, 84, 84, 84
95ba: 20,20,24,28,30,38,48,54,54,54   table  32, 32, 36, 40, 48, 56, 72, 84, 84, 84

# Sea Level Spark Table - FN904A(N,LOAD)
# - The ecu interpolates between the Sea Level and Altitude spark tables during normal part throttle
# operation.
# 10 Cols: Speed [RPM] 500,700,900,1100,1300,1500,2000,2500,3000,4000
#  8 Rows: LOAD []   .05,.15,.23,.30,.40,.50,.60,.75
  FN904A:
95c4: 70,70,70,7c,84,88,88,88,88,88   table 112,112,112,124,132,136,136,136,136,136
95ce: 70,70,70,80,88,8c,8c,88,70,70   table 112,112,112,128,136,140,140,136,112,112
95d8: 70,70,84,94,94,98,98,98,70,70   table 112,112,132,148,148,152,152,152,112,112
95e2: 64,68,78,94,98,90,90,98,70,70   table 100,104,120,148,152,144,144,152,112,112
95ec: 50,54,64,80,88,88,84,80,70,70   table  80, 84,100,128,136,136,132,128,112,112
95f6: 3c,40,40,40,48,50,68,6c,6c,6c   table  60, 64, 64, 64, 72, 80,104,108,108,108
9600: 20,20,24,28,2c,38,54,54,54,54   table  32, 32, 36, 40, 44, 56, 84, 84, 84, 84
960a: 20,20,24,28,2c,34,54,54,54,54   table  32, 32, 36, 40, 44, 52, 84, 84, 84, 84

# Altitude spark Table - FN905A(N,LOAD)
# 10 Cols: Speed [RPM] 500,700,900,1100,1300,1500,2000,2500,3000,4000
#  8 Rows: LOAD []   .05,.15,.23,.30,.40,.50,.60,.75
  FN905A:
9614: 70,70,70,7c,84,88,88,88,88,88   table 112,112,112,124,132,136,136,136,136,136
961e: 70,70,70,7c,84,88,88,88,88,88   table 112,112,112,124,132,136,136,136,136,136
9628: 64,68,7a,86,8c,92,98,98,98,98   table 100,104,122,134,140,146,152,152,152,152
9632: 50,54,50,60,7c,80,84,84,84,84   table  80, 84, 80, 96,124,128,132,132,132,132
963c: 38,38,38,38,40,54,6c,6c,6c,6c   table  56, 56, 56, 56, 64, 84,108,108,108,108
9646: 20,24,28,2c,34,44,58,58,58,58   table  32, 36, 40, 44, 52, 68, 88, 88, 88, 88
9650: 1a,20,24,28,30,38,48,48,48,48   table  26, 32, 36, 40, 48, 56, 72, 72, 72, 72
965a: 1a,1a,24,28,30,38,48,48,48,48   table  26, 26, 36, 40, 48, 56, 72, 72, 72, 72

# Part Thottle Spark Adder for EGR - FN1121(N,LOAD)
  FN1121:
9664: 00,00,30,30,30,30,30,30,30,30   table   0,  0, 48, 48, 48, 48, 48, 48, 48, 48
966e: 00,00,30,30,30,30,30,30,30,30   table   0,  0, 48, 48, 48, 48, 48, 48, 48, 48
9678: 00,00,30,30,30,30,30,30,30,30   table   0,  0, 48, 48, 48, 48, 48, 48, 48, 48
9682: 00,00,30,30,30,30,30,30,30,30   table   0,  0, 48, 48, 48, 48, 48, 48, 48, 48
968c: 00,00,30,30,30,30,30,30,30,30   table   0,  0, 48, 48, 48, 48, 48, 48, 48, 48
9696: 00,00,00,16,16,20,30,30,30,30   table   0,  0,  0, 22, 22, 32, 48, 48, 48, 48
96a0: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
96aa: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0

# MFA PT Spark Adder for RPM - FN1124(N,LOAD)
# Table of spark adders from engine speed N and LOAD. (4 x 3) 
# X input is RPM  Y -input is LOAD
  FN1124:
96b4: 00,10,04,00   table         0, 16,  4,  0
96b8: 20,14,04,08   table        32, 20,  4,  8
96bc: 2c,24,10,10   table        44, 36, 16, 16

# Torque Reduction Table - FN1119
  FN1119:
96c0: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
96ca: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
96d4: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
96de: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
96e8: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
96f2: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
96fc: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
9706: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0

# MFA Part Throttle spark modifier (multiplier). FN311(ECT,LOAD) 
  FN311:
9710: 00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0
9717: 00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0
971e: 00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0
9725: 0c,00,00,00,00,00,00   table  12,  0,  0,  0,  0,  0,  0
972c: 0c,00,00,00,00,00,f0   table  12,  0,  0,  0,  0,  0,240
9733: 14,00,00,00,00,00,f0   table  20,  0,  0,  0,  0,  0,240
973a: 14,00,00,00,00,fc,f0   table  20,  0,  0,  0,  0,252,240
9741: 14,00,00,00,00,f8,f0   table  20,  0,  0,  0,  0,248,240

# Min Low Speed Dwell - FN160A(VBAT)
#   = Dwell/Coil off time vs battery voltage 
  FN160A:
9748: ff,ff,bc,05   func        65535, 1468
974c: f0,00,bc,05   func          240, 1468
9750: e0,00,25,06   func          224, 1573
9754: c0,00,31,08   func          192, 2097
9758: a0,00,37,09   func          160, 2359
975c: 00,00,37,09   func            0, 2359

# Min High Speed Dwell - FN160B(VBAT)
#   = Dwell/Coil off time vs battery voltage 
  FN160B:
9760: ff,ff,25,06   func        65535, 1573
9764: f0,00,25,06   func          240, 1573
9768: d0,00,dc,06   func          208, 1756
976c: c0,00,94,07   func          192, 1940
9770: a0,00,3d,0a   func          160, 2621
9774: 00,00,3d,0a   func            0, 2621

# Spark Knock Retard Increment vs RPM - FN143A
  FN143A:
9778: ff,04   func              255,  4
977a: 9c,04   func              156,  4
977c: 5e,0c   func               94, 12
977e: 1f,10   func               31, 16
9780: 00,14   func                0, 20
9782: 00,14   func                0, 20

# Spark Knock Threshold Time - Output is fraction of PIP period.
  FN144:
9784: ff,19   func              255, 25
9786: 9c,19   func              156, 25
9788: 5e,16   func               94, 22
978a: 4e,13   func               78, 19
978c: 3f,04   func               63,  4
978e: 2f,03   func               47,  3
9790: 00,03   func                0,  3

# Spark Knock Threshold Position.
  FN145:
9792: ff,00   func              255,  0
9794: 00,00   func                0,  0
9796: 00,00   func                0,  0
9798: 00,00   func                0,  0
979a: 00,00   func                0,  0

# Spark Advance Rate vs RPM
#  -  Limits the advance rate to avoid pinging, increase to improve throttle response.
  FN146B:
979c: ff,10   func              255, 16
979e: 7d,10   func              125, 16
97a0: 5e,18   func               94, 24
97a2: 1f,20   func               31, 32
97a4: 00,20   func                0, 32
97a6: 00,20   func                0, 32

#################### RFA points here (97a8)

97a8: 7e,9a               word   9a7e
97aa: 00,02               word    200            DELTA                             # TP PT Threshold -  Added to RATCH.
97ac: 40,01               word    140            HYST2                             # TP WOT Threshold Hysteresis
97ae: 40,01               word    140            HYSTS                             # TP Closed Throttle Threshold Hysteresis
97b0: c0,8a               word   8ac0            THBP2                             # TP WOT breakpoint. TPS voltage - RATCH

97b2: 7f                  byte   7f              LDEL                              # Fuel Lugging Mode O/L Min ECT
97b3: 6e                  byte   6e              LDEH                              # Fuel Lugging Mode O/L Max ECT

97b4: 0a                  byte   0a              LDTM ??                           # Not used in this strategy.

97b5: 28                  byte   28              LDLTM                             # Min Time for Lugging O/L -  The minimum time in lugging mode required for the Lugging O/L Flag 
                                                                                   to be set.

97b6: b8,7e               word   7eb8            LDMH                              # Fuel Lugging Mode O/L Min Load - LDMH
97b8: d7,03               word    3d7            LDMHH                             # Fuel Lugging Mode O/L Min Load Hysteresis - LDMHH
97ba: ff,00               word     ff            OLMCL                             # Global Open Loop Fuel Multiplier

97bc: 08                  byte    8              NCNT                              # Min # of PIPs to exit crank mode

97bd: ff                        

97be: 20,03               word    320            UNRPM                             # Underspeed Engine Speed
97c0: 90,01               word    190            UNRPMH                            # Underspeed hysteresis
97c2: 84,03               word    384            NRUN                              # Min engine speed to exit crank (225 RPM)
97c4: c8,00               word     c8            NSTALL                            # Engine speed to re-enter crank (50 RPM)

97c6: 02                  byte    2              CRKTIM                            # Time after cold start before clipping drive idle to ISCLPD

#
# EGR calibration constants
#

97c7: 1e                  byte   1e              EGRTD3                            # EGR time delay (TCSTRT >= CTHIGH) for low mileage.
97c8: 5a                  byte   5a              EGRTD2                            # EGR time delay (CTLOW < TCSTRT < CTHIGH) for low mileage.
97c9: 00                  byte    0              EGRTD5                            # EGR time delay (CTLOW < TCSTRT < CTHIGH) for high mileage or no IMS hardware.
97ca: 00                  byte    0              EGRTD1                            # EGR time delay (TCSTRT <= CTLOW) for low mileage.
97cb: f0                  byte   f0              EGRTD4                            # EGR time delay (TCSTRT <= CTLOW) for high mileage or no IMS hardware.

97cc: 00                  byte    0              KPEI                              # Part throttle EGR adder
97cd: 80                  byte   80              X                                 # EGR table multiplier (byte)

97ce: cd,2c               word   2ccd            DCOFF                             # EGR Duty Cycle for Valve to Open
97d0: 00,02               word    200            EGRDED                            # EGR Deadband Value for EVP - EGRDED

97d2: 0a                  byte    a              EGRMPT                            # Calibration time delay to ramp in EGR (sec)

97d3: ff                        

97d4: fe,54               word   54fe            XFREPT                            # EPT Transfer Function (PFE) - in H2O/counts
97d6: 00,30               word   3000            IXFRPR                            # Inverse EPT Transfer Function (PFE) - counts/in H2O

97d8: 01                  byte    1              EPTSW                             # Calibration switch (PFE) - 1 = enable update EPTZER at idle
97d9: 00                  byte    0              PFEHP                             # EGR type (0=sonic, 1=PFE, 2=none)

97da: c8,00               word     c8            IERPMH                            # Idle RPM hysteresis for EPTZER update (PFE)

97dc: 5a                  byte   5a              CTEHI                             # Minimum ECT to enable EPTZER update at idle (PFE)

97dd: ff                        

97de: 3d,00               word     3d            MINDES                            # Minimum desired EGR mass flow (PFE)
97e0: 0a,00               word      a            DESHYS                            # Hysteresis for MINDES (PFE)

## Filter factors for the various filter & rollav subroutine calls, mapped by encoded addresses
# number range d040 - d060,  maps to 97e8 - 9808
97e2: 00,01               word    100            TCDASD                            # Time constant for DSTPBR, throttle closing
97e4: 9a,02               word    29a            TCDASU                            # Time constant for DSTPBR, throttle opening
97e6: 33,0d               word    d33            TCDESN                            # Time constant for DESNLO (target idle RPM)
97e8: 01,00               word      1            TCDLOP                            # DELOPT output (d040)
97ea: 8f,00               word     8f            TCDP                              # BAP 1
97ec: 00,04               word    400            TCECT                             # ECT 
97ee: 71,00               word     71            TCEACT                            # EGRACT   (d046) (PFE only - not present in A9L)
97f0: 8f,00               word     8f            TCEPT                             # IEVP -> EPTBAR, EPTZER (d048)
97f2: 00,01               word    100            TCFAM                             # FAM      (d04a)
97f4: cd,04               word    4cd                                              # RPM 1    (d04c)
97f6: 00,08               word    800            TCTP                              # TP -> TPBAR (d04e)
97f8: ae,00               word     ae            TCVBAT                            # VBAT     (d050)
97fa: 29,00               word     29            TCVS                              # VSBAR    (d052)
97fc: 2e,00               word     2e            ldffact                           # LOAD     (d054)
97fe: 71,01               word    171                                              # BAP 2    (d056)
9800: 5c,03               word    35c            TCINJD                            # INJDLY output  (d058)
9802: a4,00               word     a4            TCMPH                             # MPH      (d05a)
9804: 00,6c               word   6c00                                              # RPM 2    (d05c)
9806: 5c,01               word    15c            TCTPT                             # TP -> TBART (d05e)
9808: 00,08               word    800            TCEGR                             # EVP -> EGRBAR (d060)

980a: 00,46               word   4600            VMLO
980c: 40                  byte   40              VIPT4

# High Vehicle Speed Spark Retard - FN179A(VSBAR)
  FN179A:
980d: ff,00   func              255,  0
980f: 00,00   func                0,  0
9811: 00,00   func                0,  0
9813: 00,00   func                0,  0
9815: 00,00   func                0,  0
9817: 00,00   func                0,  0
9819: 00,00   func                0,  0

# Fuel High Speed Multiplier - FN396A
  FN396A:
981b: ff,ff   func              255,255
981d: 00,ff   func                0,255
981f: 00,ff   func                0,255
9821: 00,ff   func                0,255
9823: 00,ff   func                0,255
9825: 00,ff   func                0,255
9827: 00,ff   func                0,255

9829: ff                        

# Func - sea level lugging Open Loop multiplier (vs rpm) - FN308(N)
  FN308:
982a: ff,ff,80,00   func        65535,  128
982e: 70,17,80,00   func         6000,  128
9832: c0,12,9a,00   func         4800,  154
9836: b8,0b,9a,00   func         3000,  154
983a: 28,0a,80,00   func         2600,  128
983e: 00,00,80,00   func            0,  128
9842: 00,00,80,00   func            0,  128

# Func - Altitude Lugging Open Loop Fuel Multiplier (RPM) - FN309(N)
  FN309:
9846: ff,ff,80,00   func        65535,  128
984a: 00,00,80,00   func            0,  128
984e: 00,00,80,00   func            0,  128
9852: 00,00,80,00   func            0,  128
9856: 00,00,80,00   func            0,  128
985a: 00,00,80,00   func            0,  128
985e: 00,00,80,00   func            0,  128

# Func - Fuel Crank PulseWidth Multiplier vs Time - FN306(CRKTMR)
  FN306:
9862: ff,ff,00,40   func        65535,16384
9866: 00,00,00,40   func            0,16384
986a: 00,00,00,40   func            0,16384
986e: 00,00,00,40   func            0,16384
9872: 00,00,00,40   func            0,16384
9876: 00,00,00,40   func            0,16384

# Cranking Fuel PulseWidth vs ECT - FN348(ECT)
  FN348:
987a: ff,7f,0c,02   func         32767,  524
987e: 5a,00,0c,02   func            90,  524
9882: 4b,00,5b,02   func            75,  603
9886: 23,00,d6,05   func            35, 1494
988a: 14,00,c1,0a   func            20, 2753
988e: 0a,00,7d,0e   func            10, 3709
9892: 00,00,6a,16   func             0, 5738
9896: f6,ff,b1,27   func           -10,10161
989a: 00,80,b1,27   func        -32768,10161

# Fuel Under RPM Pulsewidth vs ECT - FN387(ECT)
  FN387:
989e: 7f,40   func               127, 64
98a0: 80,40   func              -128, 64
98a2: 80,40   func              -128, 64
98a4: 80,40   func              -128, 64
98a6: 80,40   func              -128, 64
98a8: 80,40   func              -128, 64
98aa: 80,40   func              -128, 64
98ac: 80,40   func              -128, 64
98ae: 80,40   func              -128, 64

# PFE Exhaust Back Pressure Correction - FN004(BP)
# -  Barometric pressure correction for exhaust back pressure calculation
  FN004:
98b0: ff,ff   func              255,255
98b2: c4,d5   func              196,213
98b4: a2,b9   func              162,185
98b6: 00,40   func                0, 64
98b8: 00,40   func                0, 64

# PFE EGR Valve Upstream Pressure - FN074(AM * KAMREF)
#  -  Upstream pressure as a function of input(AM * KAMREF) output = H2O
  FN074:
98ba: ff,ff,00,59   func        65535,22784
98be: 00,80,00,59   func        32768,22784
98c2: 00,58,00,2a   func        22528,10752
98c6: 00,38,00,11   func        14336, 4352
98ca: 00,28,00,0c   func        10240, 3072
98ce: 00,20,00,09   func         8192, 2304
98d2: 00,0c,00,00   func         3072,    0
98d6: 00,00,00,00   func            0,    0
98da: 00,00,00,00   func            0,    0
98de: 00,00,00,00   func            0,    0

# EGR Multipiler for ECT - FN211
  FN211:
98e2: 7f,20   func               127,  32
98e4: 78,20   func               120,  32
98e6: 73,7f   func               115, 127
98e8: 41,7f   func                65, 127
98ea: 32,00   func                50,   0
98ec: 80,00   func              -128,   0

# Open loop fuel multiplier vs BP Sealevel - FN212A(BP)
  FN212A:
98ee: ff,80   func              255,128
98f0: de,80   func              222,128
98f2: d4,00   func              212,  0
98f4: 00,00   func                0,  0
98f6: 00,00   func                0,  0

# EGR Multiplier for BAP - FN217A(BP)
  FN217A:
98f8: ff,00   func              255,  0
98fa: de,00   func              222,  0
98fc: d4,80   func              212,128
98fe: bc,80   func              188,128
9900: b2,0d   func              178, 13
9902: 00,0d   func                0, 13

# EGR Mass Flow vs EGR Valve Position - FN219A(EVP - EOFF)
  FN219A:
9904: ff,ff,8a,00   func        65535,  138
9908: ff,00,8a,00   func          255,  138
990c: a2,00,5a,00   func          162,   90
9910: 71,00,42,00   func          113,   66
9914: 32,00,20,00   func           50,   32
9918: 00,00,00,00   func            0,    0

# EGR Multipiler for ACT - FN220(ACT)
  FN220:
991c: 7f,80   func               127,128
991e: 1c,80   func                28,128
9920: 00,66   func                 0,102
9922: 80,66   func              -128,102
9924: 80,66   func              -128,102

# EGR Position vs Desired Flow - FN221
  FN221:
9926: ff,ff,ff,00   func        65535,  255
992a: 8a,00,ff,00   func          138,  255
992e: 80,00,ec,00   func          128,  236
9932: 5a,00,a2,00   func           90,  162
9936: 42,00,71,00   func           66,  113
993a: 20,00,32,00   func           32,   50
993e: 00,00,00,00   func            0,    0

# EGR Duty Cycle Adder vs EGR Error - FN239(EGRERR)
  FN239:
9942: ff,7f,ae,07   func         32767,  1966
9946: 80,59,ae,07   func         22912,  1966
994a: 80,a6,52,f8   func        -22912, -1966
994e: 00,80,52,f8   func        -32768, -1966
9952: 00,80,52,f8   func        -32768, -1966
9956: 00,80,52,f8   func        -32768, -1966
995a: 00,80,52,f8   func        -32768, -1966

# EGR mass flow as a function of DELPR -  is this EGR Transfer Function?

995e: ff,ff,00,80   func        65535,32768
9962: 00,7f,00,80   func        32512,32768
9966: 00,3c,a4,70   func        15360,28836
996a: 00,32,66,66   func        12800,26214
996e: 00,28,9a,59   func        10240,22938
9972: 00,14,71,3d   func         5120,15729
9976: 00,0a,f6,28   func         2560,10486
997a: 00,05,29,1c   func         1280, 7209
997e: 00,02,00,00   func          512,    0
9982: 00,00,00,00   func            0,    0

# EGR Desired Drop vs Flow - FN247

9986: ff,ff,00,7f   func        65535,32512
998a: 00,80,00,7f   func        32768,32512
998e: a4,70,00,3c   func        28836,15360
9992: 66,66,00,32   func        26214,12800
9996: 9a,59,00,28   func        22938,10240
999a: 71,3d,00,14   func        15729, 5120
999e: f6,28,00,0a   func        10486, 2560
99a2: 29,1c,00,05   func         7209, 1280
99a6: 00,00,00,02   func            0,  512

99aa: 00,00,00,00               

# Table - Sea level EGR table - FN908A(N,LOAD)
# X = scaled RPM Y = scaled load. Output = Percent EGR
  FN908A:
99ae: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
99b8: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
99c2: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
99cc: 00,00,00,10,14,20,20,18,04,00   table   0,  0,  0, 16, 20, 32, 32, 24,  4,  0
99d6: 00,00,08,20,2c,2c,2c,22,04,00   table   0,  0,  8, 32, 44, 44, 44, 34,  4,  0
99e0: 00,00,08,20,24,26,20,17,00,00   table   0,  0,  8, 32, 36, 38, 32, 23,  0,  0
99ea: 00,00,08,0c,0c,0e,0f,0c,00,00   table   0,  0,  8, 12, 12, 14, 15, 12,  0,  0
99f4: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0

# Table - Altitude EGR table - FN908B(N,LOAD)
# X = scaled RPM Y = scaled load. Output = Percent EGR
  FN908B:
99fe: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
9a08: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
9a12: 00,00,00,08,0a,10,10,00,00,00   table   0,  0,  0,  8, 10, 16, 16,  0,  0,  0
9a1c: 00,00,00,14,26,28,24,20,1a,10   table   0,  0,  0, 20, 38, 40, 36, 32, 26, 16
9a26: 00,00,00,1c,24,22,20,14,13,08   table   0,  0,  0, 28, 36, 34, 32, 20, 19,  8
9a30: 00,00,00,10,10,10,0f,0a,0a,00   table   0,  0,  0, 16, 16, 16, 15, 10, 10,  0
9a3a: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0
9a44: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0

# MFA EGR Multiplier -  Multiplier used for ramping in managed fuel air tables.
  FN1223:
9a4e: 80,80,80,80   table       128,128,128,128
9a52: 2a,31,24,1d   table        42, 49, 36, 29
9a56: 00,0e,16,00   table         0, 14, 22,  0

# Canister Purge Duty Cycle Multiplier - FN600
  FN600:
9a5a: ff,80   func              255,128
9a5c: 00,80   func                0,128
9a5e: 00,80   func                0,128
9a60: 00,80   func                0,128
9a62: 00,80   func                0,128
9a64: 00,80   func                0,128

# Canister Purge Duty Cycle Multiplier - FN602
  FN602:
9a66: ff,80   func              255,128
9a68: 08,80   func                8,128
9a6a: 00,00   func                0,  0
9a6c: 00,00   func                0,  0
9a6e: 00,00   func                0,  0
9a70: 00,00   func                0,  0

# Canister Purge Duty Cycle vs Airmass - FN605A(AM)
 FN605A:
9a72: ff,80   func              255,128
9a74: 50,80   func               80,128
9a76: 28,33   func               40, 51
9a78: 14,2d   func               20, 45
9a7a: 0c,00   func               12,  0
9a7c: 00,00   func                0,  0

################################################### Reg 0xFC points here (9a7e)


9a7e: 5a,9e               word   9e5a

9a80: 00                  byte    0              PRLDSW                            # Percent Load Switch - Set for PERLOAD = LOAD,
                                                                                   # clear for PERLOAD = LOAD/FN035(N)
9a81: ff                        

#
# Rev and speed limiters
#

9a82: 00,7d               word   7d00            NLM_SH                            # RPM to turn on fuel cutoff rev limiter (x4)
9a84: 30,75               word   7530            NLM_CL                            # RPM to turn off fuel cutoff rev limiter (x4)

9a86: ff                  byte   ff              VVS_SH                            # MPH to turn on speed limiter (x2)
9a87: ff                  byte   ff              VVS_CL                            # MPH to turn off speed limiter (x2)
9a88: ff                  byte   ff              HVS_SH                            # MPH to turn on high speed fuel enrichment & spark retard (x2)
9a89: ff                  byte   ff              HVS_CL                            # MPH to turn off high speed fuel enrichment & spark retard (x2)

9a8a: 00,28               word   2800            VCAL                              # Nominal 2.5V calibration constant

9a8c: 3c                  byte   3c              OPCLT3                            # ATMR1 closed loop delay for TCSTRT >= CTHIGH
9a8d: 64                  byte   64              OPCLT2                            # ATMR1 closed loop delay for CTLOW < TCSTRT < CTHIGH
9a8e: 00                  byte    0              OPCLT5                            # ATMR2 closed loop delay for CTLOW < TCSTRT < CTHIGH
9a8f: 00                  byte    0              OPCLT1                            # ATMR1 closed loop delay for TCSTRT <= CTLOW
9a90: 03                  byte   03              OPCLT4                            # ATMR2 closed loop delay for TCSTRT <= CTLOW

9a91: ff                  byte   ff
9a92: c0,8a               word   8ac0            THBP5                             # Throttle breakpoint above RATCH for Open Loop Fuel, A/D counts.
9a94: 60,6d               word   6D60            NLMT ??                           # Fuel cutoff RPM (x4) (not used in this strategy)
9a96: 90,01               word    190            NLMTH ??                          # Hysteresis for NLMT  (not used in this strategy)

9a98: 01                  byte    1              EGOCL1                            # Min no of HEGO switches required for WARM_EGO_FLAG to be set.

9a99: ff                        

9a9a: a4,00               word     a4            LOLOD                             # Minimum LOAD to enter Closed Loop, unitless.
9a9c: a4,00               word     a4            LOLODH                            # Closed Loop Enable LOAD hysteresis.
9a9e: ae,07               word    7ae            HLODH                             # Upper LOAD Limit for Closed Loop Fuel Control,unitless

9aa0: 10                  byte   10              HLCTM                             # Time at high load to force Open Loop (1/8 secs)

9aa1: ff                        

9aa2: 66,a6               word   a666            LAMMAX                            # Desired A/F Ratio lean limit - is clipped to 1.30
9aa4: 00,60               word   6000            LAMMIN                            # Desired A/F Ratio rich limit - is clipped to 0.75

9aa6: 8f,02               word    2f8            MINAE                             # Not used

9aa8: 00,01               word    100            NUMCYL                            # Number of cylinders (x 0x20)
9aaa: 68,01               word    168            DEGPIP                            # Degrees between PIPs (x4)
9aac: 00,01               word    100            PIPOUT                            # Number of PIPs between injection events on same injector (x 0x20)
9aae: 01                  byte    1              CRKPIP                            # Number of PIPs between injector outputs during Crank
9aaf: 01                  byte    1              INJOUT                            # No of injectors fired by each port.
9ab0: 08                  byte    8              NUMOUT                            # NUMOUT - # of injector ports
9ab1: 01                  byte    1              OUTINJ                            # Injector Fire Method -  1 = sequential, 2 = bank fire
9ab2: 00                  byte    0              EDSEL                             # Injector crank timing - 0 = Falling edge of PIP 1 = Rising edge
9ab3: 00                  byte    0              FRCBFT                            # ACT/ECT proportion for FN1307 (0-7F)
9ab4: 00                  byte    0              FRCSFT                            # ACT/ECT proportion for FN1306 (0-7F)
9ab5: ff                  byte   ff

9ab6: 48,0d               word    d48            IDLRPM                            # Max RPM for IDLFLG (x 4) -  max rpm to set Idle Flag when Closed Throttle flag set.
9ab8: 20,03               word    320            IDRPMH                            # IDLRPM hysteresis

9aba: 58                  byte   58              MINTV                             # Injector timing for MFA, degrees/4
9abb: 58                  byte   58              MIDTV                             # Injector timing for idle in drive, degrees/4
9abc: 00                  byte    0              CIDRSW                            # 1 = Use MIDTV at idle in drive

9abd: 4b                  byte   4b              NITMR3                            # ATMR1 timed delay to enter Closed Loop fuel after Hot start, seconds.
9abe: bd                  byte   bd              NITMR2                            # ATMR1 timed delay to enter Closed Loop fuel after Medium start, seconds.
9abf: 00                  byte    0              NITMR5                            # ATMR2 timed delay to enter Closed Loop fuel after Medium start, seconds.
9ac0: 00                  byte    0              NITMR1                            # ATMR1 timed delay to enter Closed Loop fuel after Cold start, seconds.
9ac1: bd                  byte   bd              NITMR4                            # ATMR2 timed delay to enter Closed Loop fuel after Cold start, seconds.

9ac2: 80                  byte   80              AISFM                             # Actual Intake Surface Fuel Multiplier (0x80 = 1.0)

9ac3: 46                  byte   46              DFSECT                            # Decel Fuel Shut Off Min ECT

9ac4: 48,01               word    148            DFLOD                             # Decel Fuel Shut Off Max Load
9ac6: ec,01               word    1ec            DFLODH                            # Decel Fuel Shut Off Max Load Hysteresis.  
9ac8: 58,02               word    258            DSFRPM                            # Min RPM for Decel Fuel Shut Off.
9aca: 58,02               word    258            DSFRPH                            # Min RPM for Decel Fuel Shut Off Hysteresis.

9acc: 10                  byte   10              DSTM1                             # Decel Fuel Shut Off Neutral Max Time
9acd: 00                  byte    0              DSTM2                             # Decel Fuel Shut Off Shift Max Time - DSTM2
9ace: f8                  byte   f8              CTDFSO                            # Closed Throttle Decel Fuel Shutoff Min
9acf: f8                  byte   f8              CTEDSO                            # Decel Fuel Shut Off Time Extended - CTEDSO
9ad0: 06                  byte    6              DSFTM                             # Fuel Shut Off Min Time at PT
9ad1: 04                  byte    4              PIPNUM                            # Fuel Shut Off Min PIP To Remain O/L - PIPNUM

9ad2: c0,00               word     c0            TPHYS  ??                         # Not used (DFSO shift TP hysteresis?)
9ad4: 28,0a               word    a28            SHFRPM                            # Decel Fuel Shut Off Shift Min RPM
9ad6: 58,02               word    258            SHFHYS                            # Decel Fuel Shut Off Shift Min RPM Hysteresis
9ad8: 73,00               word     73            DMIN                              # Not used (DFSO Fuel Ramp back clip?)

9ada: 0a                  byte    a              DFSVS                             # Decel Fuel Shut Off Deceleration Min MPH
9adb: 04                  byte    4              DFSVSH                            # Deccel Fuel Shut Off Deceleration Min MPH Hysteresis

9adc: 00,00               word      0            DFLDL                             # Decel Fuel Shut Off Low Load Timer Enable
9ade: 00,00               word      0            DFLDH                             # Decel Fuel Shut Off Low Load Timer Disable

9ae0: 00                  byte    0              DLDFSO                            # Decel Fuel Low Load Shut Off Time, msec.
9ae1: 00                  byte    0              PTDFSW                            # Part Throttle Decel Fuel Shut Off Enable
9ae2: 55                  byte   55              MinECT_adp                        # Adaptive ECT Min - AFECT1
9ae3: 71                  byte   71              MaxECT_adp
9ae4: 32                  byte   32              Minact_adp                        # Min ACT for Adaptive Control - AFACT1
9ae5: 64                  byte   64              Maxact_adp                        # Max ACT for Adaptive Control - AFACT2

9ae6: 3c,00               word     3c            ADAPTM                            # Adaptive Delay Time - ADAPTM
9ae8: 7b,04               word    47b            DELAMB                            # Adaptive Lambda deadband
9aea: 40,00               word     40            DELROW                            # Adaptive engine speed transient lockout
9aec: 40,00               word     40            DELCOL                            # Adaptive load transient lockout

9aee: 61                  byte   61              MINADP                            # Adaptive Control Min (see GUFB p. 6-50)
9aef: 9f                  byte   9f              MAXADP                            # Adaptive Control Max

9af0: 00,00               word      0            AELIM                             # Max. accel enrichment to allow adaptive learning
9af2: 00,00               word      0            LMBJMP                            # Rich Correction on FAM exit (subtracted from LAMBSEn)
9af4: c5,00               word     c5            ADEFTR                            # Max. transient enrichment to allow adaptive learning

9af6: 00                  byte    0              ADEGCT
9af7: 00                  byte    0              FAEGCT
9af8: 06                  byte    6              KWUCNT                            # Adaptive Max Fast Cycles

9af9: 2e                  byte   2e              MULTM ??                          # Not used                                  
9afa: 00                  byte    0              HCAMSW                            # Adaptive Fuel Idle Hi-Cam Switch
                                                                                   # 1 = use idle adaptive fuel only when HCAMFG == 0
                                                                                   # 0 = ignore HCAMFG, always use idle adaptive

9afb: ff                        


# ATMR3 Scaler for FN1861 - FN018B
  FN018B:
9afc: ff,ff,00,05   func        65535, 1280
9b00: 1e,00,00,05   func           30, 1280
9b04: 0a,00,00,03   func           10,  768
9b08: 05,00,00,02   func            5,  512
9b0c: 00,00,00,00   func            0,    0

# Table - EGO bias/amplitude/delay tables RPM column scaling - FN039(N)
  FN039:
9b10: ff,ff,00,03   func        65535,  768
9b14: e0,2e,00,03   func        12000,  768
9b18: 10,0e,00,01   func         3600,  256
9b1c: f0,0a,00,00   func         2800,    0
9b20: 00,00,00,00   func            0,    0
9b24: 00,00,00,00   func            0,    0
9b28: 00,00,00,00   func            0,    0
9b2c: 00,00,00,00   func            0,    0

# Func - Injector Offset vs Battery Voltage - FN367(VBAT)
# X: Voltage x 16 (e.g. 12V = 192 = 0xC0)
# Y: Offset x 32 (e.g. 1 ms = 32 = 0x20)
  FN367:
9b30: ff,1d   func              255, 29
9b32: e0,1d   func              224, 29
9b34: d0,20   func              208, 32
9b36: c0,25   func              192, 37
9b38: b0,2d   func              176, 45
9b3a: a0,36   func              160, 54
9b3c: 90,41   func              144, 65
9b3e: 80,53   func              128, 83
9b40: 70,71   func              112,113
9b42: 60,b1   func               96,177
9b44: 58,f0   func               88,240
9b46: 00,f0   func                0,240

# Func - Open Loop Fuel Multiplier vs ACT - FN300(ACT)
  FN300:
9b48: 7f,40   func               127, 64
9b4a: 26,40   func                38, 64
9b4c: 00,34   func                 0, 52
9b4e: ec,29   func               -20, 41
9b50: 80,29   func              -128, 41
9b52: 80,29   func              -128, 41

# Func - Closed Throttle, Open Loop Fuel Multiplier vs RPM - FN301(N)
  FN301:
9b54: ff,ff,80,00   func        65535,  128
9b58: 00,00,80,00   func            0,  128
9b5c: 00,00,80,00   func            0,  128
9b60: 00,00,80,00   func            0,  128
9b64: 00,00,80,00   func            0,  128
9b68: 00,00,80,00   func            0,  128

# Func - Fuel Idle Neutral Multiplier - FN301N(N)
  FN301N:
9b6c: ff,ff,80,00   func        65535,  128
9b70: 00,00,80,00   func            0,  128
9b74: 00,00,80,00   func            0,  128
9b78: 00,00,80,00   func            0,  128
9b7c: 00,00,80,00   func            0,  128

# Func - WOT Fuel Multiplier vs RPM - FN303(N)
  FN303:
9b80: ff,ff,79,00   func        65535,  121
9b84: c0,5d,79,00   func        24000,  121
9b88: c0,44,7a,00   func        17600,  122
9b8c: 60,3b,7d,00   func        15200,  125
9b90: 00,32,79,00   func        12800,  121
9b94: 80,25,7c,00   func         9600,  124
9b98: 00,19,74,00   func         6400,  116
9b9c: 00,00,80,00   func            0,  128

# Table - MAF Backflow Correction - FN1035(N, LOAD)
# Multiplier of raw air mass to compensate for backflow in the MAF sensor.
  FN1035:
9ba0: 80,80,80,80,80,80,80,80,80,80   table 128,128,128,128,128,128,128,128,128,128
9baa: 80,80,80,80,80,80,80,80,80,80   table 128,128,128,128,128,128,128,128,128,128
9bb4: 80,80,80,80,80,80,80,80,80,80   table 128,128,128,128,128,128,128,128,128,128
9bbe: 80,83,80,80,80,80,80,80,80,80   table 128,131,128,128,128,128,128,128,128,128
9bc8: 80,83,83,80,80,80,80,80,80,80   table 128,131,131,128,128,128,128,128,128,128
9bd2: 84,84,84,80,80,80,80,80,80,80   table 132,132,132,128,128,128,128,128,128,128
9bdc: 86,86,85,80,80,80,80,80,80,80   table 134,134,133,128,128,128,128,128,128,128
9be6: 86,86,86,80,80,80,80,80,80,80   table 134,134,134,128,128,128,128,128,128,128

# Table - Base Open Loop Fuel - FN1307(ECT,PERLOAD)  
# 10 Cols: ECT [DegF]  -30,0,30,60,90,120,150,180,210,240      (FN022B)
#  8 Rows: PERLOAD []   .05, .15, .30, .40, .55, .70, .80, .90 (FN072A)
# Output is lambda, scaled air/fuel ratio
# (128 = 0x80 = 1.0 or stoichiometric; lower values more fuel, higher more air)
  FN1307:
9bf0: 8f,8f,8d,8a,85,83,80,7a,7a,7a   table 143,143,141,138,133,131,128,122,122,122
9bfa: 8d,8d,88,85,84,83,80,7a,7a,7a   table 141,141,136,133,132,131,128,122,122,122
9c04: 71,72,72,73,74,76,76,7a,7a,73   table 113,114,114,115,116,118,118,122,122,115
9c0e: 6d,73,73,73,77,7a,7a,80,80,76   table 109,115,115,115,119,122,122,128,128,118
9c18: 66,6f,72,73,77,77,7a,80,80,78   table 102,111,114,115,119,119,122,128,128,120
9c22: 61,61,6c,6c,6f,73,71,72,6d,6d   table  97, 97,108,108,111,115,113,114,109,109
9c2c: 5a,5a,66,66,69,6c,6e,6e,6d,6c   table  90, 90,102,102,105,108,110,110,109,108
9c36: 54,54,64,64,66,69,6c,6c,6c,6c   table  84, 84,100,100,102,105,108,108,108,108

# Table - Startup Fuel - FN1306
# Subtracted from Base Fuel table for warm up enrichment.  [A/F Ratio]
# fuel base (correct address? )
# 10 Cols: ECT [DegF]  -30,0,30,60,90,120,150,180,210,240  (FN022B)
#  8 Rows: Time [Sec]  0,3,5,10,15,25,35,45                (FN018)
  FN1306:
9c40: 1b,21,18,0f,0f,0f,0f,0b,0f,1b   table  27, 33, 24, 15, 15, 15, 15, 11, 15, 27
9c4a: 17,1d,15,0f,0f,0f,0f,0d,0f,17   table  23, 29, 21, 15, 15, 15, 15, 13, 15, 23
9c54: 16,16,13,0f,0f,0f,0f,0c,0f,16   table  22, 22, 19, 15, 15, 15, 15, 12, 15, 22
9c5e: 12,11,11,0f,0f,0f,0f,0a,0f,12   table  18, 17, 17, 15, 15, 15, 15, 10, 15, 18
9c68: 0d,0d,0c,0b,0a,0b,0b,09,0b,0d   table  13, 13, 12, 11, 10, 11, 11,  9, 11, 13
9c72: 0a,0c,09,08,08,0a,0a,07,08,0a   table  10, 12,  9,  8,  8, 10, 10,  7,  8, 10
9c7c: 08,0a,07,04,03,07,07,02,04,08   table   8, 10,  7,  4,  3,  7,  7,  2,  4,  8
9c86: 00,00,00,00,00,00,00,00,00,00   table   0,  0,  0,  0,  0,  0,  0,  0,  0,  0

# Peak Load at Sea Level vs RPM - FN035(N)
# Adjust if engine is substantially more efficient than stock and Percent Load Switch is not set.
  FN035:
9c90: ff,ff,1f,65   func        65535,25887
9c94: 20,4e,1f,65   func        20000,25887
9c98: b0,36,71,6d   func        14000,28017
9c9c: 40,1f,cd,5c   func         8000,23757
9ca0: 18,15,85,5b   func         5400,23429
9ca4: a0,0f,66,56   func         4000,22118
9ca8: 00,00,33,53   func            0,21299

# Percent Load Limit Open Loop vs ECT - FN320A
  FN320A:
9cac: ff,7f,9a,59   func         32767,22938
9cb0: 69,00,9a,59   func           105,22938
9cb4: 64,00,d7,63   func           100,25559
9cb8: 00,80,d7,63   func        -32768,25559
9cbc: 00,80,d7,63   func        -32768,25559
9cc0: 00,80,d7,63   func        -32768,25559
9cc4: 00,80,d7,63   func        -32768,25559

# Fuel Drive Engagement vs ECT - FN371
  FN371:
9cc8: ff,7f,00,01   func         32767,  256
9ccc: 00,80,00,01   func        -32768,  256
9cd0: 00,80,00,01   func        -32768,  256
9cd4: 00,80,00,01   func        -32768,  256
9cd8: 00,80,00,01   func        -32768,  256
9cdc: 00,80,00,01   func        -32768,  256
9ce0: 00,80,00,01   func        -32768,  256
9ce4: 00,80,00,01   func        -32768,  256

 # Equilibrium Intake Surface Fuel - FN1321(Temp,LOAD)
  FN1321:
9ce8: 87,87,80,79,70,5a,2e,02,02,02   table 135,135,128,121,112, 90, 46,  2,  2,  2
9cf2: 93,93,8c,84,7a,63,34,04,04,04   table 147,147,140,132,122, 99, 52,  4,  4,  4
9cfc: a3,a3,9a,91,86,6d,3a,05,04,04   table 163,163,154,145,134,109, 58,  5,  4,  4
9d06: b3,b3,a9,9e,92,78,43,08,07,06   table 179,179,169,158,146,120, 67,  8,  7,  6
9d10: c3,c3,b9,ad,a0,85,4e,0c,09,08   table 195,195,185,173,160,133, 78, 12,  9,  8
9d1a: d5,d5,c9,bd,af,94,5d,12,0d,09   table 213,213,201,189,175,148, 93, 18, 13,  9
9d24: e7,e7,dc,cf,c0,a7,75,1b,13,0b   table 231,231,220,207,192,167,117, 27, 19, 11
9d2e: ff,ff,f2,e3,d2,bf,98,29,1d,10   table 255,255,242,227,210,191,152, 41, 29, 16

# Equilibrium Fuel Time Constant - FN1322(Temp,LOAD)
# 10 Cols  8 Rows
  FN1322:
9d38: 18,18,18,18,18,18,20,30,30,30   table  24, 24, 24, 24, 24, 24, 32, 48, 48, 48
9d42: 18,18,18,18,18,18,20,30,30,30   table  24, 24, 24, 24, 24, 24, 32, 48, 48, 48
9d4c: 18,18,18,18,18,18,20,30,30,30   table  24, 24, 24, 24, 24, 24, 32, 48, 48, 48
9d56: 18,18,18,18,18,18,20,30,30,30   table  24, 24, 24, 24, 24, 24, 32, 48, 48, 48
9d60: 18,18,18,18,18,18,20,30,30,30   table  24, 24, 24, 24, 24, 24, 32, 48, 48, 48
9d6a: 18,18,18,18,18,18,20,30,30,30   table  24, 24, 24, 24, 24, 24, 32, 48, 48, 48
9d74: 18,18,18,18,18,18,20,30,30,30   table  24, 24, 24, 24, 24, 24, 32, 48, 48, 48
9d7e: 18,18,18,18,18,18,20,30,30,30   table  24, 24, 24, 24, 24, 24, 32, 48, 48, 48

# Table - Exhaust Pulse Delay - FN1351(N,LOAD)
# The time, in revs X 4, from when a fuel change is made until the HEGO sensor indicates this change. 
# Result is used to calculate the transport delay in PIPs and seconds.
  FN1351:
9d88: 28,28,28,28   table        40, 40, 40, 40
9d8c: 28,28,28,28   table        40, 40, 40, 40
9d90: 28,28,28,28   table        40, 40, 40, 40
9d94: 28,28,28,28   table        40, 40, 40, 40
9d98: 28,28,28,28   table        40, 40, 40, 40
9d9c: 28,28,28,28   table        40, 40, 40, 40
9da0: 28,28,28,28   table        40, 40, 40, 40
9da4: 28,28,28,28   table        40, 40, 40, 40

# Table - HEGO amplitude - FN1352(N,LOAD)
  FN1352:
9da8: 11,11,11,11   table        17, 17, 17, 17
9dac: 11,11,11,11   table        17, 17, 17, 17
9db0: 11,11,11,11   table        17, 17, 17, 17
9db4: 11,11,11,11   table        17, 17, 17, 17
9db8: 11,11,11,11   table        17, 17, 17, 17
9dbc: 11,11,11,11   table        17, 17, 17, 17
9dc0: 11,11,11,11   table        17, 17, 17, 17
9dc4: 11,11,11,11   table        17, 17, 17, 17

# Table - HEGO bias - FN1353(N,LOAD)
# Allows the averaged A/F ratio to be shifted slightly rich or lean to adjust emissions.
# A rich mixture will lower NOx but raise CO, a lean mixture will do the opposite.
  FN1353:
9dc8: 00,0e,0e,0e   table         0, 14, 14, 14
9dcc: 00,04,04,04   table         0,  4,  4,  4
9dd0: 00,00,00,00   table         0,  0,  0,  0
9dd4: 00,fc,fc,fc   table         0,252,252,252
9dd8: 00,fc,fc,fc   table         0,252,252,252
9ddc: fc,f8,f8,f8   table       252,248,248,248
9de0: fc,f4,f4,f4   table       252,244,244,244
9de4: f0,f0,f0,f0   table       240,240,240,240

# Func: DFSO Open Loop Fuel Multiplier - FN374(N)
  FN374:
9de8: ff,ff,00,00   func        65535,    0
9dec: 30,11,00,00   func         4400,    0
9df0: cc,10,80,00   func         4300,  128
9df4: 00,00,80,00   func            0,  128
9df8: 00,00,80,00   func            0,  128
9dfc: 00,00,80,00   func            0,  128

# Table - Adaptive Control Update Rate - FN1325(N,LOAD)
# 9 rows x 10 columns
# Last row corresponds to special idle cells
# Values 0-0x7F: Learning allowed in the corresponding LTMTB table cells
#                Updates allowed after 2x the cell value of b/g loops.
# Values 0x80-0xFF: Learning disallowed
#                   2's complement of the cell content is an indirection
#                   to a different LTMTB cell whose value should be used instead.
  FN1325:
9e00: ae,ae,ae,ae,ae,ae,ae,ae,ae,ae
9e0A: ae,ae,ae,ae,ae,ae,ae,ae,ae,ae
9e14: 64,64,0a,0a,0a,0a,0a,0a,0a,0a
9e1e: 64,64,0a,0a,0a,0a,0a,0a,0a,0a
9e28: d5,d5,d5,0a,0a,0a,0a,0a,0a,0a
9e32: cb,cb,cb,0a,0a,0a,0a,0a,0a,0a
9e3c: c1,c1,c1,0a,0a,0a,0a,0a,c7,c7
9e46: c7,c7,c7,c7,c7,c7,c7,c7,c7,c7
9e50: c7,c7,0a,0a,a7,a7,a7,a7,a7,64

################## Reg 0xFE points here (9e5a) ############################

9e5a: a2,9e               word   9ea2

9e5c: 03                  byte    3              TRLOAD                            # TRLOAD - Transmission Type:
                                                                                   #  0 = manual, no clutch or gear switches, forced neutral state
                                                                                   #  1 = manual, no clutch or gear switches
                                                                                   #  2 = manual, one clutch or gear switch
                                                                                   #  3 = manual, both clutch and gear switches
                                                                                   #  4 = non electronic auto, neutral drive switch
                                                                                   #  5 = non electronic auto, neutral pressure switch,
                                                                                   #  6 = electronic auto , PRNDL sensor
9e5d: 00                  byte    0              TSTRAT                            # TSTRAT - Transmission Strategy:
                                                                                   #  0 = no transmission control
                                                                                   #  1 = SIL (shift indicator light)
                                                                                   #  2 = A4LD with 3/4 shift control and convertor clutch control 
                                                                                   #  3 = AXOD
                                                                                   #  4 = C6E4 (E4OD)
                                                                                   #  5 = A4LD-E
                                                                                   #  6 = FAX-4
                                                                                   #  7 = AOD-4 (AOD-I)
                                                                                   #  8 = 4EAT
                                                                                   #  9 = CD4E
9e5e: 55                  byte   55              CTHIGH                            # Hot Start Min ECT -  The minimum ECT for a hot start condition to be recognised.
9e5f: 1c                  byte   1c              CTLOW                             # Cold Start Max ECT -  The maximum ECT for a cold start condition to be recognised.
9e60: 44                  byte   44              TEMPFB                            # Min ECT to start ATMR2

9e61: 08                  byte    8              ENGCYL                            # PIPs per revolution (x2)

9e62: 20,03               word  320              STALLN ?                          # Not used

9e64: 01                  byte    1              LAMSW                             # Lambda Reset Switch - Set nonzero if desired A/F ratio is to be clipped
                                                                                   #  no leaner than 1 (stoichiometric, 14.64:1 for gasoline)
                                                                                   #  when transiting from O/L to C/L.
9e65: 01                  byte    1              THRMHP                            # Thermactor H/W Present
                                                                                   #  0: Disables Inlet Air Control (IACFLG == 0)
                                                                                   #  1: Enables Thermactor Air
                                                                                   #  2: Enables Supercharger Strategy
                                                                                   #  3: Enables Inlet Air Control (IACFLG == 1)
9e66: 00                  byte    0              HP_CID                            # Cylinder ID Sensor Present
9e67: 00                  byte    0              HP_CIDSEL                         # CID Sensor Type - 1 = Variable Reluctance 0 = Hall Effect sensor.

# Signature PIP duty cycle, 8 cyls/<35% = .20, 6 cyls/< 30% = .24, 4 cyls/30% =  .29, Not present = 0.99

9e68: 33,33               word   3333            MHPFD                             # = .20
#
# Transient Spark constants
# GUFB pp. 7-27, 7-28
#
9e6a: 00,7d               word   7d00            TRSRPM                            # minimum RPM to use transient compensation for SPOUT (= 8000 RPM)
9e6c: 90,01               word    190            TRSRPH                            # hysteresis for above

9e6e: 02                  byte    2              DFMIN0                            # see GUFB p. 7-27
9e6f: 02                  byte    2              DFMIN1
#
9e70: 02                  byte    2              NUMEGO                            # no of EGO sensors - 0 = one sensor, 2 = two

9e71: ff                        

9e72: 2c,b3               word   b32c            KSF                               # Keypower Scaling Factor (GUFB p. 19-6, 19-26)
9e74: 00,02               word    200            MINAM                             # MAF Min Airmass Clip
9e76: 00,00               word      0            DELTAM                            # Multiplier of filtered air mass; used as a threshold
                                                                                   #  for using FAM instead of instantaneous AM
                                                                                   #  to calculate fuel

9e78: 3f                  byte   3f              AMDESN                            # Filtered Air Mass target idle RPM limit
9e79: 06                  byte    6              AMRPM                             # Filtered Air Mass threshold above DSDRPM
9e7a: 13                  byte   13              AMRPMH                            # Hysteresis for AMRPM
9e7b: 9a                  byte   9a              EFAMPH                            # Upper clip limit for AM, as % of FAM (0x80 = 100%)
9e7c: 66                  byte   66              EFAMPL                            # Lower clip limit for AM, as % of FAM

9e7d: ff                        

9e7e: 40,00               word     40            DLHYST                            # Hysteresis for DELRAT (Filtered Air Mass logic)
9e80: cd,08               word    8cd            IFAM                              # Upper FAM clip on exit from FAM
9e82: 00,60               word   6000            REQV
9e84: 66,a6               word   a666            LEQV
9e86: 33,73               word   7333            VRLAM_1

9e88: a0                  byte   a0              VIPTM3
9e89: 40                  byte   40              VISDL2                            # Not used
9e8a: 80                  byte   80              VISDL1
9e8b: ff                  byte   ff

9e8c: c8,00               word     c8            VISCN
9e8e: e8,03               word    3e8            ISUBND

9e90: 50                  byte   50              VISDL3
9e91: ff                  byte   ff

9e92: e8,03               word    3e8            ISLBND
9e94: 7d,00               word     7d            NGOOSE
9e96: 9a,09               word    99a            VSIBRM
9e98: 66,f6               word   f666            VSIBRN
9e9a: 93,00               word     93            VPSIND
9e9c: bd,00               word     bd            VPSINU
9e9e: 05,00               word      5            V860

9ea0: 80                  byte   80              V820A


##### 9ea1 to 9fff = 0xff (unused) #####
